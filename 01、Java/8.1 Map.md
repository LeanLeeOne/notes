![](../images/1/map.png)

## 常用的Map

### HashMap

在**Java8**之前，采用**拉链法**；**Java8**将<u>链表</u>改为<u>红黑树</u>（链表长度大于8时会转换为<u>红黑树</u>）。

线程不安全，多线程同时操作时，在扩容阶段会产生<span style=background:#c2e2ff>循环链表</span>。

扩容是一个开销巨大的操作，所以我们最好提前<span style=background:#c2e2ff>指定容量</span>，避免频繁扩容。

### HashTable

`HashTable`是线程安全的，通过在方法上添加`synchronized`实现，但是性能弱于`ConcurrentHashMap`，属于远古遗留类，**没人会用**。

### ConcurrentHashMap

`ConcurrentHashMap`在**Java8**之前使用`Segment`（段落锁）来实现，**Java8**中采用CAS+`sychronized`来实现，优化了并发性能，同时使用<u>红黑树</u>增强了读操作。

#### 段落锁

1. ```java
   static final class Segment extends ReentrantLock implements Serializable
   ```

2. `Segment`中的也采用**拉链法**，其数组为`HashEntry[] table`，`HashEntry`中的V、链表均由`volatile`修饰，保证可见性，即每次获取的都是新值。

3. 进行插入操作时，需要加锁，加锁失败则表示存在线程竞争，此时[会自旋获取锁](https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/)，重试次数达到阈值后会改为**阻塞锁**获取。

### TreeMap

`TreeMap`不同于前面3个，是有序的，默认按照键来排序。

`TreeMap`要求键对象实现`Comparable.compareTo()`，或者传入一个`Comparator`的实现类来进行**键**的比较。

`TreeMap`也是采用<u>红黑树</u>来存储。

### LinkedHashMap

`LinkedHashMap`在`HashMap`的基础上使用**双向链表**来保证元素间的**顺序**。



## HashMap的结构和原理[[1]](https://tech.meituan.com/2016/06/24/java-hashmap.html)

### 存储结构

1. `Node[] table`，哈希桶数组。`Node`是`HashMap`的内部类，实现了`Map.Entry`接口

   1. ```java
      static class Node implements Map.Entry
      ```

   2. `table`的长度为`2^n`，默认为16，虽然`table`长度为**素数**能减少冲突的概率，但采用`2^n`的设计方便后续在高位运算、取模运算时进行优化。

2. `int threshold`，所能容纳的<u>键值对</u>的极限。

   1. `threshold = table.length * loadFactor`。
   2. <u>键值对</u>数量超过该阈值后就会**扩容**（resize），容量会**翻番**。

5. `final float loadFactor`，负载因子，默认为0.75。

6. `int modCount`，统计内部结构发生变化的次数，即<u>键值对</u>插入、删除的次数，用于序列化、迭代。

7. `int size`，<u>键值对</u>的实际数量。

### 功能实现

#### 散列

1. ```java
   key.hashCode();
   ```

   1. 获取Hash值

2. ```java
   (h = key.hashCode()) ^ (h >>> 16);
   ```

   1. 高位参与运算。
   2. 这样的设计在`table.length`较小时，也能保证保证高低位都会参与到计算中，同时不会有太大开销。

3. ```java
   h & (table.length - 1);
   ```

   1. 取模运算。
   2. 直接进行模运算虽然能均匀分布键，但消耗巨大，故`HashMap`采用了这样的方式来优化。
   3. 如上文所说，`table`的长度为`2^n`，所以该与运算等同于模运算，而与运算速度比模运算要快。

#### 插入<u>键值对</u>

略。

> 如果<u>键值对</u>已经存在，则直接覆盖。

#### 扩容

1. 用更大的数组替换原来的数组。 	
2. 扩容后<u>键值对</u>会重新分配位置。

### 使用

1. 推荐使用`Iterator>> iterator = map.entrySet().iterator()`的方式对<u>键值对</u>进行遍历，因为这种方式可以直接获取<u>键值对</u>。
2. 使用`Iterator iterator = map.keySet().iterator()`的方式进行遍历还需要再定位<u>键值对</u>位置，再获取值。

