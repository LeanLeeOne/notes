**《与临界区》**

<span style=background:#b3b3b3>Object.wait()/wait(long)</span>、<span style=background:#b3b3b3>Object.notify()/notifyAll()</span>必须在<span style=background:#d4fe7f>临界区</span>中使用，且必须针对<u>同一个</u><span style=background:#c2e2ff>锁对象</span>。

<span style=background:#b3b3b3>Object.wait()/wait(long)</span>、<span style=background:#b3b3b3>Object.notify()/notifyAll()</span>是通过JVM中的park/unpark机制来实现的，该机制在Linux中又是通过pthread_cond_wait/pthread_cond_signal来实现的。




**《等待与唤醒》**

**等待**是指线程让出CPU并被放入到<span style=background:#f8d2ff>等待队列</span>中，**唤醒**实际上是指将<span style=background:#f8d2ff>等待队列</span>中线程放入<span style=background:#ffb8b8>同步队列</span>：

1. <span style=background:#b3b3b3>Object.notify()</span>按照<span style=background:#c2e2ff>FIFO</span>（First In First Out）策略唤醒线程：
   1. 线程调用<span style=background:#b3b3b3>Object.wait()/wait(long)</span>后被放入<span style=background:#f8d2ff>等待队列</span>的尾部，当其他线程调用<span style=background:#b3b3b3>Object.notify()</span>或运行时间到后，
   2. 会将<span style=background:#f8d2ff>等待队列</span>的**头部**节点取出，插入到<span style=background:#ffb8b8>同步队列</span>的**尾部**，即线程的状态变为**Blocked**，与<span style=background:#ffb8b8>同步队列</span>中的其他线程一起竞争锁。
2. <span style=background:#b3b3b3>Object.notifyAll()</span>按照<span style=background:#c2e2ff>LIFO</span>（Last In First Out）策略唤醒线程：
   1. 线程调用<span style=background:#b3b3b3>Object.wait()/wait(long)</span>后被放入<span style=background:#f8d2ff>等待队列</span>的尾部，当其他线程调用<span style=background:#b3b3b3>Object.notifyAll()</span>后，
   2. 会将<span style=background:#f8d2ff>等待队列</span>的**头部**节点逐个取出（也有可能是直接从头到尾遍历），不停地插入到<span style=background:#ffb8b8>同步队列</span>的**头部**，<span style=background:#f8d2ff>等待队列</span>的尾节点反而变成了<span style=background:#ffb8b8>同步队列</span>的头节点，即“后入先出”。

<span style=background:#b3b3b3>Object.notify()/notifyAll()</span>不会立即释放对象锁，也不会立即唤醒线程，而是等持锁线程执行完**synchronized**方法或代码块后才释放、唤醒。<span style=background:#ffee7c>（为什么呢？）</span>

<span style=background:#b3b3b3>Object.notify()</span>选择唤醒的线程是任意的，但依赖于具体实现的JVM：

1. <span style=background:#f8d2ff>等待队列</span>中的线程，在不同版本的JDK里，会处于<span style=background:#f8d2ff>等待队列</span>的不同位置。
2. JDK8中，调用notify()唤醒的是<span style=background:#f8d2ff>等待队列</span>中的头节点，即等待时间最长的那个线程。
3. 注意，**synchronized**是非公平的，允许抢占，抢占过程具有一定的随机性，如果**synchronized**中混合有<span style=background:#b3b3b3>Thread.sleep(long)</span>时[会“加剧”抢占](https://www.jianshu.com/p/99f73827c616)，影响唤醒顺序。

[该文章](https://www.jianshu.com/p/ffc0c755fd8d)的评论中有人提到，<span style=background:#b3b3b3>Object.notify()</span>是有好几种机制的，不过无法通过参数配置，且JDK8后只保留了默认策略。



**《中断》**

<span style=background:#b3b3b3>Thread.interrupt()</span>只是向目标线程发送中断<span style=background:#c2e2ff>请求</span>，是否响应中断<span style=background:#c2e2ff>请求</span>（结束运行）取决于目标线程自身的代码编写。

1. 当目标线程处于**Runnable**状态时，可通过<span style=background:#b3b3b3>Thread.isInterrupted()</span>查看是否有中断请求。
2. 当目标线程处于**Blocked**、**Waiting**、**Timed** **Waiting**等状态时，对应的<span style=background:#b3b3b3>Object.wait()/wait(long)</span>、<span style=background:#b3b3b3>Thread.sleep(long)</span>、<span style=background:#b3b3b3>Thread.join()/join(long))</span>会直接抛出**InterruptedException**，是否中断（结束运行）还是取决于代码如何编写的。
3. 但是该方法不能中断IO阻塞和**synchronized**阻塞。