## 从连等号开始说起

运算符`==`用于比较对象是否相等，它比较的是对象的<span style=background:#c2e2ff>地址</span>是否相同。

作为面向对象的语言，Java理所应当地提供<span style=background:#c2e2ff>Object.equals()</span>方法来进行对象的比较，当然其实质还是使用运算符`==`来进行比较。

> 8类基本类型的值都按照常量存储，比较的也是地址。



## 覆写Object.equals()🌙

对于某些对象，我们关心的是对象的**内容**是否相等，而非其**地址**是否相等。可是Java不支持运算符的重载，即，运算符无法进行覆写，但是，Java的支持覆写方法。

所以对于需要比较内容是否相等的对象，我们可以通过覆写<span style=background:#c2e2ff>Object.equals()</span>来实现。

- `String.equals()`就是典型代表，它比较的是字符数组中的每个字符是否相等。
- `List.contains()`、`List.indexOf()`也是通过调用覆写后的<span style=background:#c2e2ff>Object.equals()</span>来判断对象是否存在，而非运算符`==`。

当然有时内容不相等并不代表值不相等，比如`1.0`与`1.00`，所以`BigDecimal`才通过`Comparable.compareTo()`来进行值相等的判断。

### 实现

对于<span style=background:#c2e2ff>Object.equals()</span>的覆写需遵循：自反性、对称性、传递性、一致性、与`null`比较返回`false`等原则。

- 具体到覆写`equals()`的代码，会先用`instanceof`判断类型，再对各个属性进行比较。



## HashMap与对象比较

`HashMap`要求Key对应的类不仅要覆写<span style=background:#c9ccff>Object.hashCode()</span>，还要覆写<span style=background:#c2e2ff>Object.equals()</span>：

1. `HashMap`基于“<u>散列表</u>”，这就要求Key能够散列，也就需要覆写<span style=background:#c9ccff>int Object.hashCode()</span>。
2. 但是**散列冲突**是无法避免的，当Key的<u>散列值</u>冲突时，我们就需要对Key是否相等做进一步判断了，确切地说是应判断Key的内容是否相等，而非Key的地址是否不相等，也就是说需要覆写<span style=background:#c2e2ff>Object.equals()</span>。

其实不止**散列冲突**需要判断Key是否相等，判断Key（<u>键值对</u>）是否存在，以及新插入<u>键值对</u>时，都需要判断Key是否相等。	

- 判断过程先调用<span style=background:#c9ccff>Object.hashCode()</span>，若相等再调用<span style=background:#c2e2ff>Object.equals()</span>进行判断。
- 换个角度想，如果直接调用<span style=background:#c2e2ff>Object.equals()</span>，我们需要遍历每个Key，效率低；而先调用<span style=background:#c9ccff>Object.hashCode()</span>能有效缩小范围，减少遍历次数。

### 实现

<span style=background:#c9ccff>Object.hashCode()</span>的覆写须遵循：

1. <span style=background:#c2e2ff>Object.equals()</span>为`true`，则<span style=background:#c9ccff>Object.hashCode()</span>为`true`。
2. <span style=background:#c2e2ff>Object.equals()</span>为`false`，则<span style=background:#c9ccff>Object.hashCode()</span>为尽量为`false`。
3. 结合前两条不难推断出，<span style=background:#c9ccff>Object.hashCode()</span>中用于生成<u>散列值</u>的字段，必须属于<span style=background:#c2e2ff>Object.equals()</span>中用于作判断的字段。

为了<u>散列值</u>的均匀性，会将每个域当作R进制中的一位，[R一般取31](https://www.cyc2018.xyz/Java/Java 基础.html#hashcode)。

```java
31*x == (x<<5) - x;
```




## TreeMap与对象比较

`TreeMap`是一种`SortMap`，它跟Hash（散列）没任何联系。

`SortMap`也需要对Key的内容是否相等进行判断，确切地说，它需要对Key的大小进行判断以便排序。

所以`SortMap`没有调用的Key的<span style=background:#c2e2ff>Object.equals()</span>，而是要求Key实现`Comparable.compareTo()`，或者传入一个`Comparator`的实现类来进行Key的比较。