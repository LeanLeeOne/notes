## 索引[[3]](https://doris.apache.org/zh-CN/docs/dev/data-table/index/index-overview/)

**Doris**仅支持在Key字段上创建索引。

**Doris**支持两类索引：

1. 内建的（对用户透明）智能索引，包括前缀索引和ZoneMap索引。
2. 用户手动创建的二级索引，包括[倒排索引](https://doris.apache.org/zh-CN/docs/dev/data-table/index/inverted-index)、[Bloom Filter索引](https://doris.apache.org/zh-CN/docs/dev/data-table/index/bloomfilter)、[N-Gram Bloom Filter索引](https://doris.apache.org/zh-CN/docs/dev/data-table/index/ngram-bloomfilter-index) 和[Bitmap索引](https://doris.apache.org/zh-CN/docs/dev/data-table/index/bitmap-index)。

前缀索引、ZoneMap索引建立在对Key排序的基础上，同时也建立在字段的Block（`1024`行）级别上。

> ZoneMap索引包含整型、日期类型字段/每一列的`MIN`、`MAX`、`NULL`值个数等信息。

### 前缀索引

**Doris**支持前缀索引：取Key的前`36Byte`作为前缀，来创建索引，但遇到`VARCHAR`类型的字段时，前缀会直接截断，并且最多使用`VARCHAR`的前`20Byte`。

前缀索引的字段上的过滤条件仅支持`=`、`<`、`>`、`<=`、`>=`、`IN`和`BETWEEN`，并且过滤条件使用`AND`连接（并列的且关系），而非`OR`、`<>`/`!=`。

> 换句话说，`VARCHAR`类型的字段只能作为前缀索引的最后一个字段。
>
> Bloom Filter索引对区分度大/基数大的字段过滤效果明显，如果`VARCHAR`类型的字段不能放在前缀索引中，可以考虑Bloom Filter索引。
>
> 不难看出，**Doris**的前缀索引是稀疏的、粗粒度的：根据给定前缀字段，快速定位Block，然后做二分查找。

### 倒排索引

与**Doris**中其他索引不同的，倒排索引在存储层使用独立的文件，跟Segment文件有逻辑对应关系、但存储的文件相互独立。这样的好处是可以做到创建、删除索引不用重写Tablet和Segment文件，大幅降低处理开销。



## Rollup

**Doris**支持创建针对单个Base表的物化Rollup表。

- Base，基础：在**Doris**中，通过`CREATE TABLE`创建的表被称为原始表或基础表。
- Rollup，上卷：在多维分析中，将数据按指定的粒度进行进一步聚合。

> 下文将Base表、Rollup表分别简称为Base、Rollup。

### 作用

Rollup通过将聚合结果（更粗粒度）物化的方式来减少Key/数据量，从而提高某些查询的效率。

Rollup中的字段顺序可以与Base中的不同，并且**Doris**不仅会自动地为Base生成和维护前缀索引，还会自动地为每个Rollup生成和维护前缀索引，所以，按需创建Rollup能有效增加前缀索引的命中率，也正因此，Rollup的含义已经超出了 “上卷” 的范围，故在源代码中，被命名为物化索引（Materialized Index）。

> 物化索引的名称并不确切，更确切的名称是，自带稀疏的前缀索引的、经过物化的自动聚合表。

### 特点

Rollup不能单独创建，必须构建于Base之上。Rollup可以创建多个。Rollup一经创建便不能修改。Rollup的创建是异步的，即，用户提交创建任务后，**Doris**会在后台对存量的数据进行计算，直到创建成功。

Rollup与Base是强一致的，其强一致性由**Doris**自动维护。

Rollup在物理上独立存储，创建地越多，占用的磁盘空间也就越大，同时由于在导入的ETL阶段会自动产生所有Rollup的数据，故会影响导入速度，但是不会降低、只会提高查询效率。

查询时仅需指定Base，无需也无法指定Rollup，**Doris**会根据查询条件自动前缀索引选择最长、创建较早、行数最少的一个Base或Rollup。

如果`DELETE`语句中的过滤条件中的Key，不存在于Rollup中，则语句不能被执行。此时，需先将Rollup删除，然后方可删除数据。

### 命中

查询时，要命中Rollup需满足以下条件，否则只能命中：

1. 查询或者子查询中涉及的所有字段都存在于同一张Rollup中。
2. 如果查询或者子查询中有`JOIN`，其类型必须是`INNER JOIN`。

> 可以通过`EXPLAIN sql;`查看执行计划中ScanNode节点的PreAggregation的值来判断是否命中Rollup，以及Rollup字段来判断命中的是哪一张Rollup。



## 物化视图

**Doris**中的物化视图分为同步和异步两种。

> 同步物化视图不支持直接查询，但异步物化视图支持。

### 同步物化视图

**Doris**中的同步物化视图只能构建于一张表上，即，创建语句中不支持`JOIN`，也正因此，**Doris**中的同步物化视图不是真正意义上物化视图，更像是克服了部分局限性的增强版的Rollup：

- Rollup仅支持对Aggregate模型做聚合，同步物化视图支持对Duplicate模型做聚合。
- Rollup的聚合方式有限，即，字段的聚合方式无需也无法修改、必须与Base完全相同，也正因此，Rollup仅支持`COUNT`、`MAX`、`MIN`、`SUM`聚合方式；同步物化视图支持更丰富的聚合函数，除了`COUNT`、`MAX`、`MIN`、`SUM`外，还支持`PERCENTILE_APPORX`、`HLL_UNION`等，并且字段的聚合方式不必与Base相同。

> 对于Unique模型，无论是Rollup，还是同步物化视图，都只能被用于调整Key的顺序，不支持做物化聚合。

同步物化视图的刷新与基表保持一致。

同步物化视图的定义，不是与每个特定的查询一模一样最好，因为维护同步物化视图是有开销的；也不是越抽象越好，越能匹配上更多的分组和聚合方式越好，越能被复用越好，因为这对具体查询的提升是有限的，换句话说，定义同步物化视图时需要平衡时间和空间。

### 异步物化视图

异步物化视图支持多表，借助集群内外的调度来定时更新。

异步物化视图支持全量刷新或分区增量刷新。

> 分区增量刷新：当异步物化视图的基表的分区数据发生变化时，识别出对应变化的分区并对其刷新（增量），无需刷新整个异步物化视图。



## [高并发点查](https://doris.apache.org/zh-CN/docs/dev/query-acceleration/hight-concurrent-point-query)

**Doris**基于列存格式引擎构建，在高并发服务场景中，用户总是希望从系统中获取整行数据。但是，当表宽时，列存格式将大大放大随机读取 IO。Doris 查询引擎和计划对于某些简单的查询（如点查询）来说太重了。需要一个在 FE 的查询规划中规划短路径来处理这样的查询。FE 是 SQL 查询的访问层服务，使用 Java 编写，分析和解析 SQL 也会导致高并发查询的高 CPU 开销。为了解决上述问题，我们在 Doris 中引入了行存、短查询路径、PreparedStatement 。

### 行存

用户可以在 Olap 表中开启行存模式，但是需要额外的空间来存储行存。目前的行存实现是将行存编码后存在单独的一列中，这样做是用于简化行存的实现。

### 使用 `PreparedStatement`

为了减少 SQL 解析和表达式计算的开销， 我们在 FE 端提供了与 MySQL 协议完全兼容的`PreparedStatement`特性（目前只支持主键点查）。当`PreparedStatement`在 FE 开启，SQL 和其表达式将被提前计算并缓存到 Session 级别的内存缓存中，后续的查询直接使用缓存对象即可。

### 开启行缓存

Doris 中有针对 Page 级别的 Cache，每个 Page 中存的是某一列的数据，所以 Page cache 是针对列的缓存，对于前面提到的行存，一行里包括了多列数据，缓存可能被大查询给刷掉，为了增加行缓存命中率，单独引入了行存缓存



## 数据表的查询

### 关联

**Doris**默认使用Broadcast Join。Shit，文档前后矛盾呀，可能是说对数据量的预估不准：

- 如果预估的小表，在过滤后仍然无法放入内存，Broadcast Join将无法完成，进行报错。
- 如果预估小表过大，则会自动切换为Shuffle Join。

### 数据更新和删除

**Doris**提供`2`种删除方式：

- 通过`DELETE FROM WHERE`语句，比较通用，适合频率较低的定时删除任务。
- 对于Unique模型，可以通过导入数据的方式将需要删除的主键行数据进行导入。**Doris**内部会通过删除标记位对数据进行最终的物理删除。这种删除方式适合以实时的方式对数据进行删除。

### 技巧

**Doris**支持[从结果中排除](https://doris.apache.org/zh-CN/docs/dev/data-table/basic-usage/#select--except)的一个或多个列的名称：`SELECT * EXCEPT`。

**Doris**支持对两个表进行[原子替换](https://doris.apache.org/zh-CN/docs/dev/advanced/alter-table/replace-table/)：`ALTER TABLE [db.]tbl1 REPLACE WITH TABLE tbl2 [PROPERTIES('swap' = 'true')];`。



# [Bucket Shuffle Join](https://doris.apache.org/zh-CN/docs/dev/query-acceleration/join-optimization/bucket-shuffle-join)

## 原理

相比于Broadcast Join与Shuffle Join， Bucket Shuffle Join有着较为明显的性能优势。减少数据在节点间的传输耗时和Join时的内存开销。相对于Doris原有的Join方式，它有着下面的优点

- 首先，Bucket-Shuffle-Join降低了网络与内存开销，使一些Join查询具有了更好的性能。尤其是当FE能够执行左表的分区裁剪与桶裁剪时。
- 其次，同时与Colocate Join不同，它对于表的数据分布方式并没有侵入性，这对于用户来说是透明的。对于表的数据分布没有强制性的要求，不容易导致数据倾斜的问题。
- 最后，它可以为Join Reorder提供更多可能的优化空间。

## 使用方式

### 设置Session变量

在FE进行分布式查询规划时，优先选择的顺序为 Colocate Join -> Bucket Shuffle Join -> Broadcast Join -> Shuffle Join。但是如果用户显式hint了Join的类型，则上述的选择优先顺序则不生效。

## Bucket Shuffle Join的规划规则

在绝大多数场景之中，用户只需要默认打开session变量的开关就可以透明的使用这种Join方式带来的性能提升，但是如果了解Bucket Shuffle Join的规划规则，可以帮助我们利用它写出更加高效的SQL。

- Bucket Shuffle Join只生效于Join条件为等值的场景，原因与Colocate Join类似，它们都依赖hash来计算确定的数据分布。
- 在等值Join条件之中包含两张表的分桶列，当左表的分桶列为等值的Join条件时，它有很大概率会被规划为Bucket Shuffle Join。
- 由于不同的数据类型的hash值计算结果不同，所以Bucket Shuffle Join要求左表的分桶列的类型与右表等值join列的类型需要保持一致，否则无法进行对应的规划。
- Bucket Shuffle Join只作用于Doris原生的OLAP表，对于ODBC，MySQL，ES等外表，当其作为左表时是无法规划生效的。
- 对于分区表，由于每一个分区的数据分布规则可能不同，所以Bucket Shuffle Join只能保证左表为单分区时生效。所以在SQL执行之中，需要尽量使用`where`条件使分区裁剪的策略能够生效。
- 假如左表为Colocate的表，那么它每个分区的数据分布规则是确定的，Bucket Shuffle Join能在Colocate表上表现更好。

# [Colocation Join](https://doris.apache.org/zh-CN/docs/dev/query-acceleration/join-optimization/colocation-join)

Colocation Join旨在为某些 Join 查询提供本地性优化，来减少数据在节点间的传输耗时，加速查询。

## 名词解释

- Colocation Group（CG）：一个 CG 中会包含一张及以上的 Table。在同一个 Group 内的 Table 有着相同的 Colocation Group Schema，并且有着相同的数据分片分布。
- Colocation Group Schema（CGS）：用于描述一个 CG 中的 Table，和 Colocation 相关的通用 Schema 信息。包括分桶列类型，分桶数以及副本数等。

## 原理

Colocation Join 功能，是将一组拥有相同 CGS 的 Table 组成一个 CG。并保证这些 Table 对应的数据分片会落在同一个 BE 节点上。使得当 CG 内的表进行分桶列上的 Join 操作时，可以通过直接进行本地数据 Join，减少数据在节点间的传输耗时。

每个 Bucket 内会有一个或多个数据分片（Tablet）。当表为单分区表时，一个 Bucket 内仅有一个 Tablet。如果是多分区表，则会有多个。

为了使得 Table 能够有相同的数据分布，同一 CG 内的 Table 必须保证以下属性相同：

1. 分桶列和分桶数
2. 副本数

同一个 CG 内的表，分区的个数、范围以及分区列的类型不要求一致。

## 使用方式

### 建表

如果 Group 已存在，则 Doris 会检查当前表是否满足 Colocation Group Schema。如果满足，则会创建该表，并将该表加入 Group。同时，表会根据已存在的 Group 中的数据分布规则创建分片和副本。 Group 归属于一个 Database，Group 的名字在一个 Database 内唯一。在内部存储是 Group 的全名为 `dbId_groupName`，但用户只感知 groupName。

## Colocation 副本均衡和修复

Colocation 表的副本分布需要遵循 Group 中指定的分布，所以在副本修复和均衡方面和普通分片有所区别。

Group 自身有一个 Stable 属性，当 Stable 为 true 时，表示当前 Group 内的表的所有分片没有正在进行变动，Colocation 特性可以正常使用。当 Stable 为 false 时（Unstable），表示当前 Group 内有部分表的分片正在做修复或迁移，此时，相关表的 Colocation Join 将退化为普通 Join。

### 副本均衡

 Colocation 表的均衡是 Bucket 级别的，即一个 Bucket 内的所有副本都会一起迁移。我们采用一个简单的均衡算法，即在不考虑副本实际大小，而只根据副本数量，将 BucketsSequence 均匀的分布在所有 BE 上。

当前的 Colocation 副本均衡和修复算法，对于异构部署的 Doris 集群效果可能不佳。

# [Runtime Filter](https://doris.apache.org/zh-CN/docs/dev/query-acceleration/join-optimization/runtime-filter)

Runtime Filter旨在为某些 Join 查询在运行时动态生成过滤条件，来减少扫描的数据量，避免不必要的I/O和网络传输，从而加速查询。

## 名词解释

- 左表：进行Probe操作。可被Join Reorder调整顺序。
- 右表：进行Build操作。可被Join Reorder调整顺序。
- Join on clause: `A join B on A.a=B.b`中的`A.a=B.b`，在查询规划时基于此生成join conjuncts，包含join Build和Probe使用的expr，其中Build expr在Runtime Filter中称为src expr，Probe expr在Runtime Filter中称为target expr。

## 原理

Runtime Filter在查询规划时生成，在HashJoinNode中构建，在ScanNode中应用。

和谓词下推、分区裁剪不同，Runtime Filter是在运行时动态生成的过滤条件，即在查询运行时解析join on clause确定过滤表达式，并将表达式广播给正在读取左表的ScanNode，从而减少扫描的数据量，进而减少probe hash table的次数，避免不必要的I/O和网络传输。

Runtime Filter主要用于大表join小表的优化，如果左表的数据量太小，或者右表的数据量太大，则Runtime Filter可能不会取得预期效果。

# [Doris Join 优化原理](https://doris.apache.org/zh-CN/docs/dev/query-acceleration/join-optimization/doris-join-optimization)

Doris 支持两种物理算子，一类是 **Hash Join**，另一类是 **Nest Loop Join**。

 假设关系S 和 R 进行Join，N 表示参与 Join 计算的节点的数量；T 则表示关系的 Tuple 数目。

## Doris Shuffle 方式

### 四种 Shuffle 方式对比

| Shuffle方式    | 网络开销    | 物理算子                   | 适用场景                                                     |
| -------------- | ----------- | -------------------------- | ------------------------------------------------------------ |
| BroadCast      | N * T(R)    | Hash Join / Nest Loop Join | 通用                                                         |
| Shuffle        | T(S) + T(R) | Hash Join                  | 通用                                                         |
| Bucket Shuffle | T(R)        | Hash Join                  | Join条件中存在左表的分布式列，且左表执行时为单分区           |
| Colocate       | 0           | Hash Join                  | Join条件中存在左表的分布式列，且左右表同属于一个Colocate Group |

上面这 4 种方式灵活度是从高到低的，它对这个数据分布的要求是越来越严格，但 Join 计算的性能也是越来越好的。

## Runtime Filter Join 优化

当前 Doris 支持三种类型 RuntimeFilter

- 一种是 IN，很好理解，将一个 hashset 下推到数据扫描节点。
- 第二种就是 BloomFilter，就是利用哈希表的数据构造一个 BloomFilter，然后把这个 BloomFilter 下推到查询数据的扫描节点。
- 最后一种就是 MinMax，就是个 Range 范围，通过右表数据确定 Range 范围之后，下推给数据扫描节点。

Runtime Filter 适用的场景有两个要求：

- 第一个要求就是左表大右表小，因为构建 Runtime Filter是需要承担计算成本的，包括一些内存的开销。
- 第二个要求就是左右表 Join 出来的结果很少，说明这个 Join 可以过滤掉左表的绝大部分数据。

当 Join 列为左表的 Key 列时，RuntimeFilter 会下推到存储引擎。Doris 本身支持延迟物化。

### Runtime Filter 类型

Doris 提供了三种不同的 Runtime Filter 类型：

- **IN** 的优点是过滤效果明显，且快速。它的缺点首先第一个它只适用于 BroadCast，第二，它右表超过一定数据量的时候就失效了，当前 Doris 目前配置的是1024，即右表如果大于 1024，IN 的 Runtime Filter 就直接失效了。
- **MinMax** 的优点是开销比较小。它的缺点就是对数值列还有比较好的效果，但对于非数值列，基本上就没什么效果。
- **Bloom Filter** 的特点就是通用，适用于各种类型、效果也比较好。缺点就是它的配置比较复杂并且计算较高。

## Join Reorder

Doris 目前支持基于规则的 Join Reorder 算法。它的逻辑是：

- 让大表、跟小表尽量做 Join，它生成的中间结果是尽可能小的。
- 把有条件的 Join 表往前放，也就是说尽量让有条件的 Join 表进行过滤
- Hash Join 的优先级高于 Nest Loop Join，因为 Hash join 本身是比 Nest Loop Join 快很多的。

## Doris Join 调优方法

Doris Join 调优的方法：

- 利用 Doris 本身提供的 Profile，去定位查询的瓶颈。Profile 会记录 Doris 整个查询当中各种信息，这是进行性能调优的一手资料。
- 了解 Doris 的 Join 机制，这也是第二部分跟大家分享的内容。知其然知其所以然、了解它的机制，才能分析它为什么比较慢。
- 利用 Session 变量去改变 Join 的一些行为，从而实现 Join 的调优。
- 查看 Query Plan 去分析这个调优是否生效。

如果前面 4 种方式串联起来之后，还是不奏效。这时候可能就需要去做 Join 语句的改写，或者是数据分布的调整、需要重新去 Recheck 整个数据分布是否合理，包括查询 Join 语句，可能需要做一些手动的调整。

## Doris Join 调优建议

- 第一点：在做 Join 的时候，要尽量选择同类型或者简单类型的列，同类型的话就减少它的数据 Cast，简单类型本身 Join 计算就很快。
- 第二点：尽量选择 Key 列进行 Join， 原因前面在 Runtime Filter 的时候也介绍了，Key 列在延迟物化上能起到一个比较好的效果。
- 第三点：大表之间的 Join ，尽量让它 Colocation ，因为大表之间的网络开销是很大的，如果需要去做 Shuffle 的话，代价是很高的。
- 第四点：合理的使用 Runtime Filter，它在 Join 过滤率高的场景下效果是非常显著的。但是它并不是万灵药，而是有一定副作用的，所以需要根据具体的 SQL 的粒度做开关。
- 最后：要涉及到多表 Join 的时候，需要去判断 Join 的合理性。尽量保证左表为大表，右表为小表，然后 Hash Join 会优于 Nest Loop Join。必要的时可以通过 SQL Rewrite，利用 Hint 去调整 Join 的顺序。
