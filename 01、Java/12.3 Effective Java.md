<style>.typora-export-sidebar, .typora-export-sidebar .outline-content {width: 300px !important}</style>
## 简介

Effective Java，编写高效的Java代码，其中的"高效"包含两个方面：高维护性、高性能。

- 高维护性又包括3方面：
  - 易读：便于
  - 安全
  - 容易扩展
  - 不易出错
- 高性能指的是运行速度快、空间占用少。

高维护性和高性能这两个追求一般不会产生冲突，但如果产生冲突，作者认为，可维护性比性能更重要，详见第`67`条。



## 主要章节介绍

第1章为引言。

第2章阐述何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清除动作。

第3章阐述对于所有对象都通用的方法，你会从中获知对`equals()`、`hashCode()`、`toString()`、`clone()`、`finalize()`以及`Comparable.compareTo()`方法相当深入的分析，从而避免今后在这些问题上再次犯错。

第4章阐述作为Java程序设计语言的核心以及Java语言的基本抽象单元（类和接口）在使用上的一些指导原则，帮助你更好地利用这些元素，设计出更加有用、健壮和灵活的类与接口。

第5章和第6章分别阐述在Java 1.5发行版本中新增加的泛型（Generic）以及枚举（Enum）和注解（Annotation）的最佳实践，教你如何最大限度地享有这些优势，并使整个过程尽可能地简单化。

第7章专门讨论在Java 8中新增的函数接口（Functional Interface）、**Lambda**表达式和方法引用（Method Reference），使创建函数对象（Function Object）变得更加容易。接着探讨为处理数据元素的序列提供了类库级别支持的Stream API，以及如何最佳的利用这些机制。

第8章讨论方法设计的几个方面：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档，从而使方法设计在可用性、健壮性和灵活性上有进一步的提升。

第9章主要讨论Java语言的具体细节，讨论了局部变量的处理、控制结构、类库的使用、各种数据类型的用法，以及两种不是有语言本身提供的机制（Reflection和Native Method，反射机制和本地方法）的用法，并讨论了优化和命名惯例。

第10章阐述如何充分发挥`Exception`的优点来提升程序的可读性、可靠性和可维护性，以及减少`Exception`使用不当所带来的负面影响，并提供一些关于有效使用`Exception`的指导原则。

第11章阐述如何帮助你编写出清晰、正确、文档组织良好的并发程序，比如如何避免过度同步，优先采用Executor Framework、并发集合（Concurrent Collection）、同步器（Synchronizer），记忆是否需要依赖于线程调度器等。

第12章阐述序列化方面的技术，并且有一项值得特别提及的特性，就是序列化代理（Serializable Proxy）模式，它可以帮助你避免对象序列化的许多缺陷。

> 官方中文版的翻译水平与网友的评价一致——蹩脚，故本文主要参考[开源版本](https://github.com/sjsdfg/effective-java-3rd-chinese/tree/v1.4/docs/notes)。
>
> 但是该*开源版本*存在很多笔误，而且翻译水平仍没完全实现“信达雅”。



## 目录

### 一、引言

### 二、创建和销毁对象

1、静态工厂方法优于构造方法

2、当构造方法参数过多时使用`Builder`模式

3、使用私有构造方法或枚举类实现`Singleton`属性

4、使用私有构造器方法执行非实例化

5、依赖注入优于引用资源

6、避免创建不必要的对象

7、消除过期的对象引用

8、避免使用`Finalizer`和`Cleaner`

9、`try-with-resources`优于`try-finally`

### 三、对于所有对象都通用的方法

10、重写`equals()`时遵守通用约定

11、重写`equals()`时同时也要重写`hashCode()`

12、始终要重写`toString()`

13、谨慎地重写`clone()`

14、考虑实现`Comparable`接口

### 四、类和接口

15、使类和成员的可访问性最小化

16、在公共类而非公共属性中使用访问方法

17、使可变性最小化

18、组合优于继承

19、要么设计继承并提供文档说明，要么禁止用继承

20、接口优于抽象类

21、为后代设计接口

22、接口只用于定义类型

23、类层次结构优于标签类

24、静态成员类优于非静态成员类

25、将源文件限制为单个顶级类

### 五、泛型

26、不要使用原始类型

27、消除非受检的警告

28、列表优于数组

29、优先考虑泛型

30、优先考虑泛型方法

31、利用限定通配符来提升API的灵活性

32、谨慎地结合泛型和可变参数

33、优先考虑类型安全的异构容器

### 六、枚举和注解

34、用`Enum`代替`int`常量

35、用实例属性代替序数

36、用`EnumSet`代替位属性

37、用`EnumMap`代替序数索引

38、用接口模拟可扩展的`Enum`

39、注解优于命名模式

40、始终使用`Override`注解

41、用标记接口定义类型

### 七、Lambda和Stream

42、**Lambda**优于匿名类

43、方法引用优于**Lambda**

44、优先使用标准的函数接口

45、慎用**Stream**

46、优先使用**Stream**中无副作用的函数

47、使用`Collection`作为返回类型优于使用**Stream**

48、慎用**Stream**并行

### 八、方法

49、检查参数的有效性

50、必要时进行保护性地复制

51、谨慎设计方法签名

52、慎用重载

53、慎用可变参数

54、返回空数组或者空集合，而非`null`

55、谨慎地返回`Optional`

56、为所有已公开的API元素编写文档注释

### 九、通用编程

57、使局部变量的作用域最小化

58、`for-each`循环优于传统的`for`循环

59、了解并使用类库

60、如需精确答案，应避免使用`float`和`double`

61、基本类型优于包装类型

62、若其它类型更合适，则尽量避免使用字符串

63、了解字符串连接的性能

64、通过接口引用对象

65、接口优于反射

66、谨用本地方法

67、谨慎地进行优化

68、遵守普遍接受的命名惯例

### 十、异常

69、只针对`Exception`的情况才使用`Exception`

70、对可恢复的情况使用`Checked Exception`，对编程错误使用`Runtime Exception`

71、避免不必要地使用`Checked Exception`

72、优先使用标准的`Exception`

73、抛出与抽象对应的`Exception`

74、每个方法抛出的所有`Exception`都要建立文档

75、在细节消息中包含失败-捕获信息

76、努力使失败保持原子性

77、不要忽略`Exception`

### 十一、并发

78、同步访问共享的可变数据

79、避免过度同步

80、`executor`、`task`和`stream`优于线程

81、并发工具优于`wait()`和`notify()`

82、线程安全性的文档化

83、慎用延迟初始化

84、不要依赖线程调度器

### 十二、序列化

85、其它方法优于Java序列化

86、谨慎地实现`Serializable`接口

87、考虑使用自定义的序列化形式

88、保护性地编写`readObject()`

89、对于实例控制，枚举类型优于`readResolve()`

90、考虑用序列化代理代替序列化实例



## 摘要

### 一、引言

无

------

### 二、创建和销毁对象

#### 1、静态工厂方法优于构造方法

> <u>静态工厂方法</u>与设计模式中的<u>工厂方法模式</u>不同，即，本条目中描述的<u>静态工厂方法</u>在设计模式中没有直接的等价。

提供<u>静态工厂方法</u>而不是<u>构造方法</u>有优点也有缺点。

- 优点
  - <u>静态工厂方法</u>有名字，易读、不必纠结方法签名。
  - <u>静态工厂方法</u>不需要每次调用时都创建一个对象，允许创建<span style=background:#c2e2ff>不可变</span>类、缓存实例。
  - <u>静态工厂方法</u>可以反悔其返回类型的任何子类型的对象。
  - <u>静态工厂方法</u>返回对象的类可以根据<u>输入参数</u>的不同而不同。
  - <u>静态工厂方法</u>在编写包含该方法的类时，返回的对象的类不需要存在。
- 缺点
  - 如果类没有`public`或`protected`类型的<u>构造方法</u>，那么该类就无法被子类化。
  - 程序员难以发现<u>静态工厂方法</u>。

> <u>静态工厂方法</u>的常见命名有：`from`、`of`、`valueOf`、`instance`/`getInstance`、`create`/`newInstance`、`getType`、`newType`。

#### 2、当构造方法参数过多时使用建造者模式

`Builder`模式结合了<u>可伸缩构造方法</u>模式的安全性和`JavaBean`模式的可读性。

#### 3、使用私有构造方法或枚举类实现单例属性

<u>单一元素枚举类</u>通常是实现单例的最佳方式。

#### 4、使用私有构造器方法执行非实例化

试图通过创建<u>抽象类</u>来强制执行<u>非实例化</u>是行不通的。

可以通过包含一个<u>私有构造方法</u>来实现类的<u>非实例化</u>。

#### 5、依赖注入优于引用资源

<u>静态工具类</u>和<u>单例类</u>不适合用来实现以来一个或多个底层资源的类。

将资源或工厂传递给<u>构造方法</u>，以创建实例，即，依赖注入。

#### 6、避免创建不必要的对象

优先使用<u>基本类型</u>而不是<u>包装类型</u>，同时要注意无意识的<u>自动装箱</u>。

> 创建额外的对象以增强程序的清晰度、简单性或功能性通常是件好事。

#### 7、消除过期的对象引用

消除过期的对象引用，以避免内存泄漏。

当一个类自己管理内存时，程序员就需要警惕内存泄漏问题。

#### 8、避免使用`Finalizer`和`Cleaner`

能不用就不用，并且大概率用不到。

#### 9、`try-with-resources`优于`try-finally`

`try-with-resources`更加方便、简洁。

------

### 三、对于所有对象都通用的方法

#### 10、重写`equals()`时遵守通用约定

重写`equals()`时要遵守自反性、对称性、传递性、一致性、非空性。

推荐使用**Google**的开源框架AutoValue。

#### 11、重写`equals()`时同时也要重写`hashCode()`

求得属性对<u>散列值</u>`c`，然后循环执行`result = 31 * result + c;`来计算对象的<u>散列值</u>。

或者使用**Guava**的`com.google.common.hash.Hashing`。

如果一个类是<span style=background:#c2e2ff>不可变</span>的，并且计算<u>散列值</u>的代价很大，那么可以考虑在对象中缓存<u>散列值</u>，而不是在每次请求时重新计算<u>散列值</u>。

#### 12、始终要重写`toString()`

通过重写`toString()`来输出有效内容，可以让调试过程更加方便。

实现`toString()`时，必须在文档中指定返回值的*格式*，如果没有使用格式，也需要在文档中指明。

<u>静态工具类</u>无需重写`toString()`。

#### 13、谨慎地重写`clone()`

重写`clone()`时需要注意的事项很多，所以，新的接口不应该继承它，新的可扩展类不应该实现它，如有需要，可使用<u>复制构造方法</u>或<u>复制工厂</u>。

> 重写`clone()`时，方法的返回类型可以是重写方法的返回类型的子类。
>
> 如果对象的每个属性包含原始值或对<span style=background:#c2e2ff>不可变</span>对象的引用，则`super.clone()`返回的对象可能正是你所需要的，不需要进一步的处理。但如果对象某个属性包含对可变对象的引用，则在重写`clone()`时需要对该属性的内部进行复制。
>
> - <span style=background:#c2e2ff>不可变</span>类不应提供`clone()`，因为这只会浪费复制。
> - 当可变对象是数组时，此时不必将某一类型的数组转换为`Object[]`，因为在数组上调用`clone()`会返回一个数组，其运行时和编译时类型与被克隆的数组相同。
> - 如果引用可变对象的属性使用`final`进行修饰，那么就没法赋值了，只能移除`final`。
>
> 与<u>构造方法</u>一样，`clone()`绝对不可以在构建过程中调用一个可以重写的方法，否则子类有机会在克隆中修复它的状态之前执行该方法，进而导致克隆和原始对象的损坏。
>
> 在设计父类时，通常有两种选择，但无论选择哪一种，都不应该实现`Clonable`接口，但可以选择通过实现正确运行的`protected clone()`来模仿`Object.clone()`。
>
> 如果类有<u>线程安全</u>的要求，那么在重写`clone()`是不要忘了进行<u>同步</u>。

#### 14、考虑实现`Comparable`接口

`Comparable.compareTo()`与`Object.equals()`相似，但是前者支持泛型，用于比较大小。

Java类库中的绝大部分值类、枚举类都实现了`Comparable`接口。

实现`Comparable`也应遵守自反性、对称性、传递性。

重写`Comparable.compareTo()`时，请避免使用`<`和`>`，应使用包装类中的静态方法`compare()`或`Comparator`接口中的构建方法。

------

### 四、类和接口

#### 15、使类和成员的可访问性最小化

> **良好的封装**是软件设计的基本原则。
>
> - **良好的封装**有助于组件的分离/解耦，进而有助于组件的独立开发、测试、理解、使用、修改，而这能加速系统的开发、降低维护的成本。
> - **良好的封装**本身不会带来良好的性能，但是有助于分析/确定组件的性能，这样在优化某些组件时不会影响其它正确的组件。
> - **良好的封装**增加了代码的可重用度，同时也降低了构建大型系统的风险。

要做到**良好的封装**，要尽可能地让每个类或成员不可访问。

> 成员包括属性、方法、嵌套类和嵌套接口。

公共类的实例属性很少使用`public`进行修饰，并且带有<u>公共可变属性</u>的类通常不是<u>线程安全</u>的。

> 即使该属性使用了`final`进行修饰，并且引用了一个<span style=background:#c2e2ff>不可变</span>的对象，而一旦将其公开就意味着放弃了切换到新的内部数据表示的灵活性。
>
> 失去灵活性的问题适用于静态属性，但有一个例外：经`public static final`修饰的常量是类的抽象的一部分。
>
> 而例外的例外是，如果经`public static final`修饰的常量是**数组**，那么直接返回该数组的行为是错误的，因为非零长度的数组总是可变的，此时应返回该数组的一个快照/副本。

#### 16、在公共类而非公共属性中使用访问方法

如果一个类在其包之外是可访问的，则应该提供访问方法来保留更改类内部表示的灵活性。

> 但如果一个类是<u>包级私有</u>的，或者是一个<u>私有内部类</u>，则直接暴露它的数据属性也没有太大问题。

#### 17、使可变性最小化

与<u>可变类</u>相比，<span style=background:#c2e2ff>不可变</span>类更易于设计、实现、使用，更不容易出错，更安全。

> <span style=background:#c2e2ff>不可变</span>对象本质上是<u>线程安全</u>的，因为它们不需要<u>同步</u>。

<span style=background:#c2e2ff>不可变</span>类的设计需遵循：

1. 不提供修改对象状态的方法（mutators，设值方法）。
2. 确保该类不能被继承。
   1. 使用`final`修饰类来实现。
   2. 或者，可以使所有的<u>构造方法</u><u>私有</u>或<u>包级私有</u>，并添加<u>公共静态工厂</u>。
3. 所有字段都用`final`来修饰。
  1. 但是可以放宽该条原则以提升性能。
4. 所有字段都用`private`来修饰。
5. 确保对任何可变组件的互斥访问。

> <span style=background:#c2e2ff>不可变</span>类的主要缺点是对于每个不同的值都需要一个单独的对象，而创建这些对象的代价可能很高，进而影响性能。
>
> 对此，可为<span style=background:#c2e2ff>不可变</span>类创建一个<u>包级私有的可变伙伴类</u>，如`String`和`StringBuilder`。

#### 18、组合优于继承

<u>继承</u>虽然强大，但是破坏了<u>封装</u>，而<u>组合</u>不会。

只有在<u>子类</u>和<u>父类</u>存在真正的父子关系时才可以使用。

> 在包中使用<u>继承</u>是安全的，因为<u>子类</u>和<u>父类</u>都在同一个程序员的控制之中。
>
> <u>组合</u>涉及<u>包装类</u>和<u>被包装类</u>，也被称为<u>装饰器模式</u>。
>
> <u>组合</u>和<u>转发</u>的结合被不准确地称为<u>委托</u>（delegation），而严格意义上的<u>委托</u>需要<u>包装对象</u>把自身传递给<u>被包装对象</u>。

#### 19、要么设计继承并提供文档说明，要么禁止用继承

对于 *专门为继承而设计的类*，其每个`public`或者`protected`方法的文档中，必须指明该方法调用哪些可重写方法，以及这些方法以何种顺序调用的，以及每次调用的结果又是如何影响后续处理，并遵守这些描述。否则，<u>子类</u>就会依赖<u>父类</u>的实现细节，如果<u>父类</u>的实现发生了变化，<u>子类</u>就有可能遭到破坏。

> 好的API文档应该是描述该方法做了什么，而不是描述方法是如何做到的。
>
> *编写子类* 是测试 *专门为继承而设计的类* 的唯一方法。通常来说，三个子类足以测试一个可继承的类，而这些子类应该由父类作者以外的人编写。

<u>构造方法</u>绝不能直接或间接地调用可重写的方法。

#### 20、接口优于抽象类

Java只允许单一继承，没有接口来得灵活。

当接口方法有明显的方法实现时，可以提供<u>默认方法</u>。

> 但默认方法有部分限制：
>
> - `Object`类中方法，如`equals()`和`hashCode()`，不允许提供<u>默认方法</u>。
> - 接口不允许包含<u>实例属性</u>或<u>非公共静态成员</u>，<u>私有静态方法</u>除外。
> - 不能将<u>默认方法</u>添加到不受控制的接口中。

Abstract Skeletal Implementation Class，抽象的骨架实现类，将<u>接口</u>和<u>抽象类</u>的优点结合起来。

> 按照惯例，<u>抽象骨架实现类</u>被称为`AbstractInterface`，如：`AbstractCollection`，`AbstractSet`。

#### 21、为后代设计接口

Java8新增的<u>默认方法</u>是为了允许将方法添加到现有的接口。

> 使用<u>默认方法</u>可以将新的方法添加到现有接口中，但不能保证这些方法可以在所有已有的实现中使用，因为在Java8之前，这些实现是用默认的接口编写的，这些默认接口永远不会获得任何新的方法，如`org.apache.commons.collections4.collection.SynchronizedCollection`。所以应尽量避免使用<u>默认方法向</u>现有接口中添加新的方法。
>
> Java8向核心集合接口中添加了许多新的<u>默认方法</u>，以便使用Lambda。

#### 22、接口只用于定义类型

<u>常量接口</u>是包含常量的接口，也就是只包含经`static final`修饰的属性。

使用<u>常量接口</u>后，使用常量名时就无需再用类名限定了，但是这违反了”接口仅用于标识类型“的初衷，故不推荐使用。

> 对类的使用者来说，类实现一个<u>常量接口</u>是没有意义的，还会令他们感到困惑。
>
> 另外，如果一个非`final`类实现了<u>常量接口</u>，那么它的所有子类的命名空间都会被接口中的常量所污染。

#### 23、类层级结构优于标签类

<u>标签字段</u>是用于标识实例类型的字段，拥有<u>标签字段</u>的类叫做<u>标签类</u>。

<u>标签类</u>冗长的、易出错、效率低，不如用子类表示不同类型的方式。

使用子类的方式将原有的类分成了父类、子类两个层级，故叫做<u>类层级结构</u>。

> <u>标签类</u>实际上仅是对<u>类层级结构</u>的简单的模仿。

#### 24、静态成员类优于非静态成员类

<u>嵌套类</u>是在另一个类中定义的类。“另一个类”叫做<u>顶级类</u>。

<u>嵌套类</u>只应存在于其宿主类中，否则它应该是一个<u>顶级类</u>。

<u>嵌套类</u>有4种：<u>静态成员类</u>、<u>非静态成员类</u>、<u>匿名类</u>和<u>局部类</u>。后三种被称为<u>内部类</u>。

> <u>嵌套类</u>又叫做<u>成员类</u>。

4种<u>嵌套类</u>各有用途：

- 如果<u>嵌套类</u>的实例不需要访问/引用其<u>顶级类</u>实例，则将其声明为<u>静态成员类</u>，否则声明为<u>非静态成员类</u>。因为<u>非静态成员类</u>的每个实例都有一个对其宿主实例的隐藏的外部引用，而存储这个引用会有额外的时空开销，同时会有<span style=background:#c2e2ff>内存泄漏</span>的风险。
- 如果一个类属于一个方法内部，且只需要从一个地方创建其实例，且存在一个预置类型来说明这个类的特征，那么将其作为<u>匿名类</u>；否则，把它变成局部类。

> 另外：
>
> - 如果一个<u>包级私有顶级类</u>或<u>接口</u>只被某个类使用，那么可以考虑将该<u>包级私有顶级类</u>或<u>接口</u>作为该类的<u>私有静态嵌套类</u>。
> - <u>匿名类</u>虽然有很多限制，但在引入Lambda之前，它是函数式编程的首选。
> - <u>局部类</u>很少被使用。

#### 25、将源文件限制为单个顶级类

虽然Java允许在单个源文件中定义多个<u>顶级类</u>，但这样做没有任何好处，反而存在重大风险。可考虑使用<u>静态成员类</u>代替这种做法。

------

### 五、泛型

泛型主要用于指定容器中元素的类型。

使用泛型时，编译器在编译时会自动强制转换类型，并判断新增的元素的类型是否正确。

这样的程序既安全、一度，但不是没有代价的，故本章主要讨论如何最大限度地利用泛型带来的收益、减少泛型带来的并发症。

#### 26、不要使用原始类型

原始类型的存在主要是为了兼容泛型诞生之前的代码。使用原始类型会丧失泛型的<u>类型安全</u>和易于阅读的优点。

#### 27、消除非受检的警告

尽可能地消除每一个未经检查的警告，但如果引发警告的代码是<u>类型安全</u>的，那么可以用`@SuppressWarnings("unchecked")`注解来抑制警告，影响范围尽可能地小，并且添加注释说明<u>类型安全</u>的原因。

#### 28、列表优于数组

数组和泛型不能很好地混合使用，而创建一个泛型数组是非法的，因为它不是<u>类型安全</u>的。

> 两者之所以不能混用是因为：
>
> - 数组是协变的（covariant），如，`Sub`是`Super`的子类，则数组`Sub[]`是数组`Super[]`的子类；而泛型是<span style=background:#c2e2ff>不可变</span>的（invariant），如，`Sub`是`Super`的子类，但`List<Sub>`不是`List<Super>`的子类。
> - 数组被具体化了（reified），即，数组在运行时知道并强制执行它们的元素类型；而泛型不可被具体化，通过擦除（erasure）来实现，即，泛型只在编译时执行类型约束，并在运行时丢弃/擦除它们的元素类型信息。
>
> 不可具体化的类型指的是，其运行时表示包含的信息少于其编译时表示的类型。

#### 29、优先考虑泛型

泛型比“需要在客户端代码中强制转换的类型”更安全、易用。

#### 30、优先考虑泛型方法

泛型方法要比那些需要对<u>输入参数</u>、返回值进行显式的强制转换的方法更安全、易用。

#### 31、利用限定通配符来提升API的灵活性

<u>限定通配符类型</u>有`extends`和`super`两种，两者的使用可遵循PECS原则，即，producer-extends，consumer-super。

> 也可以使用“获取和放置原则”来辅助记忆，即，Get and Put Principle。
>
> 但如果一个<u>输入参数</u>即是生产者，又是消费者，那么此时不应该使用<u>限定通配符类型</u>，而应使用精确的类型匹配。
>
> 所有`Comparable`、`Comparator`都是消费者。

不要在<u>返回类型</u>上应用<u>限定通配符类型</u>。

如果类型参数在方法声明中只出现一次，请将其替换为通配符。

- 如果它是一个无限制的类型参数，请将其替换为无限制的通配符`?`。
- 如果它是一个限定类型参数，则用限定通配符替换它。

#### 32、谨慎地结合泛型和可变参数

泛型和<u>可变参数</u>不能很好的结合，尽量别用。

#### 33、优先考虑类型安全的异构容器

集合等泛型的通常用法限制了每个容器的固定数量的<u>类型参数</u>，可以通过将<u>类型参数</u>放在Key上而不是容器上来解除此限制，即，将`Class<T>`作为Key。

> 本质上，注解元素是一个<u>类型安全</u>的异构容器，其Key为注解类型。

------

### 六、枚举和注解

#### 34、用`Enum`代替`int`常量

`int`枚举模式不满足<u>类型安全</u>，也没有任何表达能力，也无法转换为可打印的字符串。

字符串枚举模式虽然能打印，但属于硬编码模式，不能很好地处理书写错误，还可能存在性能问题。

而枚举类型（`Enum`）不存在上述问题，并且还允许添加任意方法和属性，允许实现任意接口。

> `Enum`对`Object`的所有方法进行了高质量的实现，并实现了`Comparable`和`Serializable`。
>
> `Enum`有一个静态方法`values()`，它会以声明的顺序返回一个包含所有<u>常量集</u>的数组。

> 枚举类中的静态属性的初始化发生于枚举常量创建之后，所以`Enum`的构造方法无法访问这些静态属性，枚举常量也无法从构造方法中相互访问。

“特定于常量的方法实现”存在“枚举常量之间难以共享代码”的缺点，并且往往需要使用`switch`，虽然简洁，但是难以维护。

对此，可采用一种更安全、易维护、灵活的方式：在`Enum`中新增一个<u>私有嵌套枚举</u>，将这个<u>私有嵌套枚举</u>作为策略传入该`Enum`。这种方式也称为<u>策略枚举</u>。

> <u>策略枚举</u>的缺点是不够简洁。
>
> 枚举与`switch`的搭配也不是一无是处，可用于利用常量特定的行为增加枚举类型。

> `Enum`中的<u>常量集</u>不需要一直保持不变，会随着时间推移而演化。

#### 35、用实例属性代替序数

`Enum.ordinal()`可以得到常量的序号，但这一方法主要是为了配合`EnumSet`和`EnumMap`来使用，即，永远不要从`Enum`的序号中得出与它相关的值，而是使用实例属性。

#### 36、用`EnumSet`代替位属性

`EnumSet`比直接使用<u>位域</u>来得更简介、清晰、安全，两者的性能相仿。

> `EnumSet`的缺点是他是可变的。

#### 37、用`EnumMap`代替序数索引

`EnumMap`比“使用序数来索引数组”来得更简介、清晰、安全，两者的性能相仿。

#### 38、用接口模拟可扩展的`Enum`

Java不支持编写可扩展的`Enum`，但是可以接口来模拟，即，编写一个接口，然后编写实现了该接口的`Enum`。

> “用接口模拟可扩展的`Enum`”的缺点是：一个`Enum`无法继承另一个`Enum`；并且，实现类之间往往存在重复代码，当然，如果重复代码过多，可将这些代码封装到<u>辅助类</u>或<u>静态辅助方法</u>中。

#### 39、注解优于命名模式

命名模式存在诸多缺点：难以应对拼写错误；无法确保其仅用于适当的程序元素；没有提供较好的将参数值与程序元素相关联的方法。

而注解不存在上述问题。

> 与开发框架的程序员相比，开发应用的程序员一般不需要定义注解；但无论哪种程序员，都应该使用Java提供的预定义注解。

#### 40、始终使用`Override`注解

在Java类库提供的几个注解中，`@Override`是程序员最常使用那个。

在子类中对父类的方法进行了重写的方法上使用`@Override`能避免将重写搞成重载。

#### 41、用标记接口定义类型

<u>标记接口</u>是不含方法声明的接口，如`Serializable`。

与<u>标记注解</u>相比，<u>标记接口</u>有两个优点：

1. <u>标记接口</u>定义了一个由标记类实例实现的类型，但<u>标记注解</u>没有定义这样的类型，即，<u>标记接口</u>在编译时就能捕获错误，而<u>标记注解</u>直到运行时才能捕获错误。
2. <u>标记接口</u>可以更精确地定位目标。

------

### 七、Lambda和Stream

#### 42、Lambda优于匿名类

在引入**Lambda**之前，<u>匿名类</u>是创建函数对象的主要手段。<u>匿名类</u>的主要缺点是代码冗长。

而**Lambda**的引入，令Java中的函数式编程变得异常简洁、方便。

> 与类和方法相比，**Lambda**没有名称和文档，如果代码片段不是自解释的，或者超过`3`行，则不要将其放入**Lambda**中。
>
> **Lambda**基本取代了<u>匿名类</u>，但一些功能**Lambda**实现不了，而<u>匿名类</u>能实现：<u>匿名类</u>可以用来创建抽象类的实例，可以用来创建具有多个抽象方法的接口实例；<u>匿名类</u>能够获得对自身的引用，即，能用`this`来指代对自身的引用，而**Lambda**不能，它其中`this`指向的是封闭实例。

#### 43、方法引用优于Lambda

<u>方法引用</u>通常会比**Lambda**更简洁。

但在某些**Lambda**中，其参数名提供了有用的说明，比起<u>方法引用</u>更加易读、易维护。

如果**Lambda**超过`3`行，可将代码段提取到一个新方法中，并引用该方法。

| 方法引用类型      | 示例                   | Lambda                                                 |
| ----------------- | ---------------------- | ------------------------------------------------------ |
| Static            | Integer::parseInt      | str -> Integer.parseInt(str)                           |
| Bound             | Instant.now()::isAfter | Instant then = Instant.now();<br/>t -> then.isAfter(t) |
| Unbound           | String::toLowerCase    | str -> str.toLowerCase()                               |
| Class Constructor | TreeMap<K, V>::new     | () -> new TreeMap<K, V>                                |
| Array Constructor | int[]::new             | len -> new int[len]                                    |

#### 44、优先使用标准的函数接口

Java提供了很多<u>函数接口</u>，其中有`6`个<u>基本接口</u>。

- `Operator`：其方法的结果和参数类型相同。
- `Predicate`：其方法接受一个参数并返回一个布尔值。
- `Function`：其方法其参数和返回类型不同。
- `Supplier`：其方法不接受参数，但是返回值。
- `Consumer`：其方法接受一个参数而不返回任何东西。

| 接口                | 方法                | 示例                | 说明 |
| ------------------- | ------------------- | ------------------- | ---- |
| `UnaryOperator<T>`  | T apply(T t)        | String::toLowerCase |      |
| `BinaryOperator<T>` | T apply(T t1, T t2) | BigInteger::add     |      |
| `Predicate<T>`      | boolean test(T t)   | Collection::isEmpty |      |
| `Function<T,R>`     | R apply(T t)        | Arrays::asList      |      |
| `Supplier<T>`       | T get()             | Instant::now        |      |
| `Consumer<T>`       | void accept(T t)    | System.out::println |      |

其余的<u>函数接口</u>都基于上面`6`个<u>基本接口</u>，基本接口操作的是对象。

除非真的有需要，才可编写自己的<u>函数接口</u>，否则应使用标准的<u>函数接口</u>。

#### 45、慎用Stream

过度使用**Stream**，会使代码变得难以阅读，进而难以维护。

> 这里的**Stream**指的是广义的**Stream**，即，**Stream API**

尽量避免用**Stream**处理`char`。

**Stream**比较擅长：

- 统一转换<u>元素序列</u>。
- 过滤<u>元素序列</u>。
- 使用单个操作组合<u>元素序列</u>，如：添加、连接、求最小值。
- 将<u>元素序列</u>累积到一个集合中，并这些<u>元素序列</u>进行分组。

但**Stream**不是万能的。<u>迭代</u>使用<u>代码块</u>来表示<u>重复计算</u>，**Stream**使用**Lambda**、函数接口、方法引用等<u>函数对象</u>来表示<u>重复计算</u>，两者相比：

- <u>代码块</u>拥可以读取/修改范围内的任何<u>局部变量</u>；而**Lambda**做不到，只能读取最终或有效的最终变量。
- <u>代码块</u>可以`return`、`break`、`continue`，或者直接抛出`Exception`；而**Lambda**做不到。

对于返回**Stream**的方法，使用复数名词来命名可使代码更易于阅读。

#### 46、优先使用Stream中无副作用的函数

传递给**Stream**的任何函数对象都应该是没有副作用的，这样才能实现“函数的结果仅取决于其输入，而不依赖任何可变状态”，否则，使用**Stream**代码将会比使用<u>迭代</u>的代码更长、更难以阅读，进而难以维护。

比如，`forEach()`仅用于报告计算的结果（`System.out::println`）、将计算的结果添加到已经存在的集合中，而非执行计算。执行计算应使用`collect(Collector)`。

> `Collector`中有`39`个工厂方法，其中`3`为`toList()`、`toSet()`、`toCollection(CollectionFactory)`，剩下的`36`个大多是用于将**Stream**收集到`Map`中。
>
> 静态导入`Collector`的方法是一种惯例，因为这使代码更易阅读。
>
> `Collector.join()`仅用于处理`CharSequence`（如`String`）。

> 这一节较为全面的介绍**Stream**中的各个方法，介绍过程不可避免地琐碎、缺少概括，建议阅读[原文](https://github.com/sjsdfg/effective-java-3rd-chinese/blob/v1.4/docs/notes/46. 优先考虑流中无副作用的函数.md)。

#### 47、使用`Collection`作为返回类型优于使用Stream

在Java8之前，对于<u>返回值</u>为<u>元素序列</u>的方法来说：

- <u>返回值</u>尽量为`Collection`、`Set`、`List`。
- 如果<u>返回值</u>仅用于`for-each`，或者<u>返回值</u>无法实现`Collection`，那么就使用`Iterable`。
- 如果<u>返回值</u>使基本类型，或<u>返回值</u>有性能要求，则使用数组。

但Java8引入了**Stream**，使得<u>元素序列</u>的选择变得复杂。

对于**Stream**和`Iterable`得转换，可编写适配器方法来解决。

`Collection`继承自`Iterable`，并且有**Stream**方法，即，可以提供迭代或流式访问，所以`Collection`及其子类通常是最佳的返回类型。

#### 48、慎用Stream并行

对**Stream**来说：

- 如果源自`Stream.iterate()`，或使用中间操作`limit()`，那么使用`parallel()`不太可能提升性能，甚至降低性能。
- 如果源自`ArrayList`、`HashMap`、`HashSet`、`ConcurrentHashMap`、数组、`int`类型范围的**Stream**或`long`范围的**Stream**，那么使用`parallel()`很有可能提升性能。
  - 因为上述<u>元素序列</u>能够精确、廉价地被分割成任意大小，并且有良好的“引用位置”。

另外：

- `reduce()`（`min()`、`max()`、`count()`、`sum()`）、短路操作（`anyMatch()`、`allMatch()`、`noneMatch()`）适合`parallel()`。
- `collect()`则不太适合`parallel()`，因为组合<u>元素序列</u>的开销非常大。

> 但对`reduce()`使用`parallel()`时，传递给`reduce()`的<u>累加器</u>和<u>组合器</u>必须是关联的，否则会出现安全故障。

> **Stream**中的<u>元素数量</u>与<u>需对每个元素执行的代码</u>的乘积超过`100,000`时，才推荐使用`parallel()`，否则`parallel()`带来的收益很可能抵不上带来的成本。
>
> `parallel()`在公共的`fork-join`池中运行。

> 如果要对随机数流使用`parallel()`，推荐使用`SplittableRandom`，而非`ThreadLocalRandom`、`Random()`。

------

### 八、方法

本章主要介绍方法设计的注意事项：如何处理参数和返回值，如何设计方法签名，如何编写方法文档。

#### 49、检查参数有效性

大多数方法和构造方法需要传入参数，尽量在方法主体的开头就对其有效性进行检查，并在文档中标明，除非说检查的成本太高。

这样做是为了尽量在错误发生后尽快检测到错误，否则，则不太可能检测到错误，并且即便检测到错误也很难定位到其根源。

> 对参数有效性的限制不是越多越好，也不是越少越好，要结合实际、讲究适中。

对于<u>公共方法</u>和<u>受保护方法</u>抛出的`Exception`，最好使用`@throws`在方法文档中进行标注。

> 检查参数时会抛出的`Exception`多为`IllegalArgumentException`、`IndexOutOfBoundsException`、`NullPointerException`。

> Java7提供的`Objects.requireNonNull()`能够方便地进行空值检查。
>
> Java9又为数组和列表引入了范围检查的方法`Objects.checkFromIndexSize()/checkFromToIndex()/checkIndex()`。

#### 50、必要时进行保护性地复制

花些功夫来采取一些措施，使类在调用方恶意调用时仍保持健壮，是值得，而<u>保护性地复制</u>就是一项有效措施。

如果入参是<u>可变类</u>，那么可对其进行<u>保护性地复制</u>；如果入参是<u>可变类</u>，且有对应的`getter`，那么`getter`中最好也进行<u>保护性地复制</u>。

长度非零的数组总是可变的，如果需要将内部数组返回，那么应对其进行<u>保护性地复制</u>。

如果调用方是可信的，比如与类属于同一个包。

> 从Java8起，`Date`已经过时，应使用<span style=background:#c2e2ff>不可变</span>类`Instance`、`LocalDateTime`或`ZonedDateTime`来代替它。
>
> 在Java8前，可以将`Date.getTime()`返回的`long`进行保存，而非直接保存<u>可变类</u>`Date`。

> <u>保护性地复制</u>应在<u>检查参数有效性</u>之前进行。

#### 51、谨慎设计方法签名

仔细选择方法名称：名称应遵守标准命名约定；名称应易于理解；名称不应过长；可参考标准库中的方法名称。

不提供过多的方法：过多的方法会使得类难以学习、使用、测试、维护、文档化。

避免过长的参数列表：参数数量不应多于`4`个，可用以下措施来控制参数的数量：

- 将方法分解为多个方法。
- 使用辅助类来保存参数数组（这些辅助类通常为<u>静态成员类</u>）。
- 如果该方法为<u>构造方法</u>，可使用`Builder`模式。

参数类型优先使用<u>接口</u>而非<u>类</u>。

枚举类型的参数往往比布尔类型的参数，更易于阅读、编写。

#### 52、慎用重载

重载（Overloaded）方法之间的选择是静态的，而重写（Overridden/Overwritten）方法之间的选择是动态的。

> Overridden、Overwritten的区别与联系见[《1 面向对象》](./1 面向对象)

> Java会根据被调用方法的对象的<u>运行时类型</u>，在运行时选择正确版本的<u>重写方法</u>，也就是说，如果在子类的实例上调用重写方法，无论子类实例的<u>编译时类型</u>如何，都会执行子类的<u>重写方法</u>。

如果具有相同参数数量的<u>重载方法</u>，语义清晰、不被混淆，否则永远不要创建这样的<u>重载方法</u>。

不要创建在 <u>*相同*</u> 参数位置采用 <u>*不同*</u> 函数式接口的<u>重载方法</u>。

甚至永远不使用重载，而是对新方法取新的名称。

> `int`与`Integer`存在自动装箱/拆箱，这可能会导致`Integer`类型的泛型在被使用时，其行为不按期望中的进行。

#### 53、慎用可变参数

<u>可变参数</u>机制实际上会创建数组，如果在调用时没有传入参数，此时会创建一个空数组，进而在运行时报错，而在非编译时。

> 创建数组意味着会有数组的分配和初始化，如果在意这部分开销，可使用<u>重载</u>进行代替，即，直到方法参数数量超过`3`个，才使用<u>可变参数</u>。

但<u>可变参数</u>对`printf()`和<u>反射机制</u>有益。

#### 54、返回空数组或者空集合，而非`null`

返回<u>空容器</u>（空数组、空集合），而非`null`，能减轻调用方的负担、令调用方安心使用。

如果在意每次分配<u>空容器</u>时产生的开销，可返回同一个<u>空容器</u>，如：`Collections.emptyList/emptySet/emptyMap`或同一个空数组。

#### 55、谨慎地返回`Optional`

在Java8以前，想要表示无法返回任何值，无论是抛出`Exception`，还是返回`null`，都有缺点：

- 应该为异常条件保留`Exception`，并且抛出`Exception`的代价很高，因为创建`Exception`时需要捕获整个堆栈跟踪。
- 返回`null`会增加调用方的负担，因为调用方需增加额外代码来判空。

为此，Java8带来了`Optional<T>`，一个<span style=background:#c2e2ff>不可变</span>容器，最多可容纳一个元素。

但不是所有的类型都能从`Optional`中获益，如，容器类型（`Set`、`Map`、`Stream`、数组、`Optional`）。

> 另外，与其返回一个空的`Optional<List<T>>`，不如返回一个空的`List<T>`。

返回`Optional`是有成本的，是需要分配和初始化对象，如果在意这些开销，则不要使用`Optional`。

> 除了次要基本类型（minor primitive types），也就是`Boolean`、`Byte`、`Character`、`Short`、`Float`，永远不要<u>返回包含装箱基本类型的`Optional`</u>，因为，<u>返回包含装箱基本类型的`Optional`</u>的开销惊人，对此，以Java提供了专门的`OptionalInt`、`OptionalLong`、`OptionalDouble`。

#### 56、为所有已公开的API元素编写文档注释

使用缺少<u>文档注释</u>的API会更容易出错，所以必须在每个导出的类、接口、构造方法、方法和属性之前加上<u>文档注释</u>。

方法的<u>文档注释</u>应简洁地描述方法会做什么，而非它如何工作。

方法的<u>文档注释</u>还应描述方法的所有前置条件、所有后置条件、所有副作用。

------

### 九、通用编程

#### 57、使局部变量的作用域最小化

使<u>局部变量</u>的作用域最小化，能有效提高代码的可读性，进而提高代码的可维护性，降低出错的可能性。

具体包括以下准则：

- 在首次使用<u>局部变量</u>的地方声明它。
- 声明<u>局部变量</u>时，就对其进行初始化。
  - `try-catch`是例外。
- 如果循环终止后，不再需要循环中的<u>变量</u>，那么优先使用`for`循环，而非`while`循环。
- 保持方法小而集中。

下面这种`for`循环的写法，能进一步使<u>局部变量</u>的作用域最小化：

```java
for(int i=0, n=expensiveComputation(); i<n; i++){
    ...
}
```

#### 58、`for-each`循环优于传统的`for`循环

与`for-each`相比，`for`中有太多的局部变量，容易出错，如果只需要元素，不需要索引变量、迭代器，那么优先使用`for-each`。

以下`3`种场景不要使用`for-each`：

- 有损过滤：指的是遍历时，需要删除指定元素的场景。
- 转换：指的是遍历时，需对部分元素或全部元素进行转换的场景。
- 并行迭代：因为需要显式地控制索引变量、迭代器，才能进行<u>同步</u>。

> `for-each`中的`:`读作`in`。

#### 59、了解并使用类库

简单来说，就是不要重复发明轮子。

知晓标准类库的主要途径为：主动了解Java每个版本新增的特性。

标准类库很庞大，但至少应了解`java.lang`、`java.util`和`java.io`的基础知识及其子包。

> 特别是Collections框架、Streams库、`java.util.concurrent`。

如果标准类库不能满足需要，那么就是寻找第三方类库，直到别无选择时，才应自行实现。

#### 60、如需精确答案，应避免使用`float`和`double`

众所周知，`float`和`double`是用二进制来表示的十进制，不是精确的。

> 特别的，`float`和`double`无法精确表示`10`的任意负次幂，不适合货币计算。
>
> - 例如：`1.03 - 0.42 = 0.6100000000000001`、`1.00 - 9 * 0.10 = 0.0999999999999999998`。
> - 对此，可使用`BigDecimal`、`int`或`long`来进行计算。
>   - `BigDecimal`与`int`或`long`相比，能够控制舍入，但使用不方便、速度慢。
>   - 不要使用`BigDecimal(double)`，而应使用`BigDecimal(String)`。

#### 61、基本类型优于包装类型

<u>基本类型</u>优于<u>包装类型</u>，因为：

- 因为`==`比较的是对象的地址，而非值，所以对<u>包装类型</u>使用`==`，往往会得到意料之外的结果。
- 混用<u>基本类型</u>和<u>包装类型</u>时，<u>包装类型</u>会自动拆箱、自动装箱，开销大、速度慢。

但有些场景只能使用<u>包装类型</u>：

- 涉及泛型。
- 在进行反射方法调用时。

#### 62、若其它类型更合适，则尽量避免使用`String`

`String`很强大，但不要滥用，即，不要用它来代替数值类型，或代替枚举类型，或代替聚合类型，或代替能力表（capabilities），否则会带来降低灵活性、降低速度、更容易出错等麻烦。

#### 63、了解字符串连接的性能

因为`String`是<span style=background:#c2e2ff>不可变</span>的，所以使用`+`来对其进行拼接，时间复杂度为`O(n^2)`。所以如果要拼接的`String`很多，请使用`StringBuilder`，而非`+`。

#### 64、通过接口引用对象

优先采用<u>接口类型</u>来声明参数、返回值、变量和字段的代码，往往要比采用<u>实现类型</u>的代码更加灵活。

但如果没有合适的<u>接口类型</u>，那就使用类层次结构中能提供所需功能的最底层的类。

#### 65、接口优于反射

<u>反射</u>的合法用途很少，仅限于管理类对运行时可能不存在的其他类、方法或字段的依赖关系。

#### 66、谨用本地方法

**JNI**主要有`3`种用途：

1. 提供对特定平台的设施的访问，如，对注册中心的访问。
   1. 但这一用途很少有必要了，因为Java日趋成熟，提供了很多以前只能在宿主平台中找到的特性。
2. 提供对现有<u>本地代码库</u>的访问，如，提供对遗留数据的访问。
3. 通过<u>本地语言</u>编写应用程序中注重性能的部分。
   1. 但这一用途也很少有必要了，因为JVM已经变得足够快了，Java标准库经历多次重写也变得足够快了。

**JNI**有`4`个缺点：

1. 由于<u>本地语言</u>不安全，使用**JNI**的程序将不再能免受内存毁坏的影响。
2. 由于<u>本地语言</u>依赖于平台，使用**JNI**的程序的可移植性会降低，并会变得难以调试。
3. 由于垃圾收集器无法跟踪<u>本地内存</u>的使用情况，且进出<u>本地代码</u>会有开销，故使用**JNI**可能反而会降低性能。
4. **JNI**需要粘合代码，使代码难以阅读、编写起来很乏味。

#### 67、谨慎地进行优化

盲目地进行优化，很可能会适得其反：编写出既不快速也不正确又难以修复的代码。

对合理架构的追求，应优先对性能的追求。因为如果代码的性能不好，还能被优化；但如果代码的架构不合理，那就难以维护、改进，往往只能重写了。

#### 68、遵守普遍接受的命名惯例

遵守普遍接受的命名惯例可以使代码易于维护、使用。

------

### 十、异常

#### 69、只针对`Exception`的情况才使用`Exception`

只针对`Exception`的情况才使用`Exception`，不要将`Exception`用于流程控制，也不要编写迫使它们这样做的API。

#### 70、对可恢复的情况使用`Checked Exception`，对编程错误使用`Runtime Exception`

对可恢复的情况使用`Checked Exception`，对编程错误使用`Runtime Exception`。

#### 71、避免不必要地使用`Checked Exception`

过度使用`Checked Exception`，会令调用者感到难受；但如果`Checked Exception`使用得当，能提升代码的可读性。

在编写API时，如果需要抛出`Checked Exception`，但是却不想抛出，可以这样做：

1. 返回一个`Optional`。但`Optional`不像`Exception`那样能返回任何额外的信息，来详细说明它无法执行你想要的计算。
2. 或者将这个需要抛出`Exception`的方法一分为二：
   1. 第一个方法返回一个`boolean`，表明是否应该抛出`Exception`。
   2. 第二个方法执行核心逻辑。

#### 72、优先使用标准的`Exception`

Java提供的标准的`Exception`涵盖了绝大部分场景

| 异常                              | 使用场景                                     |
| --------------------------------- | -------------------------------------------- |
| `IllegalArgumentException`        | 非`null`的参数值不正确                       |
| `IllegalStateException`           | 不适合方法调用的对象状态                     |
| `NullPointerException`            | 在禁止使用`null`的情况下参数值为`null`       |
| `IndexOutOfBoundsExecption`       | 下标参数值越界                               |
| `ConcurrentModificationException` | 在禁止并发修改的情况下，检测到对象的并发修改 |
| `UnsupportedOperationException`   | 对象不支持用户请求的方法                     |

优先使用这些`Exception`，而非自行编写，因为：

1. 这样做符合代码重用原则。
2. 易于被他人接受、阅读、使用。
3. `Exception`是可序列化的。

#### 73、抛出与抽象对应的`Exception`

如果低层方法抛出的`Exception`对于高层方法也合适，那么可以继续传播该`Exception`，但如果高层方法不能处理或者阻止低层方法抛出的`Exception`，那么可以使用<u>异常转译</u>。

> 但无论是高层方法，还是低层方法，<u>异常链</u>都是有效的。因为<u>异常链</u>允许高层抛出适当的`Exception`，同时又能捕获底层抛出`Exception`的原因。

#### 74、每个方法抛出的所有`Exception`都要建立文档

每个方法抛出的所有`Exception`都要建立文档。

#### 75、在细节消息中包含失败-捕获信息

在细节消息中包含失败-捕获信息，有助于程序员或网站可靠性工程师（SRE）排查问题。

#### 76、努力使失败保持原子性

这里的<u>原子性</u>与数据库事务中的<u>原子性</u>概念相仿，指的是即便方法执行失败，也应使对象保持在执行之前的状态。

有`4`种实现原子性的方式：

1. 使用<span style=background:#c2e2ff>不可变</span>类。
1. 调整代码执行顺序，令参数有效性检查等操作置于对象的状态修改操作之前。
1. 新建临时副本，操作完成后再用副本替换原始内容。
1. 使用恢复代码，也就是回滚。

#### 77、不要忽略`Exception`

不要忽略`Exception`，最起码应打印到日志中。

------

### 十一、并发

#### 78、同步访问共享的可变数据

多个线程共享可变数据时，每个线程都必须执行<u>同步</u>。

<u>同步</u>不仅可以阻止一个线程看到对象处于不一致的状态，还可以保证进入<u>同步方法</u>或<u>同步代码块</u>的每个线程，都能看到由同一个锁保护的之前所有的修改效果。

> Liveness Failure，活性失败：程序没有得到提升。
>
> Safty Failure，安全性失败：会计算出错误的结果。
>
> Safe Publication，安全发布：将对象引用从一个线程传递到其他的线程。实现方式有静态字段、`volatile`字段、`final`字段、锁定访问的字段、将对象放入并发集合中。

#### 79、避免过度同步

过度<u>同步</u>往往会导致死锁、性能降低。

- 不要在<u>同步区域</u>内调用外来的方法，否则很容易产生死锁、数据损坏。
- 应在<u>同步区域</u>内做尽可能少的工作，否则并行容易退化成串行，进而降低性能。
  - 在多核时代，比起获取锁所产生的CPU成本，确保每个核都有一个一致的内存视图而产生的延迟要致命得多。
  - 在设计<u>可变类</u>时，只有当有足够的理由时，才可以由<u>可变类</u>在内部完成<u>同步</u>操作，并且要在文档中清晰地标明。

#### 80、`executor`、`task`和`stream`优于线程

比起直接使用`Thread`，使用`executor`、`task`和`stream`要简便得多。

> 直接使用`Thread`时，`Thread`既要负责<u>任务</u>的提交，又要负责<u>任务</u>的执行；而`executor`则将<u>任务</u>的提交和执行进行了解耦。

#### 81、并发工具优于`wait()`和`notify()`

比起直接使用`wait()`和`notify()`，Java提供了更方便的并发工具：

- Lock，锁。
- Blocking Queue，阻塞队列。
- Executor，执行器。
- Concurrent Collection，并发容器。
- Synchronizer，同步器。
  - 最常用的同步器时`CountDownLatch`和`Semaphore`。
  - 较不常用的是`CyclicBarrier`和`Exchanger`。
  - 功能最强大的同步器是`Phaser`。

但如果要直接使用`wait()`和`notify()`，那么：

- 应该始终在`while`循环内部使用`wait()`。
- 优先使用`notifyAll()`，而非`notify()`。

#### 82、线程安全性的文档化

每个类都应该措辞严谨地描述其<u>线程安全</u>，或者使用<u>线程安全</u>注解清楚的记录其<u>线程安全</u>。

>类的<u>线程安全</u>可分为`5`级：
>
>- <span style=background:#c2e2ff>不可变</span>类
>  - 该类的实例其实是常量，不需要外部<u>同步</u>。
>  - 如，`String`、`Long`和`BigInteger`。
>- 无条件的<u>线程安全</u>
>  - 该类的实例是可变的，但该类具有足够的内部<u>同步</u>，无需任何外部<u>同步</u>。
>  - 如，`AtomicLong`和`ConcurrentHashMap`。
>- 有条件的<u>线程安全</u>
>  - 与无条件的<u>线程安全</u>类似，只是部分方法需要外部<u>同步</u>。
>  - 如，`Collections.synchronized()`返回的集合，其迭代器需要外部<u>同步</u>。
>- 非<u>线程安全</u>
>  - 该类的实例是可变的，必须使用外部<u>同步</u>来包围其方法，才能实现<u>线程安全</u>。
>  - 如，`ArrayList`和`HashMap`。
>- 线程对立
>  - 即使使用外部<u>同步</u>来包围类的每一个方法，也无法实现对该类的<u>线程安全</u>。
>  - 线程对立通常是由于在不<u>同步</u>的情况下，修改静态数据而导致的。
>  - 没有人故意编写线程对立类，此类通常是由于没有考虑并发性而导致的。当发现类或方法与线程不相容时，通常将其修复或弃用。

> 私有锁对象只能用于无条件的<u>线程安全</u>，不能用于有条件的<u>线程安全</u>，因为有条件的<u>线程安全</u>必须在文档中标明，究竟哪些方法在何时需要获取哪些锁。

#### 83、慎用延迟初始化

要慎用<u>延迟初始化</u>，因为它既可以用于优化代码，也可以用于破坏类中的有害循环和实例初始化，甚至反而会降低性能。

> <u>延迟初始化</u>虽然降低了初始化类或实例化类的成本，但增加了访问经<u>延迟初始化</u>处理过的字段的成本。
>
> 如果一个字段很少有机会被使用，且初始化成本很高，那么使用<u>延迟初始化</u>可以优化性能，否则使用<u>延迟初始化</u>反而有可能降低性能。

在并发场景中使用<u>延迟初始化</u>时：

- 如果是在静态字段上使用，请使用[静态内部类](../10、Linux、Maven、Git、设计模式/4.1 创建型设计模式#静态内部类)法。
- 如果是在实例字段上使用，请使用[双重检查](../10、Linux、Maven、Git、设计模式/4.1 创建型设计模式#双重检查double-check-lockdcl)法。

#### 84、不要依赖线程调度器

依赖线程调度器来保证正确性或性能的程序，都可能是不健壮的、不可移植的，如，依赖线程调度器来实现公平调度、让出CPU使用权（`Thread.yield()`、线程优先级）。

> “线程调度器公平地调度每个线程”是理想，而现实往往是残酷的。
>
> 想要每个线程尽可能地被公平地调度：
>
> - 需要确保可运行的线程的平均数量，不显著大于处理器/核心的数量。
> - 需要任务尽量短小。

> 线程处于忙等待会大大消耗CPU，所以线程不应处于忙等待，而应反复检查共享对象的状态。

------

### 十二、序列化

#### 85、其它方法优于Java序列化

Java<u>序列化</u>虽然能简化分布式对象的实现过程，但存在正确性、性能、安全性和可维护性等问题，也就是说，其风险远大于收益。

而避免上述问题的方法，就是不使用Java<u>序列化</u>。

没有任何理由在新系统中使用Java<u>序列化</u>，而应使用JSON或Protocol Buffers。

如果不得不使用Java<u>序列化</u>，那么不要接收不可信的数据，请使用白名单限制来源，而非黑名单，同时使用对象<u>反序列化</u>过滤来降低风险。

#### 86、谨慎地实现`Serializable`接口

实现`Serializable`接口短期成本很低，但长期成本很高：

- 一旦实现`Serializable`接口的类被发布，更改该类实现的灵活性就会大幅降低。
- 实现`Serializable`接口，增加了出错和出现安全漏洞的可能性。
- 实现`Serializable`接口，增加了与发布类的新版本相关的测试负担。

正因此，实现`Serializable`接口一定要十分谨慎。

> 内部类不应该实现`Serializable`接口。

#### 87、考虑使用自定义的序列化形式

如果类的物理表示与其逻辑表示相同，则默认的<u>序列化</u>形式是合适的；否则，请使用自定义的序列化形式，因为此时默认的<u>序列化</u>形式存在明显的缺点：

- 会将导出的API永久地绑定到当前的内部实现。
- 会消耗过多的时间。
- 会占用过多的空间。
- 可能会导致堆栈溢出。

无论是否使用默认的<u>序列化</u>形式，都要对其使用同步，且要注意死锁问题。

无论是否使用默认的<u>序列化</u>形式，都要类中声明<u>序列版本</u>`UID`，以消除`UID`导致不兼容现象的发生。

不要更改<u>序列版本</u>`UID`，否则会破坏与现有序列化所有实例的兼容性。

#### 88、保护性地编写`readObject()`

某种意义上，`readObject()`是一个用<u>字节流</u>作为唯一参数的公有<u>构造方法</u>，而<u>构造方法</u>必须检查其参数的有效性，并且如有必要，还需要对其参数进行<u>保护性地复制</u>。

`readObject()`能利用<u>字节流</u>创建一个普通<u>构造方法</u>无法创建的对象。

#### 89、对于实例控制，枚举类型优于`readResolve()`

如果类定义了`readResolve()`，那么它将于`readObject()`后被调用，可用于忽略<u>反序列化</u>创建的对象，进而保证单例。

优先使用枚举类型，如果做不到，才可以使用`readResolve()`。

#### 90、考虑用序列化代理代替序列化实例

为<u>可序列化</u>的类设计一个私有的静态嵌套类，用以精确的表示外围类的逻辑状态，该类会有一个单独的<u>构造方法</u>，该<u>构造方法</u>的参数类型为外围类，并且这个<u>构造方法</u>只从它的参数中复制数据。

而这个私有的静态嵌套类又叫做序列化代理，是外围类最好的<u>序列化</u>形式。

