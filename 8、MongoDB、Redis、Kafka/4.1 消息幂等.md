## 消息幂等

**Kafka**不是严格的JMS， 没有对消息幂等作严格的要求，故消息不可靠，存在丢失、重复、错误、乱序等问题：

1. 在集群、**Producer**和**Consumer**中都有可能发生<span style=background:#f8d2ff>丢消息</span>。
2. **Producer**的超时重试，可能会导致**Broker**<span style=background:#ffb8b8>重复接收</span>**Message**。
3. **Consumer**也存在<span style=background:#ffb8b8>重复消费</span>的可能。



### 集群

不难看出**Kafka**单机，无法保证不<span style=background:#f8d2ff>丢消息</span>，只能通过措施来缓解；而集群是可以保证的（但是写入失败的情况还是会存在）。

**Kafka**（集群）是通过引入了ACK的概念来解决该问题：

1. 当集群保存**Message**后，会向**Producer**返回ACK；
2. 否则，**Producer**会<span style=background:#c2e2ff>重试</span>，直到重试次数超阈值。

ACK的返回模式，即ACKS，有4种：

1. <span style=background:#e6e6e6>ACKS = 0</span>：不返回ACK；
2. <span style=background:#e6e6e6>ACKS = 1</span>：当**Leader**收到**Message**后，不等待**Follower**响应，立即返回ACK；
3. <span style=background:#e6e6e6>ACKS = 2</span>：当**Leader**和任意一个（无需全部）**Follower**成功时，就返回ACK；<span style=background:#ffee7c>真的有ACKS = 2这个选项吗？</span>
4. <span style=background:#e6e6e6>ACKS = -1</span>：当**Leader**收到**Message**后，会等待所有的**Follower**返回ACK，之后才会向生产者返回ACK。

关于<span style=background:#e6e6e6>ACKS = -1</span>：

1. **Message**同步到**Replication**是发生在**Leader**<span style=background:#c2e2ff>刷盘</span>之后；**Follower**是在**Message**写入<span style=background:#c9ccff>Page Cache</span>后就会返回ACK。
2. 该模式需要维护**ISR**，其他模式不需要。

另外，一旦有<span style=background:#ffee7c>**Broker** / **Leader**</span>宕机、<span style=background:#ffee7c>**Controller**</span>切换，就会引起**Leader**和**Follower**的切换，会导致<span style=background:#f8d2ff>丢消息</span>。



### 生产者

**Producer**可以设置批量发送**Message**，即先将多条**Message**缓存，当缓存区满或者到时间周期后，进行批量发送。

这一做法减少了IO、提升了效率，但是有<span style=background:#f8d2ff>丢消息</span>的隐患：

1. 缓存位于内存中，易失；
2. 当**Producer**线程数不做限制，且**Message**生产速度过快时，来不及写入缓存发送时：
   1. 如果选择<span style=background:#f8d2ff>丢消息</span>策略，会造成大量**Message**丢失；
   2. 如果选择阻塞线程，等待发送完毕，会造成大量线程会挂起，内存占用不断增加，引起应用崩溃。

缓解措施：

1. 持久化缓存中的消息；
2. 优化程序设计，控制**Message**生产速度，可以采用带阻塞的线程池；
3. 增大缓冲区空间，同时减小发送周期（当然提升有限，因为瓶颈在网络IO上）。

另外，**Kafka**会为每个**Producer**生成一个ID，并为每条**Message**生成一个Sequence，当**Producer**对**Message**进行重试时，**Broker**[就会根据ID、Sequence进行判断](https://www.cnblogs.com/smartloli/p/11922639.html#3/8)，从而避免<span style=background:#c9ccff>重复接收</span>。



### 消费者

由于**Consumer**默认采用自动提交，即，收到**Message**后，立即响应，在之后的**Message**处理过程中可能存在<span style=background:#f8d2ff>丢消息</span>。

可改为手动提交，即，等**Message**处理完毕后，**Consumer**再响应，但这样一来又存在<span style=background:#ffb8b8>重复消费</span>的隐患。

<span style=background:#ffee7c>自动提交/手动提交与High-Level API/Simple API</span>

同时，**Consumer**的**Rebalance**也会引发<span style=background:#ffb8b8>重复消费</span>。

<span style=background:#ffb8b8>重复消费</span>的解决方法有：

1. 本地消息表：
   1. 直接利用数据库的唯一索引来约束。
   2. 或者，在<u>更新操作</u>之前设置<u>前置操作</u>，只能从未提交、未处理，变更为处理成功、处理失败。
2. Token机制：
   1. 给**Message**分配全局唯一的ID，同时需要引入分布式事务和分布式锁来保证**Message**处理的原子性，所以对性能有一定影响。

