### 实用方法

1. <span style=background:#b3b3b3>Thread.run()</span>，线程的运行逻辑。

   ```java
   public void run(){             // 从这部分代码中不难看出，执行指定代码有两种方式：
   	if(this.runnable != null){ // 1.传入一个Runnable对象。
       	this.runnable.run();   // 2.或者直接继承Thread，重写其run()。
       }                          // 推荐使用实现接口的方式，因为更加灵活，且比继承类开销小。
   }              
   ```

2. <span style=background:#b3b3b3>Thread.start()</span>，启动线程。

3. <span style=background:#b3b3b3>Thread.sleep(long)</span>，线程休眠。

   1. <span style=background:#b3b3b3>TimeUnit.SECONDS.sleep(long)</span>等方法与该方法一样用，但是这类方法有明确的时间单位的说明，语义更清晰。

4. <span style=background:#b3b3b3>Thread.join()</span>，待子线程运行结束后，再继续运行父线程。

5. <span style=background:#b3b3b3>Thread.interrupt()/isInterrupted()</span>，<span style=background:#c2e2ff>请求</span>中断/是否中断。

6. <span style=background:#b3b3b3>Thread.setPriority(int)</span>，设置线程的优先级。

   1. 优先级默认为5。
   2. 最大优先级为1。

7. <span style=background:#b3b3b3>Thread.setDaemon(boolean)</span>，设置为守护线程。JVM退出时，不会销毁守护线程。

8. <span style=background:#b3b3b3>Thread.currentThread()</span>，获取当前线程。



### 返回执行结果

<span style=background:#b3b3b3>Thread **implements** Runnable</span>使用起来非常方便，但是它没有返回值，只能通过将返回值保存到变量，并提供额外方法读取的方式来返回结果。

对此，Java提供**Callable**这一接口，可以返回指定类型的结果。

```java
class Task implements Callable<String> {
    public String call() throws Exception{
        return "";
    }
}
Callable<String> task = new Task();
Future<String> future = Executors.newFixedThreadPool(1).submit(task);
String result = future.get();     
```

**Future\<V\>** 有以下实用方法：

1. <span style=background:#b3b3b3>Future.get()</span>，获取结果，可能会阻塞。
2. <span style=background:#b3b3b3>Future.get(long, TimeUnit)</span>，在指定的等待时间内获取结果。
3. <span style=background:#b3b3b3>Future.cancel(boolean <span style=background:#808080>mayInterruptIfRunning</span>)</span>，取消当前任务。
4. <span style=background:#b3b3b3>Future.isDone()</span>，任务是否执行完毕。



### 超级Future

可以看到，无论是<span style=background:#b3b3b3>Future.get()</span>，还是轮询<span style=background:#b3b3b3>Future.isDone()</span>来获取执行结果，主线程都需要等待。

于是Java8引入了**CompletableFuture**，当任务完成或发生异常时，会自动调用回调方法。

**CompletableFuture**的另一个特点是，即支持<span style=background:#c2e2ff>串行</span>执行，也支持<span style=background:#c2e2ff>并行</span>执行，以及串行、并行的组合，具体有以下实用方法：

1. <span style=background:#b3b3b3>CompletableFuture.supplyAsync(Supplier, Executor)</span>，提交任务，异步执行，并返回结果。
   1. 如果不传入Executor参数，则会使用<span style=background:#b3b3b3>ForkJoinPool.commonPool()</span>作为线程池来执行任务。<span style=background:#ffee7c>（这种线程池的原理是？）</span>
   2. ForkJoinPool线程池采用分治法<span style=background:#e6e6e6;color:#b3b3b3>（以及工作窃算法）</span>，将大任务拆解成多个小任务<span style=background:#c2e2ff>并行</span>执行，其线程数量取决于CPU核数。
   
3. <span style=background:#b3b3b3>CompletableFuture.thenAccept(Consumer)</span>，当正常返回结果时异步处理并返回结果。

4. <span style=background:#b3b3b3>CompletableFuture.exceptionally(Function)</span>，异步处理异常。

5. <span style=background:#b3b3b3>CompletableFuture.thenApplyAsync(Function)</span>，异步串行化处理另一个任务。

6. <span style=background:#b3b3b3>CompletableFuture.anyOf()/allOf()</span>，并行化处理多个任务。

上述方法均可使用Lambda来简化代码，欲了解更多实用方法，请阅读[文章1](https://www.jianshu.com/p/6bac52527ca4)、[文章2](https://www.cnblogs.com/fingerboy/p/9948736.html)、文章3。

<span style=background:#b3b3b3>CompletableFuture\<T\> **implements** Future\<T\>, CompletionStage\<T\></span>

1. **CompletableFuture**可以作为**Future**使用，但[很少有人这么做](https://www.cnblogs.com/flydean/p/12680262.html)。
2. ES6中引入了Promise的概念，将<u>回调中的回调</u>转写为<u>链式调用</u>，大大提升了程序的可读性。而**CompletionStage**也采用了<u>链式调用</u>的思想，通过一系列的then\*\*\*方法来实现。



### FutureTask

无论是**Future**，还是**CompletableFuture**，都是以向线程池中提交的方式来运行的，而**FutureTask**不需要。

```java
class FutureTask implements RunnableFuture<V>{}
interface RunnableFuture<V> extends Runnable, Future<V>{}
```

可以看到，**FutureTask**实现了**Runnalbe**、**Future**接口，这使得**FutureTask**可以当作一个任务执行，而且有返回值。