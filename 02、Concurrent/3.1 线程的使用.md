## 实用方法

`Thread.run()`：线程的运行逻辑。

```java
public void run(){             // 从这部分代码中不难看出，执行指定代码有两种方式：
	if(this.runnable != null){ // 1.传入一个Runnable对象。
    	this.runnable.run();   // 2.或者直接继承Thread，重写其run()。
    }                          // 推荐使用实现接口的方式，因为更加灵活，且比继承类开销小。
}              
```

`Thread.start()`：启动线程。

`Thread.sleep(long)`：线程休眠。

- `TimeUnit.SECONDS.sleep(long)`等方法与`Thread.sleep(long)`一样用，但是前一类方法有明确的时间单位的说明，语义更清晰。

`Thread.join()`：待子线程运行结束后，再继续运行父线程。

`Thread.interrupt()/isInterrupted()`：<span style=background:#c2e2ff>请求</span>中断/是否中断。

`Thread.setPriority(int)`：设置线程的优先级。

- 优先级默认为5。
- 最大优先级为1。

`Thread.setDaemon(boolean)`：设置为守护线程。

- JVM退出时，不会销毁守护线程。
- **GC**[就是一个典型的](https://blog.hufeifei.cn/2017/06/Java/multithread/01-Thread-Basic/)守护线程。

`Thread.currentThread()`：获取当前线程。



## 返回执行结果

`Thread implements Runnable`使用起来非常方便，但是它没有返回值，只能通过将返回值保存到变量，并提供额外方法读取的方式来返回结果。

对此，Java提供`Callable`这一接口，可以返回指定类型的结果。

```java
class Task implements Callable<String> {
    public String call() throws Exception{
        return "";
    }
}
Callable<String> task = new Task();
Future<String> future = Executors.newFixedThreadPool(1).submit(task);
String result = future.get();     
```

`Future<V>` 有以下实用方法：

1. `Future.get()`：获取结果，可能会阻塞。
2. `Future.get(long, TimeUnit)`：在指定的等待时间内获取结果。
3. `Future.cancel(boolean mayInterruptIfRunning`：取消当前任务。
4. `Future.isDone()`：任务是否执行完毕。



## 回调

可以看到，无论是`Future.get()`，还是轮询`Future.isDone()`来获取执行结果，主线程都需要等待。

于是Java8引入了`CompletableFuture`，当任务完成或发生异常时，会自动调用回调方法。

`CompletableFuture`的另一个特点是，即支持<span style=background:#c2e2ff>串行</span>执行，也支持<span style=background:#c2e2ff>并行</span>执行，以及串行、并行的组合，具体有以下实用方法：

1. `CompletableFuture.supplyAsync(Supplier, Executor)`：提交任务，异步执行，并返回结果。

   > 如果不传入`Executor`参数，则会使用`ForkJoinPool.commonPool()`作为线程池来执行任务。

3. `CompletableFuture.thenAccept(Consumer)`：当正常返回结果时异步处理并返回结果。

4. `CompletableFuture.exceptionally(Function)`：异步处理异常。

5. `CompletableFuture.thenApplyAsync(Function)`：异步串行化处理另一个任务。

6. `CompletableFuture.anyOf()/allOf()`：并行化处理多个任务。

上述方法均可使用Lambda来简化代码，欲了解更多实用方法，请阅读[文章1](https://www.jianshu.com/p/6bac52527ca4)、[文章2](https://www.cnblogs.com/fingerboy/p/9948736.html)、文章3。

```java
CompletableFuture<T> implements Future<T>, CompletionStage<T>
```

1. `CompletableFuture`可以作为`Future`使用，但[很少有人这么做](https://www.cnblogs.com/flydean/p/12680262.html)。
2. ES6中引入了Promise的概念，将<u>回调中的回调</u>转写为<u>链式调用</u>，大大提升了程序的可读性。而`CompletionStage`也采用了<u>链式调用</u>的思想，通过一系列的`then***()`方法来实现。



## FutureTask

无论是`Future`，还是`CompletableFuture`，都是以向线程池中提交的方式来运行的，而`FutureTask`不需要。

```java
class FutureTask implements RunnableFuture<V>{}
interface RunnableFuture<V> extends Runnable, Future<V>{}
```

可以看到，`FutureTask`实现了`Runnalbe`、`Future`接口，这使得`FutureTask`可以当作一个任务执行，而且有返回值。



## 定时器[[1]](https://blog.hufeifei.cn/2017/06/Java/multithread/02-Thread-Utility/)

对于一些简单的定时任务，可直接使用`Timer`。

但也应注意，`Timer`采用单线程，相较于`ScheduledThreadPoolExecutor`，如果任务特别耗时，会导致后续任务延迟。