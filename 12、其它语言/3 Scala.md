## 简介

**Scala**是Scalable Language的简写，是[一门多范式的编程语言](https://www.runoob.com/scala/scala-tutorial.html)，其设计初衷是要集成<u>面向对象编程</u>和<u>函数式编程</u>的各种特性。

- **Scala**是一种面向对象的语言，每个值都是对象。
- **Scala**是一种函数式语言，其函数也能当成值来使用。

> Scalable，[ˈskeɪləbl]，可扩展的。 
>
> Language，[ˈlæŋɡwɪdʒ]。
>
> Margin，[ˈmɑːrdʒɪn] ，边距。

> [编程范式](https://www.zhihu.com/question/20428688)也叫做编程方法，是指设计程序时所采用的设计风格。
>
> 编程方法主要有`4`种：面向过程编程、面向对象编程、函数式编程、泛型式编程。
>
> 而[多范式编程语言](https://www.yisu.com/zixun/355807.html)，指的是采用了多种编程方法的语言。

> 因为**Spark**本身是用**Scala**编写的，所以在编写**Spark**应用时，一般都会使用**Scala**，而非其它语言。

**Scala**与Java的关系非常密切：

- **Scala**代码可以直接调用Java代码。
- **Scala**代码会被编译成Java字节码，然后运行于JVM之上。



## 运算符

**Scala**的运算符与Java的基本一致，[但也有一些不同](https://blog.csdn.net/xiaopihaierletian/article/details/118685153)：

- `=>`，匿名函数。
  - 在**Scala**中，函数也是一种对象，可以赋值给变量。
  - **Scala**采用`(形参列表) => {函数体}`的格式来定义/创建匿名函数。
- `<-`，集合遍历。
  - 循环遍历，类似于Java`for`循环中的`:`。
- `++=`，拼接字符串。
  - 等同于`+=`。
- `:::`，表示`List`的连接操作。
  - - 类似于Java中的`List.addAll(List)`。
- `::`，表示普通元素与`List`的连接操作。
  - 类似于Java中的`List.add(Element)`。
  - `element::List`，将元素`element`添加到`List`的头部。
  - `element::List`等价于`List.::(element)`。
- `++`，连接两个`Seq`。
  - `Seq`包括：列表、集合、字符串、Map、单个元素。
- `:+`，在`List`尾部追加元素。
- `+:`，在`List`头部追加元素。
  - 冒号相关的运算符与集合运算有关。
  - 元素出现在运算符的左侧、右侧均可。
- `->`，构造元组。
- `_N`，访问元组的第`N`个元素。
- `_`
  - 通配符。
    - `_`下划线，与Java中的`*`作用相同。
  - 指代集合中的每一个元素。
    - 常用于遍历集合。
  - 使用模式匹配可以用来获取元组的组员。
  - 成员变量而非局部变量添加默认值。
    - 对于`Int`，默认值为`0`，对`Double`来说，默认值是`0.0`；对引用类型来说，默认值是`null`。
    - 加不加空格都可以。
  - `：_*`，告诉编译器，希望将某个参数当做数序列整体来处理
  - `+=`，为集合添加元素。
  - `-=`，为集合移除元素。



## 数据类型

**Scala**与Java有着相同的数据类型。

| 数据类型  | 描述                                                         |
| :-------- | :----------------------------------------------------------- |
| `Byte`    | `8`位，有符号补码整数。数值区间为`-128`到`127`               |
| `Short`   | `16`位，有符号补码整数。数值区间为`-32768`到`32767`          |
| `Int`     | `32`位，有符号补码整数。数值区间为`-2147483648`到`2147483647` |
| `Long`    | `64`位，有符号补码整数。数值区间为`-9223372036854775808`到`9223372036854775807` |
| `Float`   | `32`位，IEEE 754标准的单精度浮点数                           |
| `Double`  | `64`位，IEEE 754标准的双精度浮点数<br>**Scala**中的小数默认为`Double`，想要指定为`Float`，需要在数字后面加后缀`f` |
| `Char`    | `16`位，无符号Unicode字符。区间值为`U+0000`到`U+FFFF`        |
| `String`  | 字符序列                                                     |
| `Boolean` | `true`或`false`                                              |
| `Unit`    | 表示无值，和其他语言中`void`等同。<br>用作不返回任何结果的方法的结果类型。<br>`Unit`只有一个实例值，写成`()`。 |
| `Null`    | `null`或空引用                                               |
| `Nothing` | `Nothing`类型在**Scala**的类层级的最底端，是任何其他类型的子类型。 |
| `Any`     | `Any`是所有其他类的超类                                      |
| `AnyRef`  | `AnyRef`类是**Scala**里所有引用类(reference class)的基类     |



## 变量

**Scala**中的变量（广义上的）可指向任意类型的值。

**Scala**会根据变量的初始值自动推断变量的类型，所以：

- 有初始值的变量可不标明类型。
- 但无初始值的变量需要标明类型。

**Scala**有两种变量（广义上的）：

- 可变变量，（狭义上的），关键字为`var`
- 不可变变量，或者说，常量，关键字为`val`。
  - 常量在确定引用后，不允许变更引用，相当于Java中经`static final`修饰的“变量”。

> 不像Java，**Scala**的`;`不是必须的，按行分隔即可。



## 访问修饰符

与Java相比，**Scala**的访问修饰符更加严格，`private`不允许嵌套类访问、`protected`不允许同一包中的其它类访问。

另外，**Scala**中的属性默认访问修饰符为`public`。



## 循环

**Scala**的`while`、`do while`与Java无异，但`for`循环的形式要丰富一些：

- `for( var x <- Range ){...}`，其中，`Range`可以是一个数字区间（`i to j`，或者`i until j`）。
- `for( a <- 1 to 3; b <- 1 to 3){...}`，其中，`a`、`b`是两个循环嵌套。
- `for( x <- List ){...}`，其中，`List`就是列表`List`。

`for`循环还能直接进行过滤：

- `for( var x <- List if condition1; if condition2...){...}`。

`for`循环还能保存为变量：

- `var retVal = for{ var x <- List if condition1; if condition2...}yield x`。



## 函数

在**Scala**中，函数是一个完整的对象，是一个继承了`Trait`类的对象。

### 括号`()`、点号`.`

**Scala**可以定义<u>有括号方法</u>和<u>无括号方法</u>。

- 若<u>有括号方法</u>只包含一个参数，则当其被调用时，可以省略括号，或者用大括号`{}`来代替。
- <u>无括号方法</u>一般是用来返回对象内部状态的一个运算，不修改对象状态，并且，调用<u>无括号方法</u>时，不能带上括号。

在**Scala**中，调用方法时，可用空格` `代替点好`.`。

> 可结合《[正则表达式](https://www.runoob.com/scala/scala-regular-expressions.html)》一节中的示例。

### 方法

定义在类中的函数叫做方法。

### 闭包

闭包是一个函数，其返回值依赖于声明在函数外部的一个或多个变量。

闭包可以简单地认为是，可以访问一个函数里面局部变量的另外一个函数。



## 集合

与`Array`相比，`List`是不可变的。

与`List`一样，元组`Tuple`是不可变的；与`List`不一样的是，`Tuple`可以包含不同类型的元素。

在**Scala**中，默认引用的是不可变集合`scala.collection.immutable.Set`；若想引用可变集合，导入`scala.collection.mutable.Set`即可。

在**Scala**中，默认引用的是不可变映射`scala.collection.immutable.Map`；若想使用可变映射，导入`scala.collection.mutable.Map`即可。



## 类和对象

### 继承

**Scala**的继承跟Java很相似，但不同点在于：

1. 只有主构造方法才可以往父类的构造方法里写参数。
2. 重写一个<u>非抽象方法</u>必须使用`override`修饰符。
3. 子类重写超类的抽象方法时，不需要使用`override`关键字。

### 单例对象

**Scala**没有`static`，但提供了单例模式的实现方法，关键字为`object`。

`object`与`class`的区别在于`object`不能带参数。

另外，当`object`与某个`class`共享同一个名称时，该`object`被称作该`class`的伴生对象（Companion Object)，该`class`被称为该`object`的伴生类（Companion class）

- 伴生对象必须定义在伴生类所在的文件中。
- 伴生对象和伴生类可以互相访问其私有成员。

### 特征

**Scala**中的特征`trait`结合了Java中的接口`Interface`和抽象类`Abstract Class`。

- **Scala**只允许继承一个`class`，但允许继承多个`trait`。
- `trait`可以定义属性和方法的实现。

`trait`也可以有构造方法，由属性的初始化和其他特征体中的语句构成。

### 构造方法的执行顺序

1. 调用父类的构造方法。
2. 特征构造方法在超类构造方法之后、类构造方法之前执行。
3. 特征由左到右被构造。
4. 每个特征当中，父特征先被构造。
5. 如果多个特征共有一个父特征，则父特征不会被重复构造。



## 模式匹配

**Scala**的模式匹配`match`类似于Java中的`switch`，但比`switch`更强大。

**Scala**的`case`支持复杂条件。

**Scala**支持匹配类（`class`）以及样例类（`case class`）。

> `case classes`是一种特殊的类，经过优化以用于模式匹配，相当于Java中的枚举。

