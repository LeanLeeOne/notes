## MyBatis架构图

![](../images/5/mybatis-framework.svg)

上图参考自[文章](https://blog.csdn.net/luanlouis/article/details/40422941)。



## 接口层

接口层定义了调用方式。

### 直接基于SqlSession

`SqlSession`接口定义的一系列CURD方法与数据库交互，每个方法都需要传递Statement ID和查询参数。

但是这种方式不符合面向对象的思想，所以便有了基于`Mapper`接口的调用方式。

### 基于Mapper接口

**MyBatis**将一组组的CURD方法抽象为一个个`Mapper`对象，调用指定`Mapper`实例的指定CURD方法就可获取相应的返回结果。

基于**Mapper**接口的调用方式其实是对**SqlSession**的封装：
1. **MyBatis**基于动态代理通过`SqlSession.getMapper(XXXMapper.class)`创建一个个的`Mapper`实例。
2. 调用`Mapper`实例的某一方法时，`MyBatis`会根据<u>方法名</u>和<u>参数类型</u>确定Statement ID。
3. 然后实例化一个`SqlSession`，并调用其相应的CURD方法。

<span style=background:#fdc200>注意</span>：每次通过`Mapper`访问数据库，都会创建一个`SqlSession`，但[同一事务中请求会共用一个](https://www.jianshu.com/p/5a72006e7779)`SqlSession`。



## 数据处理层

数据处理层负责构建SQL（包括参数解析）、执行SQL、封装查询结果。

其中，“封装查询结果”，支持结果集关系一对多和多对一的转换，转换方式支持两种，一种为嵌套查询语句，另一种为嵌套结果集。

一对多查询时，会使用基于**CGLib**的懒加载。



## 支撑层

### DataSource

**MyBatis**由三种`DataSource`：

1. Unpooled，不使用`ConnectionPool`的`DataSource`。
2. Pooled，使用`ConnectionPool`的`DataSource`。
3. JNDI，使用JNDI实现的`DataSource`。

**MyBatis**使用工厂模式创建`DataSource`。

创建`SqlSession`执行SQL时，**MyBatis**才会调用`DataSource`来实例化`java.sql.Connection`。

### Connection Pool

每次执行SQL都创建`Connection`是浪费的，而将`Connection`池化是一个很好的选择。

**MyBatis**的`ConnectionPool`中的`Connection`有两种空闲（Idle）和活动（Active）两种状态，且两种状态的`Connection`会分别放置在`IdleConnections`和`ActiveConnections`中。

当从`ConnectionPool`中获取`Connection`时：

1. 若`IdleConnections`不为空，则直接返回一个`Connection`；
2. 若`IdleConnections`为空，但`ActiveConnections`未满，则会返回一个新的`Connection`；
3. 若`IdleConnections`为空，且`ActiveConnections`满，会查看最先放入`ActiveConnections`中的连接是否过期，如果过期，则移除该`Connection`，并新建一个`Connection`；
4. 否则，返回第二步。

使用完的`Connection`会被调用`close()`，但是该方法经过了代理，不会释放资源，而是将`Connection`放入`IdleConnections`中。

> 上面提到的`Connection`实际上是**MyBaits**对`java.sql.Connection`的代理类，即，使用了<u>代理模式</u>。

<span style=background:#ffee7c>连接数问题</span>

### 事务

**MyBatis**提供了两种事务管理方式：

1. `JdbcTransaction`，使用`java.sql.Connection`来管理事务（GetConnection、Commit、Rollback、Close）。
   1. 开启“auto commit”后，会忽略Commit和Rollback。
2. `ManagedTransaction`，将事务管理托管给JBoss、WebLogic等容器。
   3. 在事务中调用`Mapper`的方法时，会增加引用次数，调用完成，就减少引用次数，不会真正关闭`SqlSession`；[但如果会话不存在事务](https://segmentfault.com/a/1190000015138959)，则直接关闭`SqlSession`。

> MyBatis使用了<u>工厂模式</u>来创建事务。

### 缓存

**MyBatis**提供两级缓存：

1. ##### 会话级别
   
   1. 该缓存位于`Executor`中，而`SqlSession`又持有`Executor`中，查询结果会存入该缓存。
   
      ![](../images/5/mybatis-sql-session-executor-cache-uml.png)
   
   2. `SqlSession`中的任何<span style=background:#c2e2ff>修改</span>操作都会<span style=background:#c2e2ff>清空</span>该缓存。
   
   3. 该缓存实际上是一个`HashMap`实例，由Statement ID、传入参数、rowBounds（limit、offset）组成Key，也没有额外的到期失效机制。
   
2. ##### 应用级别

   1. 该缓存的生命周期与应用相同。
   
   2. 开启该缓存后，**MyBatis**会在为`SqlSession`创建`Executor`时，对`Executor`对象加上一个装饰者`CachingExecutor`，之后的实际请求都会经过`CachingExecutor`，而`CachingExecutor`会将结果缓存。
   
      > `CachingExecutor`的设计体现了<u>装饰者模式</u>。
      
   3. 该缓存有两种使用方式：
   
      1. `<cache/>`，每个`Mapper`独享一个缓存。
      2. `<cache-ref/>`，多个`Mapper`共用一个缓存。
   
   4. 该缓存支持如**LRU**、**FIFO**等多种缓存刷新策略，还支持自定义策略，集成**Redis**。



## 引导层

实例化配置类，实例化`SqlSessionFactory`。

> 实例化`SqlSessionFactory`时使用了<u>Builder模式</u>。



## MyBatis核心类

### 核心类及其功能

| 核心类           | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| SqlSession       | 会话，与数据库交互的入口                                     |
| Executor         | 执行器，负责生成SQL和维护查询缓存                            |
| StatementHandler | 对JDBC Statement的封装，负责对设置JDBC Statement的参数、将JDBC Statement结果集转换成集合 |
| ParameterHandler | 将传入SqlSession的参数转换成JDBC Statement所需要的参数       |
| ResultSetHandler | 将JDBC返回的ResultSet转换成集合                              |
| TypeHandler      | Java数据类型和JDBC数据类型相互映射、转换                     |
| MappedStatement  | 对CURD的封装                                                 |
| SqlSource        | 根据传入的ParameterObject，动态生成SQL，封装为BoundSql对象并返回 |
| BoundSql         | 动态生成的SQL以及相应的参数信息                              |
| Configuration    | 配置类                                                       |

### 核心类之间的关系

![](../images/5/mybatis-class-relationship.svg)



## 使用

### `#{}`与`${}`

```sql
SELECT * FROM student WHERE name = #{name}
SELECT * FROM student WHERE name = '${name}'
```

[如上所示](https://segmentfault.com/a/1190000004617028)，**MyBatis**使用SQL Map时，提供了两种传递参数占位符。

**MyBatis**在对SQL预编译之前，会对SQL进行动态解析，生成`BoundSql`对象，此时`#{}`与`${}`会有不同表现：

- `#{}`
  - 会被解析为一个`PreparedStatement`的参数占位符`?`。
  - 预编译SQL可以重复利用，性能高；没有SQL注入问题。
- `${}`
  - 仅会进行单纯的字符串替换。
  - 表名、字段名作为变量时，只能使用这种方式。

更多关于`#{}`与`${}`的讨论，见[文章](https://blog.csdn.net/weixin_34452850/article/details/88991943)的评论区。

### 占位符模糊查询

1. `"%"#{question}"%"`：`#{…}`解析成SQL时，会在变量外侧自动加<u>单引号</u>，所以这里`%`需要使用<u>双引号</u>，不然，如果使用单引号会查不到任何结果。

2. `CONCAT(’%’,#{question},’%’) `：使用`CONCAT()`来拼装SQL。

3. 使用`<bind/>`标签：

   ```xml
   <select id="listUserLikeUsername" resultType="com.jourwon.pojo.User">
   　　<bind name="pattern" value="'%' + username + '%'" />
   　　SELECT id,sex,age,username,password FROM person WHERE username LIKE #{pattern}
   </select>
   ```

### @Param

`@Param(value)`用于修饰变量，[主要用于5种场景](https://juejin.cn/post/6844903894997270536)：

1. 方法有多个参数需要传递的。
2. 方法参数要取别名。
3. SQL 使用了`${}`。
4. 动态SQL中使用参数作为判断条件。
5. 方法参数为`Collection`/`Array`，且方法名不为`collection`/`array`的。

### IndexOutOfBoundsException

```
Exception in thread "main" org.apache.ibatis.exceptions.PersistenceException:
### Error querying database.  Cause: java.lang.IndexOutOfBoundsException: Index: 1, Size: 1
### The error may exist in StudentMapper.xml
### The error may involve one.StudentMapper.selectByIdDesc
### The error occurred while handling results
### SQL: select id,sex from student order by id desc
### Cause: java.lang.IndexOutOfBoundsException: Index: 1, Size: 1
```

假设`student`表有`id`、`name`、`sex`、`address`等字段，但是SQL中只查询了部分字段，如`id`、`sex`，<u>**MyBatis**在将结果映射成POJO时</u>，如果POJO使用了**Lombok**处理，此时就可能会抛出`IndexOutOfBoundsException`以及[上面的异常信息](https://blog.csdn.net/weixin_42332985/article/details/108498550)。

确切地说，是在POJO使用了**Lombok**的`@Builder`修饰后，会出现这种问题。

- 在不使用**Lombok**时，编译器在编译时会自动为类补充一个<span style=background:#f8d2ff>无参构造方法</span>，<u>**MyBatis**在将结果映射成POJO时</u>，会调用该<span style=background:#f8d2ff>无参构造方法</span>，并调用我们手写Getter/Setter完成属性的赋值。
- 而在使用**Lombok**的`@Builder`后，编译器会为POJO添加一个<span style=background:#c9ccff>全参构造方法</span>，不再提供<span style=background:#f8d2ff>无参构造方法</span>，<u>**MyBatis**在将结果映射成POJO时</u>，就有可能出现字段缺失的问题，进而抛出`IndexOutOfBoundsException`。

解决方法很简单：

1. 修改POJO：向POJO中同时增加`@NoArgsConstructor`和`@AllArgsConstructor`即可。
2. 或者修改SQL：将全部字段分别列出，或直接使用`*`即可。
