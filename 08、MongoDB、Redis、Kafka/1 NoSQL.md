## 关系型数据库与非关系型数据库的简单比较

在我看来“NoSQL”是“没有SQL”、“不用写SQL”、“<span style=background:#c9ccff>非关系型数据库</span>”的意思，同时也是“Not Only SQL（不止SQL）”、“完成<span style=background:#f8d2ff>关系型数据库</span>能力之外工作”的意思。

<span style=background:#c9ccff>非关系型数据库</span>的种类有很多：

1. <u>键值对</u>存储，如**Redis**。
2. 列存储，如**HBase**（实际也是<u>键值对</u>存储）。
3. 文档存储，如**Elasticsearch**、**MongoDB**。
4. 图数据库，如**Neo4J**。

<span style=background:#f8d2ff>关系型数据库</span>采用结构化数据，<span style=background:#c9ccff>非关系型数据库</span>支持非结构化数据，但偏爱结构化数据。

<span style=background:#f8d2ff>关系型数据库</span>仍是使用[最广泛的](https://db-engines.com/en/ranking)数据库，因为其对**关系**的表示（`JOIN`）和**事务**，是<span style=background:#c9ccff>非关系型数据库</span>无法替代的，更确切地说<span style=background:#c9ccff>非关系型数据库</span>是对关系型数据库一种补充，或者说是对读写能力的增强（因为没有`JOIN`、事务），甚至各类<span style=background:#c9ccff>非关系型数据库</span>之间也不是为了相互取代，而是相互补充。

<span style=background:#f8d2ff>关系型数据库</span>往往使用单机结构，而非集群结构，在并发读写、容灾、扩展等方面存在先天不足。对此，<span style=background:#f8d2ff>关系型数据库</span>使用主从结构、读写分离等措施来应对，但归途还是集群结构。当然集群，或者说分布式也不是没有缺点的，首先，更复杂的系统要求更高的维护成本，再者，集群 / 分布式需要考率网络传输（带宽、延迟、信息丢失）问题。

<span style=background:#f8d2ff>关系型数据库</span>追求强一致性，<span style=background:#c9ccff>非关系型数据库</span>大多基于分布式，追求强一致性。



## 非关系型数据库的表设计

### 表的预设计模式与动态模式

#### 预设计模式

<span style=background:#f8d2ff>关系型数据库</span>多采用预设计模式。

指在建表之初就指定表结构，允许表结构的修改，但是插入的数据必须符合当前表结构，即数据是结构化的。

#### 动态模式

<span style=background:#c9ccff>非关系型数据库</span>多支持动态模式。

指无需指定表结构，每次插入的数据的无需保持结构一致，即数据是半结构化、甚至非结构化的。

#### 小结

动态模式更加灵活，允许我们数量少、种类多的数据集中存储到一张表中；有利有弊，动态模式要求我们的逻辑代码需要对文档类型进行判断，增加编码量、系统复杂性，以及数据库底层数据维护开销的增加。

总之，动态模式不能滥用。

### 范式化与反范式化

#### Normalization

范式化，指将不同的对象拆分到不同的表中，利用关系模型将这些对象关联起来，某一类对象的变化不对其它对象产生影响。

范式化写入（增删改）性能好，因为写入量小，数据修改方便；但读取性能弱，因为需要读取多张表。

具体来说，范式化**只存储**关联对象的id。

关系型数据库采用范式化。

#### Denormalization

反范式化，不将对象进行拆分，采用内嵌的方式将不同的对象进行关联。

反范式化写入性能差，因为写入量大，数据修改不方便；但读取性能好，因为只需读取一张表（但也有包含的行多余的问题）。

具体来说，反范式化会将**整个**关联对象的信息都存储（内嵌）到本对象中。

非关系型数据库不支持范式化。

#### 小结

范式化、反范式化不存在优劣，我们往往需要根据业务场景采用折中做法，即将关联对象部分存储（内嵌）到到本对象中。

