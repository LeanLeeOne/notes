## 简介

Effective Java，编写高效的Java代码，其中的"高效"包含两个方面：高维护性、高性能。

- 高维护性又包括3方面：
  - 易读：便于
  - 安全
  - 容易扩展
  - 不易出错
- 高性能指的是运行速度快、空间占用少。

高维护性和高性能这两个追求一般不会产生冲突，但如果产生冲突，作者认为，可维护性比性能更重要，<span style=background:#ffee7c>因为</span>



## 主要章节介绍

第1章为引言。

第2章阐述何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清除动作。

第3章阐述对于所有对象都通用的方法，你会从中获知对equals、hashCode、toString、clone、finalize以及Comparable.compareTo方法相当深入的分析，从而避免今后在这些问题上再次犯错。

第4章阐述作为Java程序设计语言的核心以及Java语言的基本抽象单元（类和接口）在使用上的一些指导原则，帮助你更好地利用这些元素，设计出更加有用、健壮和灵活的类与接口。

第5章和第6章分别阐述在Java 1.5发行版本中新增加的泛型（Generic）以及枚举（Enum）和注解（Annotation）的最佳实践，教你如何最大限度地享有这些优势，并使整个过程尽可能地简单化。

第7章专门讨论在Java 8中新增的函数接口（Functional Interface）、Lambda表达式和方法引用（Method Reference），使创建函数对象（Function Object）变得更加容易。接着探讨为处理数据元素的序列提供了类库级别支持的Stream API，以及如何最佳的利用这些机制。

第8章讨论方法设计的几个方面：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档，从而使方法设计在可用性、健壮性和灵活性上有进一步的提升。

第9章主要讨论Java语言的具体细节，讨论了局部变量的处理、控制结构、类库的使用、各种数据类型的用法，以及两种不是有语言本身提供的机制（Reflection和Native Method，反射机制和本地方法）的用法，并讨论了优化和命名惯例。

第10章阐述如何充分发挥异常的优点来提高程序的可读性、可靠性和可维护性，以及减少异常使用不当所带来的负面影响，并提供一些关于有效使用异常的指导原则。

第11章阐述如何帮助你编写出清晰、正确、文档组织良好的并发程序，比如如何避免过度同步，优先采用Executor Framework、并发集合（Concurrent Collection）、同步器（Synchronizer），记忆是否需要依赖于线程调度器等。

第12章阐述序列化方面的技术，并且有一项值得特别提及的特性，就是序列化代理（Serializable Proxy）模式，它可以帮助你避免对象序列化的许多缺陷。

> 官方中文版的翻译水平与网友的评价一致——蹩脚，故本文主要参考[开源版本](https://github.com/sjsdfg/effective-java-3rd-chinese/tree/v1.4/docs/notes)。
>
> 但是该*开源版本*存在很多笔误。



## 目录

### 一、引言

### 二、创建和销毁对象

1、静态工厂方法优于构造方法

2、当构造方法参数过多时使用`Builder`模式

3、使用私有构造方法或枚举类实现`Singleton`属性

4、使用私有构造器方法执行非实例化

5、依赖注入优于引用资源

6、避免创建不必要的对象

7、消除过期的对象引用

8、避免使用`Finalizer`和`Cleaner`

9、try-with-resources优于try-finally

### 三、对于所有对象都通用的方法

10、重写`equals`时遵守通用约定

11、重写`equals`时同时也要重写`hashCode`

12、始终要重写`toString`

13、谨慎地重写`clone`

14、考虑实现`Comparable`接口

### 四、类和接口

15、使类和成员的可访问性最小化

16、在公共类而非公共属性中使用访问方法 

17、使可变性最小化

18、组合优于继承

19、要么设计继承并提供文档说明，要么禁止用继承

20、接口优于抽象类

21、为后代设计接口

22、接口只用于定义类型

23、类层次结构优于标签类

24、静态成员类优于非静态成员类

25、将源文件限制为单个顶级类

### 五、泛型

26、不要使用原始类型

27、消除非受检的警告

28、列表优于数组

29、优先考虑泛型

30、优先考虑泛型方法

31、利用限定通配符来提升API的灵活性

32、谨慎地结合泛型和可变参数

33、优先考虑类型安全的异构容器

### 六、枚举和注解

34、用`Enum`代替`int`常量

35、用实例属性代替序数

36、用`EnumSet`代替位属性

37、用`EnumMap`代替序数索引

38、用接口模拟可扩展的`Enum`

39、注解优于命名模式

40、始终使用`Override`注解

41、用标记接口定义类型

### 七、Lambda和Stream

42、`Lambda`优于匿名类

43、方法引用优于`Lambda`

44、优先使用标准的函数接口

45、慎用`Stream`

46、优先选择`Stream`中无副作用的函数

47、使用`Collection`作为返回类型优于使用`Stream`

48、慎用`Stream`并行

### 八、方法

49、检查参数的有效性

50、必要时进行保护性拷贝

51、谨慎设计方法签名

52、慎用重载

53、慎用可变参数

54、返回空数组或者空集合，而非`null`

55、谨慎地返回`Optional`

56、为所有已公开的API元素编写文档注释

### 九、通用编程

57、使局部变量的作用域最小化

58、`for-each`循环优于传统的`for`循环

59、了解并使用类库

60、如需精确答案，应避免使用`float`和`double`

61、基本类型优于包装类型

62、若其他类型更合适，则尽量避免使用字符串

63、了解字符串连接的性能

64、通过接口引用对象

65、接口优于反射

66、谨用本地方法

67、谨慎地进行优化

68、遵守普遍接受的命名惯例

### 十、异常

69、只针对异常的情况才使用异常

70、对可恢复的情况使用受检异常，对编程错误使用运行时异常

71、避免不必要地使用受检异常

72、优先使用标准的异常

73、抛出与抽象对应的异常

74、每个方法抛出的所有异常都要建立文档

75、在细节消息中包含失败-捕获信息

76、努力使失败保持原子性

77、不要忽略异常

### 十一、并发

78、同步访问共享的可变数据

79、避免过度同步

80、`executor`、`task`和`stream`优于线程

81、并发工具优于`wait`和`notify`

82、线程安全性的文档化

83、慎用延迟初始化

84、不要依赖线程调度器

### 十二、序列化

85、其他方法优于Java序列化

86、谨慎地实现`Serializable`接口

87、考虑使用自定义的序列化形式

88、保护性地编写`readObject`方法

89、对于实例控制，枚举类型优于`readResolve`

90、考虑用序列化代理代替序列化实例



## 摘要

### 一、引言

无

<u></u>

### 二、创建和销毁对象

1、静态工厂方法优于构造方法

> <u>静态工厂方法</u>与设计模式中的<u>工厂方法模式</u>不同，即，本条目中描述的<u>静态工厂方法</u>在设计模式中没有直接的等价。

提供<u>静态工厂方法</u>而不是<u>构造方法</u>有优点也有缺点。

- 优点
  - <u>静态工厂方法</u>有名字，易读、不必纠结方法签名。
  - <u>静态工厂方法</u>不需要每次调用时都创建一个对象，允许创建不可变类、缓存实例。
  - <u>静态工厂方法</u>可以反悔其返回类型的任何子类型的对象。
  - <u>静态工厂方法</u>返回对象的类可以根据输入参数的不同而不同。
  - <u>静态工厂方法</u>在编写包含该方法的类时，返回的对象的类不需要存在。
- 缺点
  - 如果类没有`public`或`protected`类型的<u>构造方法</u>，那么该类就无法被子类化。
  - 程序员难以发现<u>静态工厂方法</u>。

2、当构造方法参数过多时使用建造者模式

`Builder`模式结合了<u>可伸缩构造方法</u>模式的安全性和`JavaBean`模式的可读性。 

3、使用私有构造方法或枚举类实现单例属性

<u>单一元素枚举类</u>通常是实现单例的最佳方式。

4、使用私有构造器方法执行非实例化

试图通过创建<u>抽象类</u>来强制执行<u>非实例化</u>是行不通的。

可以通过包含一个<u>私有构造方法</u>来实现类的<u>非实例化</u>。

5、依赖注入优于引用资源

<u>静态工具类</u>和<u>单例类</u>不适合用来实现以来一个或多个底层资源的类。

将资源或工厂传递给<u>构造方法</u>，以创建实例，即，依赖注入。

6、避免创建不必要的对象

优先使用<u>基本类型</u>而不是<u>包装类型</u>，同时要注意无意识的<u>自动装箱</u>。

> 创建额外的对象以增强程序的清晰度、简单性或功能性通常是件好事。

7、消除过期的对象引用

消除过期的对象引用，以避免内存泄漏。

当一个类自己管理内存时，程序员就需要警惕内存泄漏问题。

8、避免使用`Finalizer`和`Cleaner`

能不用就不用，并且大概率用不到。

9、`try-with-resources`优于`try-finally`

`try-with-resources`更加方便、简洁。

### 三、对于所有对象都通用的方法

10、重写`equals`时遵守通用约定

重写`equals`时要遵守自反性、对称性、传递性、一致性、非空性。

推荐使用**Google**的开源框架AutoValue。

11、重写`equals`时同时也要重写`hashCode`

求得属性对<u>散列值</u>`c`，然后循环执行`result = 31 * result + c;`来计算对象的<u>散列值</u>。

或者使用**Guava**的`com.google.common.hash.Hashing`。

如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存<u>散列值</u>，而不是 在每次请求时重新计算哈希码。

12、始终要重写`toString`

通过重写`toString()`来输出有效内容，可以让调试过程更加方便。

实现`toString()`时，必须在文档中指定返回值的*格式*，如果没有使用格式，也需要在文档中指明。

<u>静态工具类</u>无需重写`toString()`。

13、谨慎地重写`clone`

重写`clone()`时需要注意的事项很多，所以，新的接口不应该继承它，新的可扩展类不应该实现它，如有需要，可使用<u>复制构造方法</u>或<u>复制工厂</u>。

> 重写`clone()`时，方法的返回类型可以是重写方法的返回类型的子类。
>
> 如果对象的每个属性包含原始值或对不可变对象的引用，则`super.clone()`返回的对象可能正是你所需要的，不需要进一步的处理。但如果对象某个属性包含对可变对象的引用，则在重写`clone()`时需要对该属性的内部进行复制。
>
> - <u>不可变类</u>不应提供`clone()`，因为这只会浪费复制。
> - 当可变对象是数组时，此时不必将某一类型的数组转换为`Object[]`，因为在数组上调用`clone()`会返回一个数组，其运行时和编译时类型与被克隆的数组相同。
> - 如果引用可变对象的属性使用`final`修饰，那么就没法赋值了，只能移除`final`。
>
> 与<u>构造方法</u>一样，`clone()`绝对不可以在构建过程中调用一个可以重写的方法，否则子类有机会在克隆中修复它的状态之前执行该方法，进而导致克隆和原始对象的损坏。
>
> 在设计父类时，通常有两种选择，但无论选择哪一种，都不应该实现`Clonable`接口，但可以选择通过实现正确运行的`protected clone()`来模仿`Object.clone()`。
>
> 如果类有线程安全的要求，那么在重写`clone()`是不要忘了进行同步。

14、考虑实现`Comparable`接口

`Comparable.compareTo()`与`Object.equals()`相似，但是前者支持泛型，用于比较大小。

Java类库中的绝大部分值类、枚举类都实现了`Comparable`接口。

实现`Comparable`也应遵守自反性、对称性、传递性。

重写`Comparable.compareTo()`时，请避免使用`<`和`>`，应使用包装类中的静态方法`compare()`或`Comparator`接口中的构建方法。

### 四、类和接口

### 五、泛型

### 六、枚举和注解

### 七、Lambda和Stream

### 八、方法

### 九、通用编程

### 十、异常

### 十一、并发

### 十二、序列化

