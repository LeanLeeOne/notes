### 应用场景

[线程池](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)有2类主要应用场景：

1. **多请求聚合**

   1. 即IO密集型。
   2. 用户的一次请求往往包含多个请求，串行处理虽然简单，但是响应时间长；采用线程池进行并行处理，能有效缩短响应时间。
   3. 这种场景中，每个子请求的处理时间较短，且并发量要求高，所以我们往往不设置缓冲队列，同时调高**corePoolSize**、**maximumPoolSize**，以最大的速度来处理请求。

2. **批量计算**

   1. 即CPU密集型。
   2. 批量计算往往数据量大、耗时长，往往采用离线计算的方式。采用线程池进行并行处理能充分利用CPU资源，提升处理速度。
   3. 这种场景中，即便采用了线程池，批量计算也难以瞬时完成，所以需要我们设置缓冲队列，同时过多的线程数反而引起上下文的频繁切换、降低处理速度及吞吐量，所以需要我们限制**corePoolSize**。



### 参数设置

线程池的参数设置没有通用法则，设置不当会引发多种问题：

1. 如果**corePoolSize**、**maximumPoolSize**设置过小，会导致服务方大量抛出RejectedExecutionException，进而触发服务降级。
2. 如果缓冲队列过长，同时任务处理能力过小，当请求量激增时，会导致任务积压在缓冲队列中，进而引发服务调用超时。

既然线程池的参数难以设置，我们是否直接弃用线程池，采用Disruptor、Actor、协程等框架能实现并发呢？答案是否，因为这些框架虽然各有特点，但是在Java中缺乏成熟的应用，我们最终还是考虑线程池参数该如何设置。

采用动态设置参数能提升线程池的适应性，大概流程为：将线程池参数迁移到分布式配置中心上，线程池参数可以动态修改且实时生效。

线程池参数动态化设置的设计如下：

1. **参数选择**

   1. 线程池参数有8个，但核心配置仅为3个：**corePoolSize**、**maximumPoolSize**、**workQueue**。
   2. 该设计中仅提供两种**workQueue**：

      1. **SynchronousQueue**，同步队列，不缓冲任务，适合IO密集型。
      2. **ArrayBlockingQueue**，有界队列，缓冲CPU密集型任务；队列容量需要指明，防止任务无限制堆积。

2. **动态修改参数**

   1. 在原有Java线程池的基础上进行封装，允许线程池监听同步外部消息，并根据消息修改参数。

3. **增加监控**

   1. 对线程池执行任务的生命周期添加监控，进而实现状态分析、变更通知、负载告警等功能。
   2. 监控粒度包括：应用粒度、线程池粒度、任务粒度等

4. **操作日志、权限校验**

   1. 线程池参数的每次修改都会记录日志。
   2. 应用负责人才能对应用的线程池参数进行修改。