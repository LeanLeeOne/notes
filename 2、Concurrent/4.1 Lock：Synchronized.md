[Java锁杂谈](https://www.zhihu.com/question/317687988/answer/1715863550)

[How to do distributed locking?](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)

<span style="background:yellow">[Java的3种并发控制工具：CountDownLatch、CyclicBarrier和Semaphore](http://blog.sina.com.cn/s/blog_7d1968e20102xewm.html)</span>

<span style="background:yellow">两个线程如何交替执行？</span>



**《synchronized》**

Java使用**synchronized**关键字来标识**临界区**，使用时需指定一个对象作为锁：

1. 同步代码块

2. 1. **synchronized**修饰代码块时，需要指定一个对象作为锁。

3. 同步方法

4. 1. **synchronized**修饰方法时，无需指定对象，因为此时会自动将**this**，即将对象本身作为锁。
   2. 如果**synchronized**修饰的是**静态方法**，则会自动将类对应的Class实例作为锁，这会导致同一个类的多个对象、多个方法并发执行时都会阻塞等待。

​                void method(){synchronized(object){……}} // 同步代码块 synchronized void method(){……}          // 同步方法              

显然，**synchronized**判断是否为同一把锁的依据为作为锁的对象是否为同一个。

中文多使用“判断”一词，英文多使用“check”一词，直译过来就是“检查”。在计算机中的绝大部分语境中，“判断”、“检查”没有区别，按照个人习惯使用就好。

**《Monitor》**

[Monitor](https://segmentfault.com/a/1190000016417017)，直译为监视器，也称作管程。

直接使用**Semaphore**、**Mutex**等原语即复杂，又容易出错（死锁），所以Java等编程语言在**Semaphore**、**Mutex**等原语的基础上提出了**Monitor**。

**Monitor**类包含以下几个重要属性：

1. 同步队列

2. 1. 保存被阻塞的线程。

3. 一个MutexLock

4. 1. 对互斥量（Mutex）的封装。

5. 条件变量及相关操作wait()、signal()。

6. 1. 调用wait()可阻塞当前线程，并让出**Monitor**。
   2. 调用signal()可唤醒被阻塞的线程。

Java对象的内存模型包括3部分：1.对象头、2.实例数据、3.对齐填充。

其中，对象头也称作Mark Word，用来保存锁标识（bit fields，类型标识；tag bits，状态标识），不同格式的Mark Work对应不同的锁状态：

| **type**                     | **state**    |                     |                |          |          |          |
| ---------------------------- | ------------ | ------------------- | -------------- | -------- | -------- | -------- |
| **bitfields**                | **tag bits** | **en**              | **zh**         |          |          |          |
| hash code                    | age          | 0                   | 01             | unlocked | 无锁状态 |          |
| thread id                    | epoch        | age                 | 1              | 01       | biasable | 偏向状态 |
| lock record address          | 00           | light-weight locked | 轻量级锁定状态 |          |          |          |
| heavy-weight monitor address | 10           | inflated            | 膨胀状态       |          |          |          |
| forwarding address, etc.     | 11           | marked for GC       | 垃圾回收       |          |          |          |

**《Monitor与synchronized》**

**synchronized**正是基于“**锁对象**”（作为锁的对象）的**Monitor**实例实现的同步：

1. Java中的每个对象都可以关联一个**Moniter**实例，当线程执行到**临界区**时，会在自己的栈桢中开辟空间保存**锁对象**的Mark Word的副本（这一步是我猜的），而Mark Word的内容会替换为**Monitor**的内存地址，**锁对象**也就与**Monitor**关联上了。

2. 1. 线程开辟的这块空间叫做**锁记录**（Lock Record）。
   2. “内存地址”和“指针”是同一回事儿。

3. 同一时刻只允许一个线程使用**Monitor**，从而实现了多线程对**临界区**的互斥访问。

基本类型、Null不是对象，无法关联**Monitor**实例，这也是它俩为啥不能配合**synchronized**使用的原因。

线程在无法执行的时候需要让出**Monitor**，以便其他线程有机会使用。JVM没有明确规定如何实现Monitor与对象的关联。

**《**[**Monitor与同步代码块**](https://blog.hufeifei.cn/2017/06/15/Java/Java多线程复习与巩固（四）--synchronized的JVM实现/#3-jvm-gui-fan-zhong-de-monitor)**》**

同步代码块在编译后，会变成由monitorenter指令和monitorexit指令前后包围的字节码。

1. monitorenter指令用来尝试占有**锁对象**的**Monitor**，如[JVM规范](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter)所述，线程执行monitorenter：

2. 1. 如果**锁对象**的**Monitor**的“entry count”为0，该线程会进入该Monitor并将“entry count”设为1，完成上锁并占有该**Monitor**。（entry count指的是哪个属性？源码里没这个属性。）
   2. 如果线程已经占有了该**Monitor**，则线程会再次进入Monitor并将“entry count”加1（可重入）。（进入又是什么意思？）
   3. 如果**Monitor**已经被其他线程占有，则线程会被阻塞并放入**同步队列**，等待“entry count”归0后，重新尝试占有**Monitor**。

3. monitorexit指令用来释放**锁对象**的**Monitor**。

4. 1. 执行monitorexit的线程必是**Monitor**的所有者。
   2. 每执行一次monitorexit，**Monitor**的“entry count”就会减1。
   3. 当entry减为0时，该线程也就完成了Monitor的释放，不再占有该**Monitor**，同步队列中的其他线程会竞争获取**锁对象**的**Monitor**。

**《****Monitor与****同步方法》**

同步方法与普通方法几乎没有区别，只是多了一个ACC_SYNCHRONIZED标志位，以标明该方式需要同步访问。

调用同步方法时会进入**Monitor**，方法返回时会退出**Monitor**，这一过程由JVM隐式地执行。

**《重量级锁****》**

**synchronized**之所以被称为**重量级锁**是因为：

1. **synchronized**依赖**Monitor**类，而**Moniter**基于操作系统的**MutexLock**（互斥锁）指令，执行该指令时会锁住总线。
2. 阻塞/唤醒会涉及多个线程的切换，即需要从用户态转为核心态，开销大。

为了减少开销，jdk6对**synchronized**[进行了很多优化](https://www.jianshu.com/p/1e8d54cb2bf1)：

1. 引入了锁消除、锁粗化、自适应的自旋等设计。
2. 随竞争的加剧，锁还会进行单向的升级（膨胀）：偏向锁 **->** 轻量级锁 **->** 重量级锁，而非只基于**Monitor**作为重量级锁发挥作用。

**《锁消除》**

有些**临界区**始终处于单线程环境中，不存在多线程的竞争，这时应取消**临界区**（消除同步锁），以减少开销。

开发人员可以根据逻辑将自己代码中没有意义的同步锁消除掉，但无法消除JDK或第三方JAR中的同步锁，如StringBuffer、Vector、HashTable等类。

但JVM会对代码进行**逃逸分析**将没有意义的同步锁消除掉。（那开发人员是否可以放松警惕，随意加锁？）

**《锁粗化》**

**临界区**的范围应尽可能地小，以减少加锁状态的持续时间，从而减少线程的等待时间。但有些代码中会有针对**同一锁对象**的连续的**临界区**，从而引起频繁的加锁/解锁操作，反而增加开销。JVM会识别这种情景，并合并这些**临界区**，以减少加锁/解锁操作。

**《自旋》**

有些**临界区**很小，时间维度上的小，即加锁后很快就会解锁，且线程间的竞争不激烈，这时不值得采用阻塞/唤醒的方式，可以使用**自旋**的方式。

**自旋**要求线程有以下行为：

1. 当一个线程尝试获取锁时，发现该锁已经被其他线程占用，这时该线程应对锁的状态进行循环检测（基于CAS），直到检测到锁被释放，然后线程获取锁。
2. 其中，循环检测的次数应该有一定限度，不应无限等待，当循环超过指定的次数仍然没能获取锁时，线程应取消**自旋**，进入阻塞状态。
3. **自旋**于JDK4引入，循环检测的次数默认为10。

循环次数固定的**自旋**难免有些僵硬，所以JDK6对**自旋**进行了优化，引入了自适应**自旋：**

1. 循环检测的次数不再固定，而是根据持有同一把锁的线程的前一次**自旋**的循环次数及结果来决定。
2. 如果前一次的**自旋**成功，那么这一次的**自旋**也很有可能会成功，所以应增加循环的次数。
3. 如果**自旋**失败，那么应减少循环的次数；当循环的次数减少到0时，应取消**自旋**，改为阻塞/唤醒的方式。

**《偏向锁》**

有研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由**同一**线程多次获得。

所以JDK6后，**synchronized**默认类型为**偏向锁**，其运行过程为：

1. 线程执行到**临界区**，判断**锁对象**的Mark Word是否为可偏向状态。

2. 1. 如果线程是**首次**执行到**临界区**，则会在自己的栈桢中开辟空间，以保存Mark Word的副本。开辟的这块空间叫做**锁记录**（Lock Record）。

3. 若Mark Word的状态标识为**01**，且是否偏向为**0**，说明为“无锁状态”，则进行一次**CAS**操作，尝试将Mark Word替换为可偏向状态（包括设置“是否偏向”为1，设置**ThreadID**等）：

4. 1. 如果成功，则加锁完成。
   2. 如果失败，说明存在竞争，会撤销**偏向锁**。

5. 若Mark Word的状态标识为**01**，且是否偏向为**1**，说明为可偏向状态，然后会判断**ThreadID**是否与自己的相等：

6. 1. 如果相等，说明已经设置偏向锁，且偏向自己，则直接返回。

   2. 如果不相等，说明偏向锁指向的是其他线程，则该线程会进行一次（应该是一次，而非多次）**CAS**操作，尝试将**ThreadID**设为自己的：

   3. 1. 如果成功，则加锁完成。
      2. 如果失败，说明存在竞争，会撤销**偏向锁**。

7. 若Mark Word的状态标识为**00**时，说明锁已经由**偏向锁**升级为**轻量级锁**，进入**轻量级锁**的竞争模式。

8. 若Mark Word的状态标识为**10**时，说明锁已经由**轻量级锁**升为**重量级锁**，进入**重量级锁**的竞争模式。

**偏向锁**仅需进行一次**CAS**，以后执行到**临界区**时，不需要再进行**CAS**，只需判断Mark Word是否为可偏向状态，以及**ThreadID**。

如果存在竞争，会撤销**偏向锁**：

1. 暂停持锁线程。

2. 判断**锁对象**是否处于锁定状态（怎么判断？）：

3. 1. 如果否，则将锁恢复至无锁状态，线程竞争重新获取锁。

   2. 如果是，则：

   3. 1. 将Mark Word设为“轻量级锁定状态”：将状态标识设为**00**，并将持锁线程的**LockRecord**的**地址**写入Mark Word。
      2. 将Mark Word的**地址**也存入到**LockRecord**中（Mark Word的副本之前已经存入到**LockRecord**中了）。
      3. 锁也就升级为了**轻量级锁**，进入**轻量级锁**的竞争模式。

4. 将持锁线程恢复。

注意，暂停/恢复持锁线程的过程没有发生锁的转移。

**《轻量级锁》**

**轻量级锁**也是通过**CAS**来释放锁的：

1. 持锁线程进行一次**CAS**，尝试将Mark Word的内容替换（还原）为自己之前保存在**LockRecord**中的Mark Word**副本**。
2. 如果替换成功，锁会恢复到最初的无锁状态，即成功释放锁。
3. 如果替换失败，说明竞争加剧，已经由**轻量级锁**升级为**重量级锁**，之后会进入**重量级锁**的竞争模式：释放锁的同时，唤醒阻塞的线程。

由**偏向锁**升级而来的**轻量级锁**的运行过程为：

1. 线程执行到**临界区**，发现Mark Word为“轻量级锁定状态”，即状态标识为**00**。

2. 线程会判断Mark Word中保存的**LockRecord**的**地址**是否是自己的**LockRecord**的**地址**：

3. 1. 如果是，则说明已经获取了**轻量级锁**，可以运行临界区中的代码。

   2. 如果否，则说明锁已被其他线程占有，该线程会**自旋**，即循环执行**CAS**，尝试将无锁状态的Mark Word的内容替换为“轻量级锁定状态”，且其中的**LockRecord**的**地址**为自己的**LockRecord**：

   3. 1. 如果持锁线程释放锁，即锁恢复到最初的无锁状态，那么**CAS**会成功，该线程也就得到了**轻量级锁**，线程会将Mark Word的**地址**也存入到**LockRecord**中。
      2. 如果直到**自旋**结束，持锁线程仍未释放锁，即该线程仍未获得锁，该线程就会将**轻量级锁**升级为**重量级锁**：将状态标识设为**10**，将Mark Word的内容替换为**Monitor**的地址。

除了**偏向锁**升级得到**轻量级锁**，我们还可以直接关闭JVM的**偏向锁**设置，将**轻量级锁**作为**synchronized**的默认类型，这时当线程运行到**临界区**，会判断Mark Word的内容：

1. 如果为“轻量级锁定状态”，则线程按照上文所述的过程运行。

2. 如果为“膨胀状态”，           则线程进入**重量级锁**的竞争模式（好像两句废话）。

3. 如果为“无锁状态”，           则线程将Mark Word的副本保存到**LockRecord**中，然后进行一次**CAS**，尝试将无锁状态的Mark Word的内容替换为“轻量级锁定状态”，且其中的**LockRecord**的**地址**为自己的**LockRecord**：

4. 1. 如果成功，该线程也就得到了**轻量级锁**，线程会将状态标识为**00**，并将Mark Word的**地址**也存入到**LockRecord**中。
   2. 如果失败，说明锁已被其他线程占有，该线程会**自旋**，之后的过程无需赘述。

**《偏向锁、轻量级锁、重量级锁的比较》**

1. **偏向锁**

2. 1. 仅需在设置**ThreadID**时执行一次**CAS**，之后进入**临界区**时不需进行**CAS**，仅需在内存中判断ThreadID是否相等，开销小。
   2. 并且即便**偏向锁**因升级为**轻量级锁**而需要撤销时会带来的开销，但也小于节省下来的**CAS**开销。
   3. 持有**偏向锁**的线程不会主动解锁，且一有竞争会立刻升级为**轻量级锁**，只适合一个线程执行临界区的场景。

3. **轻量级锁**

4. 1. 加锁/解锁操作需要执行多次**CAS**，执行**CAS**时会锁住总线，且**自旋**会消耗CPU，开销略大。
   2. 适合多线程交替执行同步代码块，即有竞争但不激烈的场景。

5. **重量级锁**

6. 1. 缺点不再赘述，就是太重，但竞争激烈的场景只能用它。