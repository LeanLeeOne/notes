### 极限

MySQL单表数据达到2000万时，性能会下降，此时就需要分表了。

[之所以是2000万，主要跟B+树有关。](https://zhuanlan.zhihu.com/p/355302417)



### [数据库分库分表思路](https://www.cnblogs.com/butterfly100/p/9034281.html)

ShardingSphere是一个用于分库分表的中间件



### 千万级数据的导入导出

在分库分表的基础上，需要在传输过程中对<u>**内存使用空间**</u>和<u>**磁盘的流量**</u>进行限制，同时还需增加监控，动态调整导入 / 导出程序对<u>**内存**</u>、<u>**磁盘**</u>的使用情况。



### 分布式ID

对数据库分库分表后需要有一个唯一ID来标识一条记录：

1. 全局唯一，最基本的要求。
2. 趋势递增，大部分的数据库都使用了基于B树的数据结构来存储数据，主键的有序能保证读写性能。
3. 单调递增，以满足事务版本号、增量消息、排序的需要。
4. 信息安全，如果ID是连续的，则很容易被恶意用户掌握数据量。

[常见方案](https://zhuanlan.zhihu.com/p/107939861)：

1. <span style=background:#c2e2ff>UUID</span>

   1. 分为5段，8-4-4-4-12共36个字符。
   2. **优点**：本地生成，没有网络损耗。
   3. **缺点**：过长且无序，从而不易存储，作为主键会降低数据库读写性能；包含MAC信息，有泄露MAC的风险。

2. <span style=background:#c2e2ff>Redis</span>

   1. 使用原子性的自增指令`incr`、`increby`。
   2. **优点**：性能高。
   3. **缺点**：需要考虑持久化的问题，RDB存在重复风险、AOF恢复时间长。

3. <span style=background:#c2e2ff>自增ID</span>
   1. 单独创建数据库实例 / 集群，利用数据库自带的自增ID。
   2. **优点**：简单，绝对有序。
   3. **缺点**：单机情况下，性能低；集群模式下，步长难扩展。

4. <span style=background:#d4fe7f>号段 / 批量ID</span>

   1. 一次生成一批，数据库中只保存最大值、步长，内存中保存当前ID。
   2. **优点**：减少了数据库的访问次数，提升了性能。
   3. **缺点**：几乎没有缺点，只是服务重启后ID会不连续，然后信息不安全。

5. <span style=background:#d4fe7f>类snowflake方案</span>

   1. UUID其实也算作类snowflake方案。

   2. **优点**：性能高。

   3. **缺点**：依赖机器时钟，存在发号重复风险；js中的数字只有Double，只有53位保存数值，Long型的ID传到前段时需要转成String才能处理。

      ![0](../images/7/snowflake.png)

6. <span style=background:#c2e2ff>[美团Leaf](https://tech.meituan.com/2017/04/21/mt-leaf.html)</span>

   1. Leaf-segment，批量取号，易于扩展，双缓存平顺。
   2. Leaf-snowflake，使用**Zookeeper**生成的节点顺序号作为Worker ID。



### 关于数据库系统中的库（实例）存在意义的理解

数据库的存在<span style=background:#c2e2ff>库（实例）</span>这一概念，是为了节约硬件资源。

每个应用系统几乎都需要一个数据库，而一个应用按照不同的运行环境（开发、测试、生产）又需要不同的数据库。但受限于资金，我们无法为每个应用，甚至每个应用的不同运行环境，单独部署一台数据库。

为此，数据库（系统）允许我们在一台数据库上创建多个相互隔离的<span style=background:#c2e2ff>库（实例）</span>，充分利用硬件资源。当然前提是各个<span style=background:#c2e2ff>库（实例）</span>的负载不大。

另外，不同运行环境下的<span style=background:#c2e2ff>库（实例）</span>还是要部署在不同数据库服务器上的，还是要避免相互影响。

