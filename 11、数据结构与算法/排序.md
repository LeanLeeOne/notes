## 快速排序

选取数组中的第一个元素，然后从右往左逐个查找，找到比该元素小的数值后，停止查找，交换两个元素的值，然后再从左往右逐个查找，找到比该元素大的元素后，停止查找，交换两个元素的值，重复此步骤，直到左右下标相等，然后以此元素为界限，分别对数组的左右两部分递归应用该流程，最后返回的就是排好序的数组。

```javascript
sort = (a, start, end) => {
	let p = a[start];
	let i=start;
	let j=end;
	while(i<j){
		while(i<j && p<a[j]){
			j--;
		}
		while(i<j && p>a[i]){
			i++;
		}
		if(a[i] == a[j] && i<j){
			i++
		}else{
			let temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	(i-1 > start) && sort(a, start, i-1);
 (j+1 < end) && sort(a, j+1, end);
}

var array=[2, 4, 6, 11, 3, 22, 1, 5, 7, 8];
sort(array, 0, array.length-1);
```



## 排序算法的比较[[1]](https://www.cyc2018.xyz/算法/基础/算法 - 排序.html)

|       算法       | 稳定性 |         时间复杂度          | 空间复杂度 |           备注           |
| :--------------: | :----: | :-------------------------: | :--------: | :----------------------: |
|     选择排序     |   ❌    |          `O(n^2)`           |   `O(1)`   |                          |
|     冒泡排序     |   ✔    |          `O(n^2)`           |   `O(1)`   |                          |
|     插入排序     |   ✔    |      `O(n)` ~ `O(n^2)`      |   `O(1)`   | 时间复杂度和初始顺序有关 |
|     希尔排序     |   ❌    | n的若干倍乘于递增序列的长度 |   `O(1)`   |      改进版插入排序      |
|     快速排序     |   ❌    |         `O(n*logn)`         | `O(logn)`  |           最快           |
| 三向切分快速排序 |   ❌    |    `O(n)`  ~ `O(n*logn)`    | `O(logn)`  |   适用于有大量重复主键   |
|     归并排序     |   ✔    |         `O(n*logn)`         |   `O(n)`   |                          |
|      堆排序      |   ❌    |         `O(n*logn)`         |   `O(1)`   |    无法利用局部性原理    |

