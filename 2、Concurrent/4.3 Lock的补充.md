### Atomic

<span style=background:#b3b3b3>java.util.concurrent.atomic.*</span>，原子操作封装类，通过**volatile**+**CAS**+**自旋**来实现线程安全访问。

**AtomicInteger**主要有3个属性：

1. <span style=background:#e6e6e6>volatile int value</span>，实际的值。
2. <span style=background:#e6e6e6>static final Unsafe unsafe</span>，获取并操作内存的数据。
3. <span style=background:#e6e6e6>static final long valueOffset</span>
   1. value属性相对于AtomicInteger的首地址的偏移量，之后的自增自减是直接对内存进行操作的，所以需要内存偏移量。
   2. 对于一个确定的运行环境，其valueOffset是固定不变的，但这不代表着可以写死。因为对于不同的开发环境，比如32位JVM和64位JVM，它俩的valueOffset就不同，所以采用了这种编码的形式，而没有直接写死。

Java8提供LongAdder、LongAccumulator来应对多线程高度竞争的场景。



### JUC与AQS

**JUC**（<span style=background:#b3b3b3>java.util.concurrent.\*</span>）提供了很多并发工具类，它们都是基于**AQS**实现的，比起直接使用<span style=background:#b3b3b3>Object.wait()/wait(long)</span>、<span style=background:#b3b3b3>Object.notify()/notifyAll()</span>要方便得多。

ThreadPoolExecutor.Worker也是利用**AQS**同步状态，实现对独占线程变量的设置（tryAcquire()、tryRelease()）。

[3种常见的并发控制工具](http://blog.sina.com.cn/s/blog_7d1968e20102xewm.html)：

1. **CountDownLatch**
   1. 子任务完成后通知主任务。
   2. 每完成一个子任务就调用<span style=background:#b3b3b3>CountDownLatch.countDown()</span>（<span style=background:#e6e6e6>Sync.tryReleaseShared()</span>），将<span style=background:#c2e2ff>未完成的子任务数</span>（count）减一，当count归零后，主线程会从<span style=background:#b3b3b3>CountDownLatch.await()</span>（<span style=background:#e6e6e6>Sync.tryAcquireShared()</span>）中醒来。<span style=background:#c2e2ff>未完成的子任务数</span>需要<span style=background:#c9ccff>预设</span>。
   3. 可应用于并发处理一张excel里的多个sheet。
2. **CyclicBarrier**
   1. 子任务完成后通知主任务。
   2. 可循环使用的（Cyclic）内存屏障（Barrier）。当子任务到达一个屏障，即<span style=background:#b3b3b3>CountDownLatch.await()</span>处，也称同步点）时会被阻塞，直到所有的子任务都到达屏障时，阻塞才会接触。<span style=background:#c2e2ff>子任务数</span>同样需要<span style=background:#c9ccff>预设</span>。
   3. 可以设置当所有子任务都到达屏障时，要执行的动作。
3. **Semaphore**
   1. 可用于共享资源数量的控制，比如数据库连接数。<span style=background:#c2e2ff>资源数量</span>同样需要<span style=background:#c9ccff>预设</span>。
   2. <span style=background:#b3b3b3>Semaphore.acquire()</span>，减少计数，<span style=background:#e6e6e6>Sync.tryAcquireShared()</span>。
   3. <span style=background:#b3b3b3>Semaphore.release()</span>，增加计数，<span style=background:#e6e6e6>Sync.tryReleaseShared()</span>。

并发读写锁：

1. **ReadWriteLock**

   1. **ReadWriteLock**是一种悲观锁，允许在没有写入时，多个线程并发读；但在读时不允许写入。
   2. **ReadWriteLock**适合读多写少的场景。
   3. 在创建**ReadWriteLock**后，需要先获取读锁或写锁，然后才能加锁，如，<span style=background:#b3b3b3>ReadWriteLock.readLock().lock()</span>。
   4. 其实现类**ReentrantReadWriteLock**，使用<span style=background:#b3b3b3>AQS.state</span>的高16位保存写锁持有的次数，低16位保存读锁的持有次数。
   5. 不允许锁的升级，允许降级。

2. **StampedLock**

   1. **StampedLock**是一种乐观锁，于Java 8引入，也用于并发读写，它与**ReadWriteLock**的最大不同在于<u>支持读时写入</u>。
   2. <u>支持读时写入</u>意味着读取的数据可能不一致，所以**StampedLock**需要额外检测数据是否一致，若不一致则将乐观读升级为悲观读。
   3. **StampedLock**的写锁不可重入，读锁可重入。

   ```java
   // StampedLock的使用说明：
   long stamp = stampedLock.tryOptimisticRead(); // 加乐观锁
   …… // 读取
   if(!stampedLock.validate(stamp)){ // 检测数据是否一致
       stamp = stampedLock.readLock(); // 升级为悲观锁
       try{
           …… // 重新读取
       }finally{
           stamped.unlockRead(stamp); // 解锁
       }
   }
   …… // 业务代码
   ```

 [下图](https://www.infoq.cn/news/java-memory-model-5)为JUC框架的层级结构：

![](../images/2/juc-framework.webp)



### [锁的分类](https://tech.meituan.com/2018/11/15/java-lock.html)

1. 乐观锁和悲观锁。

   1. **乐观锁**，认为读的过程中大概率不会有写，基于CAS。
   2. **悲观锁**，认为读的过程中有写，写入需要等待读取完成。
   3. 在数据库中有所应用。
2. 公平锁和非公平锁。

   1. 公平与否的标准在于是否允许插队。
   2. 插队能提高效率（吞吐量）。
3. 可重入锁和不可重入锁。

   1. 可重入的意思是允许同一持锁者重复加锁，不会产生死锁。
   2. 我们所遇到的锁绝大部分都是可重入的。
4. 共享锁和排他锁。
   1. **读**过程可以是**共享**的，也可以**排他**的，但**写**过程只能是**排他**的。
   2. 并发**读**的过程很难感知到数据的更新，所以**共享锁**往往只允许并发**读**，不允许**写**。
   3. **独占锁**，也称**排他锁**。独占可以是完全的，即只允许持锁者**读写**，也可以是不完全的，即只允许持锁者**写**，但允许其他人**读**。
   4. 在数据库中有所应用。
5. 偏向锁、轻量级锁、重量级锁。



### 死锁

死锁可从3个方面预防：

1. 破坏互斥条件
1. 破坏占用和等待条件
   1. 使用同一个锁对象。
1. 破坏不可抢占条件
   1. 即中断阻塞，所以**Lock**可破坏，**synchronized**无法破坏。
   2. 支持超时。
   3. 非阻塞地获取锁，获取锁失败时直接返回，不进入阻塞状态。
1. 破坏循环等待条件
   1. 当多个线程持有不同的锁，并试图获取对方已持有的锁时，就会无限等待，即死锁。
   1. 有序加锁：多线程按照统一的顺序获取锁，能防止死锁。



### 分布式锁

[How to do distributed locking?](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)

