MySQL中的锁按照粒度划分可以分为3种：全局锁、表锁和行锁。

可以直接阅读《[全局锁、表锁、行锁](https://juejin.cn/post/6844904132046749710)》，这篇文章脉络条理清晰，就是挫别字有点多，而且也像是抄的，文章大纲为：

1. 全局（读）锁（flush tables with read lock）

   1. 为什么需要全局锁
   2. 全局锁的缺点
   3. 全局锁的替换方案（使用事务）
   4. 为什么不设置全局读

2. 表锁（lock tables table_name read, table_name2 write）

   1. 读锁（共享锁，又称S锁（这种简称真low），写锁（排他锁，X锁）
   2. 表锁注意事项

   3. 元数据锁，也分为读锁、写锁

   4. 1. [这篇文章](https://www.cnblogs.com/keme/p/11065025.html)中的“元数据锁”章节提到了一个元数据锁的注意事项，如右图所示：

3. 行锁

   1. 行锁的两阶段协议
   2. 死锁问题
   3. MySQL中死锁的解决方案



表锁：

1. 优点：获取、释放开销小，不易死锁。
2. 缺点：粒度小、并发量低。

行锁：

1. 优点：粒度细，并发量大。
2. 缺点：获取、释放开销大，易死锁。

InnoDB的行锁是通过对索引项加锁，而非对记录加锁来实现的。

1. 查询数据时只有在过滤条件中包含自定义索引，才可能触发行锁。
2. MySQL会根据SQL的执行代价来选择是否使用索引，所以有时即便查询条件里包含索引列，但是如果全表遍历的成本较低，MySQL就不会选择使用索引，也就不会触发行锁。
3. 使用相同索引项查询时，可能会引起冲突。

减少SQL的执行时间，确保锁定及时释放。



可通过加行锁来控制数据的<span style=background:#e6e6e6>并发写</span>，MySQL加<span style=background:#c9ccff>行锁</span>的过程跟是否有索引有关：

1. 有索引时，直接定位到相应的行，加锁。
2. 无索引时，会先将所有行加锁<span style=background:#e6e6e6>（这么弱智？）</span>，然后遍历，将不符合条件的行的锁取消。不难看出，这样开销巨大。



Mysql 有很多类型对种锁，`表锁`、`record lock`、`gap lock`、`意向共享/排他锁`、`插入意向锁`、`元数据锁`、`Auto_Incr自增锁`，排除掉 *元数据锁*、Auto_Incr自增锁 之后，剩下的锁组合使用最多的就是在RR隔离级别下。https://www.cnblogs.com/wangiqngpei557/p/12236155.html

<span style=background:#ffee7c>意向锁</span>

[插入意向锁本质上是加间隙锁，是为了保证最大并发插入，不相关的行插入不受到互斥。](https://www.cnblogs.com/wangiqngpei557/p/12236155.html)

https://blog.csdn.net/zcl_love_wx/article/details/81983267

https://www.jb51.net/article/181429.htm



![0](../images/7/serial-execution.png)