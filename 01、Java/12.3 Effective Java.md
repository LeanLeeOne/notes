## 简介

Effective Java，编写高效的Java代码，其中的"高效"包含两个方面：高维护性、高性能。

- 高维护性又包括3方面：
  - 易读：便于
  - 安全
  - 容易扩展
  - 不易出错
- 高性能指的是运行速度快、空间占用少。

高维护性和高性能这两个追求一般不会产生冲突，但如果产生冲突，作者认为，可维护性比性能更重要，<span style=background:#ffee7c>因为</span>



## 主要章节介绍

第1章为引言。

第2章阐述何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清除动作。

第3章阐述对于所有对象都通用的方法，你会从中获知对equals、hashCode、toString、clone、finalize以及Comparable.compareTo方法相当深入的分析，从而避免今后在这些问题上再次犯错。

第4章阐述作为Java程序设计语言的核心以及Java语言的基本抽象单元（类和接口）在使用上的一些指导原则，帮助你更好地利用这些元素，设计出更加有用、健壮和灵活的类与接口。

第5章和第6章分别阐述在Java 1.5发行版本中新增加的泛型（Generic）以及枚举（Enum）和注解（Annotation）的最佳实践，教你如何最大限度地享有这些优势，并使整个过程尽可能地简单化。

第7章专门讨论在Java 8中新增的函数接口（Functional Interface）、**Lambda**表达式和方法引用（Method Reference），使创建函数对象（Function Object）变得更加容易。接着探讨为处理数据元素的序列提供了类库级别支持的Stream API，以及如何最佳的利用这些机制。

第8章讨论方法设计的几个方面：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档，从而使方法设计在可用性、健壮性和灵活性上有进一步的提升。

第9章主要讨论Java语言的具体细节，讨论了局部变量的处理、控制结构、类库的使用、各种数据类型的用法，以及两种不是有语言本身提供的机制（Reflection和Native Method，反射机制和本地方法）的用法，并讨论了优化和命名惯例。

第10章阐述如何充分发挥异常的优点来提高程序的可读性、可靠性和可维护性，以及减少异常使用不当所带来的负面影响，并提供一些关于有效使用异常的指导原则。

第11章阐述如何帮助你编写出清晰、正确、文档组织良好的并发程序，比如如何避免过度同步，优先采用Executor Framework、并发集合（Concurrent Collection）、同步器（Synchronizer），记忆是否需要依赖于线程调度器等。

第12章阐述序列化方面的技术，并且有一项值得特别提及的特性，就是序列化代理（Serializable Proxy）模式，它可以帮助你避免对象序列化的许多缺陷。

> 官方中文版的翻译水平与网友的评价一致——蹩脚，故本文主要参考[开源版本](https://github.com/sjsdfg/effective-java-3rd-chinese/tree/v1.4/docs/notes)。
>
> 但是该*开源版本*存在很多笔误，而且翻译水平仍没完全实现“信达雅”。



## 目录

### 一、引言

### 二、创建和销毁对象

1、静态工厂方法优于构造方法

2、当构造方法参数过多时使用`Builder`模式

3、使用私有构造方法或枚举类实现`Singleton`属性

4、使用私有构造器方法执行非实例化

5、依赖注入优于引用资源

6、避免创建不必要的对象

7、消除过期的对象引用

8、避免使用`Finalizer`和`Cleaner`

9、`try-with-resources`优于`try-finally`

### 三、对于所有对象都通用的方法

10、重写`equals`时遵守通用约定

11、重写`equals`时同时也要重写`hashCode`

12、始终要重写`toString`

13、谨慎地重写`clone`

14、考虑实现`Comparable`接口

### 四、类和接口

15、使类和成员的可访问性最小化

16、在公共类而非公共属性中使用访问方法

17、使可变性最小化

18、组合优于继承

19、要么设计继承并提供文档说明，要么禁止用继承

20、接口优于抽象类

21、为后代设计接口

22、接口只用于定义类型

23、类层次结构优于标签类

24、静态成员类优于非静态成员类

25、将源文件限制为单个顶级类

### 五、泛型

26、不要使用原始类型

27、消除非受检的警告

28、列表优于数组

29、优先考虑泛型

30、优先考虑泛型方法

31、利用限定通配符来提升API的灵活性

32、谨慎地结合泛型和可变参数

33、优先考虑类型安全的异构容器

### 六、枚举和注解

34、用`Enum`代替`int`常量

35、用实例属性代替序数

36、用`EnumSet`代替位属性

37、用`EnumMap`代替序数索引

38、用接口模拟可扩展的`Enum`

39、注解优于命名模式

40、始终使用`Override`注解

41、用标记接口定义类型

### 七、Lambda和Stream

42、**Lambda**优于匿名类

43、方法引用优于**Lambda**

44、优先使用标准的函数接口

45、慎用`Stream`

46、优先选择`Stream`中无副作用的函数

47、使用`Collection`作为返回类型优于使用`Stream`

48、慎用`Stream`并行

### 八、方法

49、检查参数的有效性

50、必要时进行保护性拷贝

51、谨慎设计方法签名

52、慎用重载

53、慎用可变参数

54、返回空数组或者空集合，而非`null`

55、谨慎地返回`Optional`

56、为所有已公开的API元素编写文档注释

### 九、通用编程

57、使局部变量的作用域最小化

58、`for-each`循环优于传统的`for`循环

59、了解并使用类库

60、如需精确答案，应避免使用`float`和`double`

61、基本类型优于包装类型

62、若其他类型更合适，则尽量避免使用字符串

63、了解字符串连接的性能

64、通过接口引用对象

65、接口优于反射

66、谨用本地方法

67、谨慎地进行优化

68、遵守普遍接受的命名惯例

### 十、异常

69、只针对异常的情况才使用异常

70、对可恢复的情况使用受检异常，对编程错误使用运行时异常

71、避免不必要地使用受检异常

72、优先使用标准的异常

73、抛出与抽象对应的异常

74、每个方法抛出的所有异常都要建立文档

75、在细节消息中包含失败-捕获信息

76、努力使失败保持原子性

77、不要忽略异常

### 十一、并发

78、同步访问共享的可变数据

79、避免过度同步

80、`executor`、`task`和`stream`优于线程

81、并发工具优于`wait`和`notify`

82、线程安全性的文档化

83、慎用延迟初始化

84、不要依赖线程调度器

### 十二、序列化

85、其他方法优于Java序列化

86、谨慎地实现`Serializable`接口

87、考虑使用自定义的序列化形式

88、保护性地编写`readObject`方法

89、对于实例控制，枚举类型优于`readResolve`

90、考虑用序列化代理代替序列化实例



## 摘要

### 一、引言

无

------

### 二、创建和销毁对象

#### 1、静态工厂方法优于构造方法

> <u>静态工厂方法</u>与设计模式中的<u>工厂方法模式</u>不同，即，本条目中描述的<u>静态工厂方法</u>在设计模式中没有直接的等价。

提供<u>静态工厂方法</u>而不是<u>构造方法</u>有优点也有缺点。

- 优点
  - <u>静态工厂方法</u>有名字，易读、不必纠结方法签名。
  - <u>静态工厂方法</u>不需要每次调用时都创建一个对象，允许创建不可变类、缓存实例。
  - <u>静态工厂方法</u>可以反悔其返回类型的任何子类型的对象。
  - <u>静态工厂方法</u>返回对象的类可以根据<u>输入参数</u>的不同而不同。
  - <u>静态工厂方法</u>在编写包含该方法的类时，返回的对象的类不需要存在。
- 缺点
  - 如果类没有`public`或`protected`类型的<u>构造方法</u>，那么该类就无法被子类化。
  - 程序员难以发现<u>静态工厂方法</u>。

#### 2、当构造方法参数过多时使用建造者模式

`Builder`模式结合了<u>可伸缩构造方法</u>模式的安全性和`JavaBean`模式的可读性。

#### 3、使用私有构造方法或枚举类实现单例属性

<u>单一元素枚举类</u>通常是实现单例的最佳方式。

#### 4、使用私有构造器方法执行非实例化

试图通过创建<u>抽象类</u>来强制执行<u>非实例化</u>是行不通的。

可以通过包含一个<u>私有构造方法</u>来实现类的<u>非实例化</u>。

#### 5、依赖注入优于引用资源

<u>静态工具类</u>和<u>单例类</u>不适合用来实现以来一个或多个底层资源的类。

将资源或工厂传递给<u>构造方法</u>，以创建实例，即，依赖注入。

#### 6、避免创建不必要的对象

优先使用<u>基本类型</u>而不是<u>包装类型</u>，同时要注意无意识的<u>自动装箱</u>。

> 创建额外的对象以增强程序的清晰度、简单性或功能性通常是件好事。

#### 7、消除过期的对象引用

消除过期的对象引用，以避免内存泄漏。

当一个类自己管理内存时，程序员就需要警惕内存泄漏问题。

#### 8、避免使用`Finalizer`和`Cleaner`

能不用就不用，并且大概率用不到。

#### 9、`try-with-resources`优于`try-finally`

`try-with-resources`更加方便、简洁。

------

### 三、对于所有对象都通用的方法

#### 10、重写`equals`时遵守通用约定

重写`equals`时要遵守自反性、对称性、传递性、一致性、非空性。

推荐使用**Google**的开源框架AutoValue。

#### 11、重写`equals`时同时也要重写`hashCode`

求得属性对<u>散列值</u>`c`，然后循环执行`result = 31 * result + c;`来计算对象的<u>散列值</u>。

或者使用**Guava**的`com.google.common.hash.Hashing`。

如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存<u>散列值</u>，而不是在每次请求时重新计算哈希码。

#### 12、始终要重写`toString`

通过重写`toString()`来输出有效内容，可以让调试过程更加方便。

实现`toString()`时，必须在文档中指定返回值的*格式*，如果没有使用格式，也需要在文档中指明。

<u>静态工具类</u>无需重写`toString()`。

#### 13、谨慎地重写`clone`

重写`clone()`时需要注意的事项很多，所以，新的接口不应该继承它，新的可扩展类不应该实现它，如有需要，可使用<u>复制构造方法</u>或<u>复制工厂</u>。

> 重写`clone()`时，方法的返回类型可以是重写方法的返回类型的子类。
>
> 如果对象的每个属性包含原始值或对不可变对象的引用，则`super.clone()`返回的对象可能正是你所需要的，不需要进一步的处理。但如果对象某个属性包含对可变对象的引用，则在重写`clone()`时需要对该属性的内部进行复制。
>
> - <u>不可变类</u>不应提供`clone()`，因为这只会浪费复制。
> - 当可变对象是数组时，此时不必将某一类型的数组转换为`Object[]`，因为在数组上调用`clone()`会返回一个数组，其运行时和编译时类型与被克隆的数组相同。
> - 如果引用可变对象的属性使用`final`进行修饰，那么就没法赋值了，只能移除`final`。
>
> 与<u>构造方法</u>一样，`clone()`绝对不可以在构建过程中调用一个可以重写的方法，否则子类有机会在克隆中修复它的状态之前执行该方法，进而导致克隆和原始对象的损坏。
>
> 在设计父类时，通常有两种选择，但无论选择哪一种，都不应该实现`Clonable`接口，但可以选择通过实现正确运行的`protected clone()`来模仿`Object.clone()`。
>
> 如果类有线程安全的要求，那么在重写`clone()`是不要忘了进行同步。

#### 14、考虑实现`Comparable`接口

`Comparable.compareTo()`与`Object.equals()`相似，但是前者支持泛型，用于比较大小。

Java类库中的绝大部分值类、枚举类都实现了`Comparable`接口。

实现`Comparable`也应遵守自反性、对称性、传递性。

重写`Comparable.compareTo()`时，请避免使用`<`和`>`，应使用包装类中的静态方法`compare()`或`Comparator`接口中的构建方法。

------

### 四、类和接口

#### 15、使类和成员的可访问性最小化

> **良好的封装**是软件设计的基本原则。
>
> - **良好的封装**有助于组件的分离/解耦，进而有助于组件的独立开发、测试、理解、使用、修改，而这能加速系统的开发、降低维护的成本。
> - **良好的封装**本身不会带来良好的性能，但是有助于分析/确定组件的性能，这样在优化某些组件时不会影响其它正确的组件。
> - **良好的封装**增加了代码的可重用度，同时也降低了构建大型系统的风险。

要做到**良好的封装**，要尽可能地让每个类或成员不可访问。

> 成员包括属性、方法、嵌套类和嵌套接口。

公共类的实例属性很少使用`public`进行修饰，并且带有<u>公共可变属性</u>的类通常不是线程安全的。

> 即使该属性使用了`final`进行修饰，并且引用了一个不可变的对象，而一旦将其公开就意味着放弃了切换到新的内部数据表示的灵活性。
>
> 失去灵活性的问题适用于静态属性，但有一个例外：经`public static final`修饰的常量是类的抽象的一部分。
>
> 而例外的例外是，如果经`public static final`修饰的常量是**数组**，那么直接返回该数组的行为是错误的，因为非零长度的数组总是可变的，此时应返回该数组的一个快照/副本。

#### 16、在公共类而非公共属性中使用访问方法

如果一个类在其包之外是可访问的，则应该提供访问方法来保留更改类内部表示的灵活性。

> 但如果一个类是<u>包级私有</u>的，或者是一个<u>私有内部类</u>，则直接暴露它的数据属性也没有太大问题。

#### 17、使可变性最小化

与<u>可变类</u>相比，<u>不可变类</u>更易于设计、实现、使用，更不容易出错，更安全。

> 不可变对象本质上是线程安全的，因为它们不需要同步。

<u>不可变类</u>的设计需遵循：

1. 不提供修改对象状态的方法（mutators，设值方法）。
2. 确保该类不能被继承。
   1. 使用`final`修饰类来实现。
   2. 或者，可以使所有的<u>构造方法</u><u>私有</u>或<u>包级私有</u>，并添加<u>公共静态工厂</u>。
3. 所有字段都用`final`来修饰。
  1. 但是可以放宽该条原则以提高性能。
4. 所有字段都用`private`来修饰。
5. 确保对任何可变组件的互斥访问。

> <u>不可变类</u>的主要缺点是对于每个不同的值都需要一个单独的对象，而创建这些对象的代价可能很高，进而影响性能。
>
> 对此，可为<u>不可变类</u>创建一个<u>包级私有的可变伙伴类</u>，如`String`和`StringBuilder`。

#### 18、组合优于继承

<u>继承</u>虽然强大，但是破坏了<u>封装</u>，而<u>组合</u>不会。

只有在<u>子类</u>和<u>父类</u>存在真正的父子关系时才可以使用。

> 在包中使用<u>继承</u>是安全的，因为<u>子类</u>和<u>父类</u>都在同一个程序员的控制之中。
>
> <u>组合</u>涉及<u>包装类</u>和<u>被包装类</u>，也被称为<u>装饰器模式</u>。
>
> <u>组合</u>和<u>转发</u>的结合被不准确地称为<u>委托</u>（delegation），而严格意义上的<u>委托</u>需要<u>包装对象</u>把自身传递给<u>被包装对象</u>。

#### 19、要么设计继承并提供文档说明，要么禁止用继承

对于 *专门为继承而设计的类*，其每个`public`或者`protected`方法的文档中，必须指明该方法调用哪些可重写方法，以及这些方法以何种顺序调用的，以及每次调用的结果又是如何影响后续处理，并遵守这些描述。否则，<u>子类</u>就会依赖<u>父类</u>的实现细节，如果<u>父类</u>的实现发生了变化，<u>子类</u>就有可能遭到破坏。

> 好的API文档应该是描述该方法做了什么，而不是描述方法是如何做到的。
>
> *编写子类* 是测试 *专门为继承而设计的类* 的唯一方法。通常来说，三个子类足以测试一个可继承的类，而这些子类应该由父类作者以外的人编写。

<u>构造方法</u>绝不能直接或间接地调用可重写的方法。

#### 20、接口优于抽象类

Java只允许单一继承，没有接口来得灵活。

当接口方法有明显的方法实现时，可以提供<u>默认方法</u>。

> 但默认方法有部分限制：
>
> - `Object`类中方法，如`equals()`和`hashCode()`，不允许提供<u>默认方法</u>。
> - 接口不允许包含<u>实例属性</u>或<u>非公共静态成员</u>，<u>私有静态方法</u>除外。
> - 不能将<u>默认方法</u>添加到不受控制的接口中。

Abstract Skeletal Implementation Class，抽象的骨架实现类，将<u>接口</u>和<u>抽象类</u>的优点结合起来。

> 按照惯例，<u>抽象骨架实现类</u>被称为`AbstractInterface`，如：`AbstractCollection`，`AbstractSet`。

#### 21、为后代设计接口

Java8新增的<u>默认方法</u>是为了允许将方法添加到现有的接口。

> 使用<u>默认方法</u>可以将新的方法添加到现有接口中，但不能保证这些方法可以在所有已有的实现中使用，因为在Java8之前，这些实现是用默认的接口编写的，这些默认接口永远不会获得任何新的方法，如`org.apache.commons.collections4.collection.SynchronizedCollection`。所以应尽量避免使用<u>默认方法向</u>现有接口中添加新的方法。
>
> Java8向核心集合接口中添加了许多新的<u>默认方法</u>，以便使用Lambda。

#### 22、接口只用于定义类型

<u>常量接口</u>是包含常量的接口，也就是只包含经`static final`修饰的属性。

使用<u>常量接口</u>后，使用常量名时就无需再用类名限定了，但是这违反了”接口仅用于标识类型“的初衷，故不推荐使用。

> 对类的使用者来说，类实现一个<u>常量接口</u>是没有意义的，还会令他们感到困惑。
>
> 另外，如果一个非`final`类实现了<u>常量接口</u>，那么它的所有子类的命名空间都会被接口中的常量所污染。

#### 23、类层级结构优于标签类

<u>标签字段</u>是用于标识实例类型的字段，拥有<u>标签字段</u>的类叫做<u>标签类</u>。

<u>标签类</u>冗长的、易出错、效率低，不如用子类表示不同类型的方式。

使用子类的方式将原有的类分成了父类、子类两个层级，故叫做<u>类层级结构</u>。

> <u>标签类</u>实际上仅是对<u>类层级结构</u>的简单的模仿。

#### 24、静态成员类优于非静态成员类

<u>嵌套类</u>是在另一个类中定义的类。“另一个类”叫做<u>顶级类</u>。

<u>嵌套类</u>只应存在于其宿主类中，否则它应该是一个<u>顶级类</u>。

<u>嵌套类</u>有4种：静态成员类、非静态成员类、匿名类和局部类。后三种被称为内部类。

> 4种嵌套类各有用途：
>
> - 如果一个成员类的每个实例都需要引用其宿主实例，则使其成为<u>非静态</u>的；否则，使其静态。
> - 如果一个类属于一个方法内部，且只需要从一个地方创建其实例，且存在一个预置类型来说明这个类的特征，那么将其作为<u>匿名类</u>；否则，把它变成局部类。

> 另外：
>
> - 如果一个<u>包级私有顶级类</u>或<u>接口</u>只被某个类使用，那么可以考虑将该<u>包级私有顶级类</u>或<u>接口</u>作为该类的<u>私有静态嵌套类</u>。
> - <u>非静态成员类</u>的每个实例都有一个对其宿主实例的隐藏的外部引用，而存储这个引用会有额外的时空开销，同时会有<u>内存泄露</u>的风险。
> - <u>匿名类</u>虽然有很多限制，但在引入Lambda之前，它是函数式编程的首选。
> - <u>局部类</u>很少被使用。

#### 25、将源文件限制为单个顶级类

虽然Java允许在单个源文件中定义多个<u>顶级类</u>，但这样做没有任何好处，反而存在重大风险。可考虑使用<u>静态成员类</u>代替这种做法。

------

### 五、泛型

泛型主要用于指定容器中元素的类型。

使用泛型时，编译器在编译时会自动强制转换类型，并判断新增的元素的类型是否正确。

这样的程序既安全、一度，但不是没有代价的，故本章主要讨论如何最大限度地利用泛型带来的收益、减少泛型带来的并发症。

#### 26、不要使用原始类型

原始类型的存在主要是为了兼容泛型诞生之前的代码。使用原始类型会丧失泛型的<u>类型安全</u>和易于阅读的优点。

#### 27、消除非受检的警告

尽可能地消除每一个未经检查的警告，但如果引发警告的代码是<u>类型安全</u>的，那么可以用`@SuppressWarnings("unchecked")`注解来抑制警告，影响范围尽可能地小，并且添加注释说明<u>类型安全</u>的原因。

#### 28、列表优于数组

数组和泛型不能很好地混合使用，而创建一个泛型数组是非法的，因为它不是<u>类型安全</u>的。

> 两者之所以不能混用是因为：
>
> - 数组是协变的（covariant），如，`Sub`是`Super`的子类，则数组`Sub[]`是数组`Super[]`的子类；而泛型是不变的（invariant），如，`Sub`是`Super`的子类，但`List<Sub>`不是`List<Super>`的子类。
> - 数组被具体化了（reified），即，数组在运行时知道并强制执行它们的元素类型；而泛型不可被具体化，通过擦除（erasure）来实现，即，泛型只在编译时执行类型约束，并在运行时丢弃/擦除它们的元素类型信息。
>
> 不可具体化的类型指的是，其运行时表示包含的信息少于其编译时表示的类型。

#### 29、优先考虑泛型

泛型比“需要在客户端代码中强制转换的类型”更安全、易用。

#### 30、优先考虑泛型方法

泛型方法要比那些需要对<u>输入参数</u>、返回值进行显式的强制转换的方法更安全、易用。

#### 31、利用限定通配符来提升API的灵活性

<u>限定通配符类型</u>有`extends`和`super`两种，两者的使用可遵循PECS原则，即，producer-extends，consumer-super。

> 也可以使用“获取和放置原则”来辅助记忆，即，Get and Put Principle。
>
> 但如果一个<u>输入参数</u>即是生产者，又是消费者，那么此时不应该使用<u>限定通配符类型</u>，而应使用精确的类型匹配。
>
> 所有`Comparable`、`Comparator`都是消费者。

不要在<u>返回类型</u>上应用<u>限定通配符类型</u>。

如果类型参数在方法声明中只出现一次，请将其替换为通配符。

- 如果它是一个无限制的类型参数，请将其替换为无限制的通配符`?`。
- 如果它是一个限定类型参数，则用限定通配符替换它。

#### 32、谨慎地结合泛型和可变参数

泛型和<u>可变参数</u>不能很好的结合，尽量别用。

#### 33、优先考虑类型安全的异构容器

集合等泛型的通常用法限制了每个容器的固定数量的<u>类型参数</u>，可以通过将<u>类型参数</u>放在Key上而不是容器上来解除此限制，即，将`Class<T>`作为Key。

> 本质上，注解元素是一个<u>类型安全</u>的异构容器，其Key为注解类型。

------

### 六、枚举和注解

#### 34、用`Enum`代替`int`常量

`int`枚举模式不满足<u>类型安全</u>，也没有任何表达能力，也无法转换为可打印的字符串。

字符串枚举模式虽然能打印，但属于硬编码模式，不能很好地处理书写错误，还可能存在性能问题。

而枚举类型（`Enum`）不存在上述问题，并且还允许添加任意方法和属性，允许实现任意接口。

> `Enum`对`Object`的所有方法进行了高质量的实现，并实现了`Comparable`和`Serializable`。
>
> `Enum`有一个静态方法`values()`，它会以声明的顺序返回一个包含所有<u>常量集</u>的数组。

> 枚举类中的静态属性的初始化发生于枚举常量创建之后，所以`Enum`的构造方法无法访问这些静态属性，枚举常量也无法从构造方法中相互访问。

“特定于常量的方法实现”存在“枚举常量之间难以共享代码”的缺点，并且往往需要使用`switch`，虽然简洁，但是难以维护。

对此，可采用一种更安全、易维护、灵活的方式：在`Enum`中新增一个<u>私有嵌套枚举</u>，将这个<u>私有嵌套枚举</u>作为策略传入该`Enum`。这种方式也称为<u>策略枚举</u>。

> <u>策略枚举</u>的缺点是不够简洁。
>
> 枚举与`switch`的搭配也不是一无是处，可用于利用常量特定的行为增加枚举类型。

> `Enum`中的<u>常量集</u>不需要一直保持不变，会随着时间推移而演化。

#### 35、用实例属性代替序数

`Enum.ordinal()`可以得到常量的序号，但这一方法主要是为了配合`EnumSet`和`EnumMap`来使用，即，永远不要从`Enum`的序号中得出与它相关的值，而是使用实例属性。

#### 36、用`EnumSet`代替位属性

`EnumSet`比直接使用<u>位域</u>来得更简介、清晰、安全，两者的性能相仿。

> `EnumSet`的缺点是他是可变的。

#### 37、用`EnumMap`代替序数索引

`EnumMap`比“使用序数来索引数组”来得更简介、清晰、安全，两者的性能相仿。

#### 38、用接口模拟可扩展的`Enum`

Java不支持编写可扩展的`Enum`，但是可以接口来模拟，即，编写一个接口，然后编写实现了该接口的`Enum`。

> “用接口模拟可扩展的`Enum`”的缺点是：一个`Enum`无法继承另一个`Enum`；并且，实现类之间往往存在重复代码，当然，如果重复代码过多，可将这些代码封装到<u>辅助类</u>或<u>静态辅助方法</u>中。

#### 39、注解优于命名模式

命名模式存在诸多缺点：难以应对拼写错误；无法确保其仅用于适当的程序元素；没有提供较好的将参数值与程序元素相关联的方法。

而注解不存在上述问题。

> 与开发框架的程序员相比，开发应用的程序员一般不需要定义注解；但无论哪种程序员，都应该使用Java提供的预定义注解。

#### 40、始终使用`Override`注解

在Java类库提供的几个注解中，`@Override`是程序员最常使用那个。

在子类中对父类的方法进行了重写的方法上使用`@Override`能避免将重写搞成重载。

#### 41、用标记接口定义类型

<u>标记接口</u>是不含方法声明的接口，如`Serializable`。

与<u>标记注解</u>相比，<u>标记接口</u>有两个优点：

1. <u>标记接口</u>定义了一个由标记类实例实现的类型，但<u>标记注解</u>没有定义这样的类型，即，<u>标记接口</u>在编译时就能捕获错误，而<u>标记注解</u>直到运行时才能捕获错误。
2. <u>标记接口</u>可以更精确地定位目标。

------

### 七、Lambda和Stream

#### 42、Lambda优于匿名类

在引入**Lambda**之前，<u>匿名类</u>是创建函数对象的主要手段。<u>匿名类</u>的主要缺点是代码冗长。

而**Lambda**的引入，令Java中的函数式编程变得异常简洁、方便。

> 与类和方法相比，**Lambda**没有名称和文档，如果代码片段不是自解释的，或者超过`3`行，则不要将其放入**Lambda**中。
>
> **Lambda**基本取代了<u>匿名类</u>，但一些功能**Lambda**实现不了，而<u>匿名类</u>能实现：<u>匿名类</u>可以用来创建抽象类的实例，可以用来创建具有多个抽象方法的接口实例；<u>匿名类</u>能够获得对自身的引用，即，能用`this`来指代对自身的引用，而**Lambda**不能，它其中`this`指向的是封闭实例。

#### 43、方法引用优于Lambda

<u>方法引用</u>通常会比**Lambda**更简洁。

但在某些**Lambda**中，其参数名提供了有用的说明，比起<u>方法引用</u>更加易读、易维护。

如果**Lambda**超过`3`行，可将代码段提取到一个新方法中，并引用该方法。

| 方法引用类型      | 示例                   | Lambda                                                 |
| ----------------- | ---------------------- | ------------------------------------------------------ |
| Static            | Integer::parseInt      | str -> Integer.parseInt(str)                           |
| Bound             | Instant.now()::isAfter | Instant then = Instant.now();<br/>t -> then.isAfter(t) |
| Unbound           | String::toLowerCase    | str -> str.toLowerCase()                               |
| Class Constructor | TreeMap<K, V>::new     | () -> new TreeMap<K, V>                                |
| Array Constructor | int[]::new             | len -> new int[len]                                    |

#### 44、优先使用标准的函数接口

Java提供了很多<u>函数接口</u>，其中有`6`个<u>基本接口</u>。

- `Operator`：其方法的结果和参数类型相同。
- `Predicate`：其方法接受一个参数并返回一个布尔值。
- `Function`：其方法其参数和返回类型不同。
- `Supplier`：其方法不接受参数，但是返回值。
- `Consumer`：其方法接受一个参数而不返回任何东西。

| 接口                | 方法                | 示例                | 说明 |
| ------------------- | ------------------- | ------------------- | ---- |
| `UnaryOperator<T>`  | T apply(T t)        | String::toLowerCase |      |
| `BinaryOperator<T>` | T apply(T t1, T t2) | BigInteger::add     |      |
| `Predicate<T>`      | boolean test(T t)   | Collection::isEmpty |      |
| `Function<T,R>`     | R apply(T t)        | Arrays::asList      |      |
| `Supplier<T>`       | T get()             | Instant::now        |      |
| `Consumer<T>`       | void accept(T t)    | System.out::println |      |

其余的<u>函数接口</u>都基于上面`6`个<u>基本接口</u>，基本接口操作的是对象。

除非真的有需要，才可编写自己的<u>函数接口</u>，否则应使用标准的<u>函数接口</u>。

#### 45、慎用`Stream`

#### 46、优先选择`Stream`中无副作用的函数

#### 47、使用`Collection`作为返回类型优于使用`Stream`

#### 48、慎用`Stream`并行

------

### 八、方法

------

### 九、通用编程

------

### 十、异常

------

### 十一、并发

------

### 十二、序列化

