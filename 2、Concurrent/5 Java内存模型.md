[深入理解Java内存模型](https://blog.csdn.net/ccit0519/article/details/11241403)

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

https://zhuanlan.zhihu.com/p/137193948



内存模型的3大特性：

1. 原子性

   1. 不会被打断。

2. 可见性

   1. 变量值更新后

3. 有序性

   1. 代码的执行顺序不会被打乱，即避免重排序问题。

JVM定义的原子操作有：

1. 基本型的赋值。

   1. JVM没有明确规定64位的long、double的赋值是否为原子操作，但在x64平台，JVM是按原子操作实现的。

3. 引用类型的赋值。



### Volatile

JVM中，变量保存在主存中，但是当线程会在自己的寄存器中对变量创建一份副本，线程修改值时只修改自己的寄存器中的变量的值，之后由JVM择机更新到主存中，而非立刻更新，而对共享变量来说，即便立即更新到主存，其他线程的寄存器中保存的值仍然为旧值，需要重新读取，总之，主存中的值与各个线程寄存器中的值很容易不一致。而这也正是可见性问题，这种不一致也叫做不可见。

x86架构回写主存的速度很快，在低负载下不容易发生可见性问题；但是ARM架构会有显著延迟，容易发生<span style=background:#c2e2ff>可见性</span>问题。

经**volatile**修饰的变量，寄存器中的值被修改后会立即更新到主存中，而且持有该变量副本的线程也会立即更新寄存器中的值。

线程间共享变量往往需要使用**volatile**关键字修饰，确保每个线程都能读取到最新的值。

**volatile**还可以保证有序性。



### [总线风暴](https://cloud.tencent.com/developer/article/1707875)

1. **高速缓冲存储器一致性**

2. 1. CPU会将主存中的数据读到自己的Cache（高速缓冲存储器，简称缓存）中，在多核处理器普及的今天，主存中的共享变量可能存在于多个核心的**缓存**中，当其中一个**核心**修改了自己**缓存**中的变量并将其更新到主存后，其它**核心**的**缓存**中的变量就与主存中的变量不一致了，即失效了。

   2. 这时我们需要一定的机制，让其他**核心**重新从主存中读取该变量到自己的缓存中，这样缓存就一致了。

   3. 1. 核心与主存交换数据时会<u>锁住总线</u>。
      2. MESI协议是通用的缓存一致性机制。

3. 经**volatile**修饰的共享变量会大概率出现缓存不一致，恢复一致的过程会<u>锁住总线</u>，**CAS**也会<u>锁住总线</u>，所以当对经**volatile**修饰的共享变量频繁进行**CAS**时，总线会被频繁锁住，或者说流量激增，如同刮起了风暴。



### Atomic

<span style=background:#b3b3b3>java.util.concurrent.atomic.*</span>，原子操作封装类。

通过CAS及while循环来实现线程安全访问。

Java 8提供LongAdder、LongAccumulator来应对多线程高度竞争的场景。