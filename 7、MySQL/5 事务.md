### 基本特征

数据库事务，是一组有序操作，这组操作具有4个基本特征（ACID）：

1、**Atomicity**，原子性。

2、**Consistency**，一致性。

3、**Isolation**，隔离性。

4、**Durability**，持久性。

#### [正确理解Consistency](https://www.zhihu.com/question/31346392/answer/362597203)

**Consistency**是指：系统从一个<u>正确的状态</u>，转换到另一个<u>正确的状态</u>。

而<u>正确的状态</u>是指：当前的状态满足预定的约束。

<u>正确的状态</u>是由应用层定义的，但无论是否定义、定义是否准确，数据库都会按照应用层的要求使用AID来执行，如：

```sql
UPDATE account SET balance = 100 WHERE id = 1 AND balance >= 100; // 正确定义约束
UPDATE account SET balance = 100 WHERE id = 1 AND balance > 100;  // 约束不准确，但数据库仍旧会执行
UPDATE account SET balance = 100 WHERE id=1; 					  // 没有定义约束，但数据库仍旧会执行
```

也就是说，AID都是数据库的特征、手段，依赖数据库的具体实现；唯独C是应用层的要求、目的，依赖于开发者使用AID来保证。



### 隔离级别与问题

| 隔离界别 / 存在问题 | Dirty Read | Non Repeatable Read | Phantom Read |
| ------------------- | ---------- | ------------------- | ------------ |
| Read Uncommitted    | Yes        | Yes                 | Yes          |
| Read Committed      | -          | Yes                 | Yes          |
| Repeatable Read     | -          | -                   | Yes          |
| Serializable        | -          | -                   | -            |



### [事务并发问题](http://c.biancheng.net/view/4220.html)

1. **Dirty Read**
   1. <span style=background:#ffb8b8>脏读</span>，指的是一个事务读取到了其他事务未提交的更改。
   2. 这时如果当其他事务回滚，该事务的数据可能与表里的就不一致，成为脏数据了。
2. **Non-Repeatable Read**
   1. <span style=background:#ffb8b8>不可重复读</span>，指的是在一个事务的多次相同读取中，读取到的结果不一致。
   2. 这是因为其他事务<span style=background:#c2e2ff>修改</span>了表里的数据，造成了该事务的多次读取的结果不一致。
3. **Phantom Read**
   1. <span style=background:#ffb8b8>幻读</span>，指的是一个事务的多次相同查询中，后面的查询结果<span style=background:#c2e2ff>出现</span> / <span style=background:#c2e2ff>消失</span>了前面未出现的结果，如同幻觉一样。
   2. 这是因为其他事务<span style=background:#c2e2ff>插入</span>、<span style=background:#c2e2ff>删除</span>、<span style=background:#c2e2ff>更新</span>了符合条件的数据。
   3. <span style=background:#ffb8b8>不可重复读</span>与<span style=background:#ffb8b8>幻读</span>的<span style=background:#d4fe7f>区别</span>在于一个是某些记录的<span style=background:#c2e2ff>内容</span>发生了变化，一个是记录的<span style=background:#c2e2ff>条数</span>发生了变化。
   4. 需要加<span style=background:#c9ccff>表锁</span>才能根除。
4. [丢失更新](https://cloud.tencent.com/developer/article/1433036)：
   1. 第一类丢失，事务回滚后，将其他已提交事务的修改进行了覆盖。
      1. 按SQL92标准实现的隔离级别都不会允许这种情况的发生。

   2. 第二类丢失，事务提交后，将其他已提交事务的修改进行了覆盖。

      1. 第二类丢失其实就是<span style=background:#ffb8b8>不可重复读</span>问题。
      2. 可通过小范围加锁、版本列法解决。



### [隔离级别](https://zhuanlan.zhihu.com/p/117476959)

SET [<span style=background:#d4fe7f>SESSION </span>| <span style=background:#d4fe7f>GLOBAL</span>] TRANSACTION ISOLATION LEVEL {<span style=background:#f8d2ff>READ UNCOMMITTED</span> | <span style=background:#f8d2ff>READ COMMITTED</span> | <span style=background:#f8d2ff>REPEATABLE READ</span> | <span style=background:#f8d2ff>SERIALIZABLE</span>}

1. **Read Uncommitted**
   1. <span style=background:#f8d2ff>读未提交</span>，不做隔离控制，属于最低的隔离级别。
2. **Read Committed**
   1. <span style=background:#f8d2ff>读已提交</span>，解决了<span style=background:#ffb8b8>脏读</span>问题，但是事务内的多次读取仍有可能不一致。
   2. 即，未能解决<span style=background:#ffb8b8>不可重复读</span>和<span style=background:#ffb8b8>幻读</span>问题。
3. **Repeatable Read**
   1. <span style=background:#f8d2ff>可重复读</span>，即事务不会读取其他事务对数据内容的修改，即便其他事务已经提交了。
   2. 但未能解决<span style=background:#ffb8b8>幻读</span>。
4. **Serializable**
   1. <span style=background:#f8d2ff>串行化</span>，事务的执行顺序变成了完全的顺序执行。
   2. 读的时候加<span style=background:#c9ccff>共享锁</span>（<span style=background:#c9ccff>表锁</span>），允许其他事务读，但是不允许其他事务写。
   3. 写的时候加<span style=background:#c9ccff>排他锁</span>（Exclusive Locks，简称X锁），不允许其他事务读写数据。

**MySQL**的**InnoDB**支持四种隔离级别，默认隔离级别为<span style=background:#f8d2ff>可重复读</span>。

**Oracle**只支持<span style=background:#f8d2ff>串行化</span>和<span style=background:#f8d2ff>读已提交</span>，默认为<span style=background:#f8d2ff>读已提交</span>。



### 关于幻读

另外**MySQL**使用<span style=background:#c9ccff>间隙锁</span>来处理<span style=background:#ffb8b8>幻读</span>，并且将<span style=background:#c9ccff>行锁</span>与<span style=background:#c9ccff>间隙锁</span>合并到了一起，即<span style=background:#c9ccff>Next-Key</span>。

所谓<span style=background:#c9ccff>间隙锁</span>是加在不符合条件的区间上的锁，其他事务想要向这些区间中插入数据，需要等待区间上的锁的释放。

锁只会在事务提交之后才释放，也就是说，其他事务需要等待加锁的事务执行完，此时可能会发生等待超时。

**MySQL**<span style=background:#ff4343>**未能**</span>完全解决幻读问题，只是大幅降低了概率。

即，没能解决在“加间隙锁前，其他事务插入了符合条件的数据”这种情况。



### 补充

**DDL**操作前都会隐式提交当前事务，所以**DML**和**DDL**混用会有一致性问题。
