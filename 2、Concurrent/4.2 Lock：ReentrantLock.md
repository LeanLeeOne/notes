[深入理解ReentrantLock](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)

​	作者：美团技术团队

​	原标题：从ReentrantLock的实现看AQS的原理及应用



### ReentrantLock

**ReentrantLock**是通过CAS+volatile实现的，没有线程的切换，是轻量级锁。

实用方法：

1. <span style=background:#b3b3b3>ReentrantLock.lock()/tryLock()/tryLock(long, TimeUnit)</span>，加锁。
2. <span style=background:#b3b3b3>ReentrantLock.unlock()</span>，解锁。
3. <span style=background:#b3b3b3>ReentrantLock.await(long)</span>，同<span style=background:#b3b3b3>Thread.sleep(long)</span>一样，会释放锁。



### Codition

**Condition**为**Lock**提供线程的等待、唤醒。

实用方法：

1. <span style=background:#b3b3b3>Condition.await()</span>，线程进入等待，<span style=background:#c9ccff>会</span>释放锁。
2. <span style=background:#b3b3b3>Condition.singal()</span>，唤醒某个线程。
3. <span style=background:#b3b3b3>Condition.singalAll()</span>，唤醒所有线程。

唤醒后的线程从返回后需要重新获取锁。



### synchronized与ReentrantLock

1. 锁的实现：

   1. **synchronized**由**JVM**实现，是语言关键字，靠系统指令实现。
   2. **ReentrantLock**是**JDK**提供的，位于java.util.concurrent包中，原理是CAS+volatile。

2. 公平锁：

   1. **synchronized**是<span style=background:#c2e2ff>非公平</span>锁，即允许<span style=background:#ff8000>抢占</span>。
   2. **ReentrantLock**默认是<span style=background:#c2e2ff>非公平</span>锁，但是可设置为<span style=background:#c2e2ff>公平</span>锁。

3. 等待可中断：

   1. **ReentrantLock**可中断。
   2. **synchronized**不行。

4. 释放：

   1. **synchronized**不用担心没有释放锁而导致死锁。
   2. 而**ReentrantLock**需要手动释放。

5. **ReentrantLock**还可绑定多个**Condition**。

   1. <span style=background:#d4fe7f>优先</span>使用**synchronized**，除非需要使用**ReentrantLock**的高级功能。

此外，两者均为<span style=background:#c2e2ff>可重入</span>锁；新版Java对**synchronized**做了很多优化，两者<span style=background:#c2e2ff>性能</span>相仿。