## 前言

# 第一部分数据系统基础

## 第1章可靠、可扩展与可维护的应用系统

### 1.1、认识数据系统

### 1.2、可靠性

#### 1.2.1、硬件故障

#### 1.2.2、软件错误

#### 1.2.3、人为失误

#### 1.2.3、可靠性的重要性

### 1.3、可扩展性

#### 1.3.1、描述负载

#### 1.3.2、描述性能

#### 1.3.3、应对负载增加的方法

### 1.4、可维护性

#### 1.4.1、可运维性：运维更轻松

#### 1.4.2、简单性：简化复杂度

#### 1.4.3、可演化性：易于改变

### 1.5、小结

## 第2章数据模型与查询语言

### 2.1、关系模型与文档模型

#### 2.1.1、NoSQL的诞生

#### 2.1.2、对象－关系不匹配

#### 2.1.3、多对一与多对多的关系

#### 2.1.4、文档数据库是否在重演历史？

2.1.4.1、网络模型
2.1.4.2、关系模型
2.1.4.3、文档数据库的比较

#### 2.1.5、关系数据库与文档数据库现状

2.1.5.1、哪种数据模型的应用代码更简单？
2.1.5.2、文档模型中的模式灵活性
2.1.5.3、查询的数据局部性
2.1.5.4、文挡数据库与关系数据库的融合

### 2.2、数据查询语言

#### 2.2.1、Web上的声明式查询

#### 2.2.2、MapReduce查询

### 2.3、图状数据模型

#### 2.3.1、属性图

#### 2.3.2、Cypher查询语言

#### 2.3.3、SQL中的图查询

#### 2.3.4、三元存储与SPARQL

2.3.4.1、语义网
2.3.4.2、RDF数据模型

#### 2.3.5、SPARQL查询语言

#### 2.3.6、Datalog基础

### 2.4、小结

## 第3章数据存储与检索

### 3.1、数据库核心：数据结构

#### 3.1.1、哈希索引

#### 3.1.2、SSTables和LSM-Tree

3.1.2.1、构建和维护SSTables
3.1.2.2、从SSTables到LSM-Tree
3.1.2.3、性能优化

#### 3.1.3、B-trees

3.1.3.1、使B-tree可靠
3.1.3.2、优化B-tree

#### 3.1.4、对比B-tree和LSM-tree

3.1.4.1、LSM-tree的优点
3.1.4.2、LSM-tree的缺点

#### 3.1.5、其他索引结构

3.1.5.1、在索引中存储值
3.1.5.2、多列索引
3.1.5.3、全文搜索和模糊索引
3.1.5.4、在内存中保存所有内容

### 3.2、事务处理与分析处理

#### 3.2.1、数据仓库

3.2.1.1、OLTP数据库和数据仓库之间的差异

#### 3.2.2、星型与雪花型分析模式

### 3.3、列式存储

#### 3.3.1、列压缩

3.3.1.1、内存带宽和矢量化处理

#### 3.3.2、列存储中的排序

3.3.2.1、几种不同的排序

#### 3.3.3、列存储的写操作

#### 3.3.4、聚合：数据立方体与物化视图

### 3.4、小结

## 第4章数据编码与演化

### 4.1、数据编码格式

#### 4.1.1、语言特定的格式

#### 4.1.2、JSON、XML与二进制变体

4.1.2.1、二进制编码

#### 4.1.3、Thrift与Protocol Buffers

4.1.3.1、字段标签和模式演化
4.1.3.2、数据类型和模式演化

#### 4.1.4、Avro

4.1.4.1、写模式与读模式
4.1.4.2、模式演化规则
4.1.4.3、那么writer模式又是什么？
4.1.4.4、动态生成的模式
4.1.4.5、代码生成和动态类型语言

#### 4.1.5、模式的优点

### 4.2、数据流模式

#### 4.2.1、基于数据库的数据流

4.2.1.1、不同的时闯写入不同的值
4.2.1.2、归档存储

#### 4.2.2、基于服务的数据流：REST和RPC

4.2.2.1、网络服务
4.2.2.2、远程过程调用（RPC）的问题
4.2.2.3、RPC的发展方向
4.2.2.4、RPC的数据编码和演化

#### 4.2.3、基于消息传递的数据流

4.2.3.1、消息代理
4.2.3.2、分布式Actor框架

# 第二部分分布式数据系统

## 第5章数据复制

### 5.1、主节点与从节点

#### 5.1.1、同步复制与异步复制

#### 5.1.2、配置新的从节点

#### 5.1.3、处理节点失效

5.1.3.1、从节点失效：追赶式恢复
5.1.3.2、主节点失效：节点切换

#### 5.1.4、复制日志的实现

5.1.4.1、基于语旬的复制
5.1.4.2、基于预写日志（WAL）传输
5.1.4.3、基于行的逻辑日志复制
5.1.4.4、基于触发器的复制

### 5.2、复制滞后问题

#### 5.2.1、读自己的写

#### 5.2.2、单调读

#### 5.2.3、前缀一致读

#### 5.2.4、复制滞后的解决方案

### 5.3、多主节点复制

#### 5.3.1、适用场景

5.3.1.1、多数据中心
5.3.1.2、离线客户端操作
5.3.1.3、协作编辑

#### 5.3.2、处理写冲突

5.3.2.1、同步与异步冲突检测
5.3.2.2、避免冲突
5.3.2.3、收敛于一致状态
5.3.2.4、自定义冲突解决逻辑
5.3.2.5、什么是冲突？

#### 5.3.3、拓扑结构

### 5.4、无主节点复制

#### 5.4.1、节点失效时写入数据库

5.4.1.1、读修复与反孀
5.4.1.2、读写quorum

#### 5.4.2、Quorum一致性的局限性

5.4.2.1、监控旧值
5.4.2.2、宽松的quorum与数据回传
5.4.2.3、多数据中心操作

#### 5.4.3、检测并发写

5.4.3.1、最后写入者获胜（丢弃并发写入）
5.4.3.2、Happens-before关系和并发
5.4.3.3、确定前后关系
5.4.3.4、合并同时写入的值
5.4.3.5、版本矢量

### 5.5、小结

## 第6章数据分区

### 6.1、数据分区与数据复制

### 6.2、键－值数据的分区

#### 6.2.1、基于关键字区间分区

#### 6.2.2、基于关键字哈希值分区

#### 6.2.3、负载倾斜与热点

### 6.3、分区与二级索引

#### 6.3.1、基于文档分区的二级索引

#### 6.3.2、基于词条的二级索引分区

### 6.4、分区再平衡

#### 6.4.1、动态再平衡的策略

6.4.1.1、为什么不用取模？
6.4.1.2、固定数量的分区
6.4.1.3、动态分区
6.4.1.4、按节点比例分区

#### 6.4.2、自动与手动再平衡操作

### 6.5、请求路由

#### 6.5.1、并行查询执行

### 6.6、小结

## 第7章事务

### 7.1、深入理解事务

#### 7.1.1、ACID的含义

7.1.1.1、原子性
7.1.1.2、一致性
7.1.1.3、隔离性
7.1.1.4、持久性

#### 7.1.2、单对象与多对象事务操作

7.1.2.1、单对象写入
7.1.2.2、多对象事务的必要性
7.1.2.2、处理错误与中止

### 7.2、弱隔离级别

#### 7.2.1、读-提交

7.2.1.1、防止脏读
7.2.1.2、防止脏写
7.2.1.3、实现读－提交

#### 7.2.2、快照级别隔离与可重复读

7.2.2.1、实现快照级别隔离
7.2.2.2、一致性快照的可见性规则
7.2.2.3、索引与快照级别隔离
7.2.2.4、可重复读与命名混淆

#### 7.2.3、防止更新丢失

7.2.3.1、原子写操作
7.2.3.2、显式加锁
7.2.3.3、自动检测更新丢失
7.2.3.4、原子比较和设置
7.2.3.5、冲突解决与复制

#### 7.2.4、写倾斜与幻读

7.2.4.1、定义写倾斜
7.2.4.2、更多写倾斜的例子
7.2.4.3、为何产生写倾斜
7.2.4.4、实体化冲突

### 7.3、串行化

#### 7.3.1、实际串行执行

7.3.1.1、采用存储过程封装事务
7.3.1.2、存储过程的优缺点
7.3.1.3、分区
7.3.1.4、串行执行小结

#### 7.3.2、两阶段加锁

7.3.2.1、实现两阶段加锁
7.3.2.2、两阶段加锁的性能
7.3.2.3、谓词锁
7.3.2.4、索引区间锁

#### 7.3.3、可串行化的快照隔离

7.3.3.1、悲观与乐观的并发控制
7.3.3.2、基于过期的条件做决定
7.3.3.3、检测是否读取了过期的MVCC对象
7.3.3.4、检测写是否影响了之前的读
7.3.3.5、可串行化快照隔离的性能

### 7.4、小结

## 第8章分布式系统的挑战

### 8.1、故障与部分失效

#### 8.1.1、云计算和超算

### 8.2、不可靠的网络

#### 8.2.1、现实中的网络故障

#### 8.2.2、检测故障

#### 8.2.3、超时与无限期的延迟

8.2.3.1、网络拥塞与排队

#### 8.2.4、同步与异步网络

8.2.4.1、网络延迟是否可预测？

### 8.3、不可靠的时钟

#### 8.3.1、单调时钟与墙上时钟

8.3.1.1、墙上时钟
8.3.1.2、单调时钟

#### 8.3.2、时钟同步与准确性

#### 8.3.3、依赖同步的时钟

8.3.3.1、时间戳与事件顺序
8.3.3.2、时钟的置信区间
8.3.3.3、全局快照的同步时钟

#### 8.3.4、进程暂停

8.3.4.1、响应时间保证
8.3.4.2、调整垃圾回收的影响

### 8.4、知识，真相与谎言

#### 8.4.1、真相由多数决定

8.4.1.1、主节点与锁
8.4.1.2、Fencing令牌

#### 8.4.2、拜占庭故障

8.4.2.1、弱的谎言形式

#### 8.4.3、理论系统模型与现实

8.4.3.1、算法的正确性
8.4.3.2、安全与活性
8.4.3.3、将系统模型映射到现实世界

### 8.5、小结

## 第9章一致性与共识

### 9.1、一致性保证

### 9.2、可线性化

#### 9.2.1、如何达到线性化？

#### 9.2.2、线性化的依赖条件

9.2.2.1、加锁与主节点选举
9.2.2.2、约束与唯一性保证
9.2.2.3、跨通道的时间依赖

#### 9.2.3、实现线性化系统

9.2.3.1、线性化与quorum

#### 9.2.4、线性化的代价

9.2.4.1、CAP理论
9.2.4.2、可线性化与网络延迟

### 9.3、顺序保证

#### 9.3.1、顺序与因果关系

9.3.1.1、因果顺序并非全序
9.3.1.2、可线性化强于因果一致性
9.3.1.3、捕获因果依赖关系

#### 9.3.2、序列号排序

9.3.2.1、非因果序列发生器
9.3.2.2、Lamport时间戳
9.3.2.3、时间戳排序依然不够

#### 9.3.3、全序关系广播

9.3.3.1、使用全序关系广播
9.3.3.2、采用全序关系广播实现线性化存储
9.3.3.3、采用线性化存储实现全序关系广播

### 9.4、分布式事务与共识

#### 9.4.1、原子提交与两阶段提交

9.4.1.1、从单节点到分布式的原子提交
9.4.1.2、两阶段提交
9.4.1.3、系统的承诺
9.4.1.4、协调者发生故障
9.4.1.5、三阶段提交

#### 9.4.2、实践中的分布式事务

9.4.2.1、Exactly-once息处理
9.4.2.2、X/A交易
9.4.2.3、停顿时仍持有锁
9.4.2.4、从协调者故障中恢复
9.4.2.5、分布式事务的限制

#### 9.4.3、支持容错的共识

9.4.3.1、共识算法与全序广播
9.4.3.2、主从复制与共识
9.4.3.3、Epoch和Quorum
9.4.3.4、共识的局限性

#### 9.4.4、成员与协调服务

9.4.4.1、节点任务分配
9.4.4.1、服务发现
9.4.4.2、成员服务

### 9.5、小结

# 第三部分派生数据

## 第10章批处理系统

### 10.1、使用UNIX工具进行批处理

#### 10.1.1、简单日志分析

10.1.1.1、命令链与自定义程序
10.1.1.2、排序与内存中聚合

#### 10.1.2、UNIX计哲学

10.1.2.1、统一接口
10.1.2.2、逻辑与布线分离
10.1.2.3、透明与测试

### 10.2、MapReduce与分布式文件系统

#### 10.2.1、MapReduce作业执行

10.2.1.1、MapReduce的分布式执行
10.2.1.2、MapReduce工作流

#### 10.2.2、Reduce端的join与分组

10.2.2.1、示例：分析用户活动事件
10.2.2.2、排序-合并join
10.2.2.3、将相关数据放在一起
10.2.2.4、分组
10.2.2.5、处理数据倾斜

#### 10.2.3、map端join操作

10.2.3.1、广播哈希join
10.2.3.2、分区哈希join
10.2.3.3、map端合并join
10.2.3.4、具有map端join的MapReduce工作流

#### 10.2.4、批处理工作流的输出

10.2.4.1、生成搜索索引
10.2.4.2、批处理输出键值
10.2.4.3、批处理输出的哲学

#### 10.2.5、对比Hadoop与分布式数据库

10.2.5.1、存储多样性
10.2.5.2、处理模型的多样性
10.2.5.3、针对频繁故障的设计

### 10.3、超越MapReduce

#### 10.3.1、中间状态实体化

10.3.1.1、数据流引擎
10.3.1.2、容错
10.3.1.3、关于实体化的讨论

#### 10.3.2、图与迭代处理

10.3.2.1、Pregel处理模型
10.3.2.2、容错
10.3.2.3、并行执行

#### 10.3.3、高级API 和语言

10.3.3.1、转向声明式查询语言
10.3.3.2、不同领域的专业化

### 10.4、小结

## 第11章流处理系统

### 11.1、发送事件流

#### 11.1.1、消息系统

11.1.1.1、生产者与消费者之间的直接消息传递
11.1.1.2、消息代理
11.1.1.3、消息代理与数据库对比
11.1.1.4、多个消费者
11.1.1.5、确认和重新传递

#### 11.1.2、分区日志

11.1.2.1、基于日志的消息存储
11.1.2.2、对比日志与传统消息系统
11.1.2.3、消费者偏移量
11.1.2.4、磁盘空间使用
11.1.2.5、当消费者跟不上生产者时
11.1.2.6、重新处理信息

### 11.2、数据库与流

#### 11.2.1、保持系统同步

#### 11.2.2、变更数据捕获

11.2.2.1、实现变更数据捕获
11.2.2.2、初始快照
11.2.2.3、日志压缩
11.2.2.4、对变更流的API支持

#### 11.2.3、事件溯源

11.2.3.1、从事件日志导出当前状态
11.2.3.2、命令和事件

#### 11.2.4、状态，流与不可变性

11.2.4.1、不变事件的优势
11.2.4.2、相同的事件日志派生多个视图
11.2.4.3、并发控制
11.2.4.4、不变性的限制

### 11.3、流处理

#### 11.3.1、流处理的适用场景

11.3.1.1、复杂事件处理
11.3.1.2、流分析
11.3.1.3、维护物化视图
11.3.1.4、在流上搜索
11.3.1.5、消息传递和RPC

#### 11.3.2、流的时间问题

11.3.2.1、事件时间与处理时间
11.3.2.2、了解什么时候准备就绪
11.3.2.3、你用谁的时钟？
11.3.2.4、窗口类型

#### 11.3.3、流式join

11.3.3.1、流和流join（窗口join)
11.3.3.2、流和表join
11.3.3.3、表和表join（物化视图维护）
11.3.3.4、join的时间依赖性

#### 11.3.4、流处理的容错

11.3.4.1、微批处理和校验点
11.3.4.2、重新审视原子提交
11.3.4.3、幂等性
11.3.4.4、故障后重建状态

### 11.4、小结

## 第12章数据系统的未来

### 12.1、数据集成

#### 12.1.1、采用派生数据来组合工具

12.1.1.1、为何需要数据流
12.1.1.2、派生数据与分布式事务
12.1.1.3、全序的局限
12.1.1.4、排序事件以捕获因果关系

#### 12.1.2、批处理和流处理集成

12.1.2.1、保持派生状态
12.1.2.2、为应用程序演化而重新处理数据
12.1.2.3、Lambda架构
12.1.2.4、统一批处理和流处理

### 12.2、分拆数据库

#### 12.2.1、编排多种数据存储技术

12.2.1.1、创建一个索引
12.2.1.2、元数据库
12.2.1.3、分离式如何工作
12.2.1.4、分离式与集成式系统
12.2.1.5、遗漏了什么？

#### 12.2.2、围绕数据流设计应用系统

12.2.2.1、应用程序代码作为派生函数
12.2.2.2、应用程序代码与状态分离
12.2.2.3、数据流： 状态变化和应用程序代码之间的相互影响
12.2.2.4、流式处理与服务

#### 12.2.3、观察派生状态

12.2.3.1、实体化视图和缓存
12.2.3.2、有状态，可离线客户端
12.2.3.3、状态更改推送至客户端
12.2.3.4、端到端的事件流
12.2.3.5、读也是事件
12.2.3.6、多分区数据处理

### 12.3、端到端的正确性

#### 12.3.1、数据库的端到端争论

12.3.1.1、Exactly-once执行操作
12.3.1.2、重复消除
12.3.1.3、操作标识符
12.3.1.4、端到端的争论
12.3.1.5、在数据系统中采用端到端的恩路

#### 12.3.2、强制约束

12.3.2.1、唯一性约束需要达成共识
12.3.2.2、基于日志的消息传递唯一性
12.3.2.3、多分区请求处理

#### 12.3.3、时效性与完整性

12.3.3.1、数据流系统的正确性
12.3.3.2、宽松的约束
12.3.3.3、无需协调的数据系统

#### 12.3.4、信任， 但要确认

12.3.4.1、软件缺陷时的完整性
12.3.4.2、不要盲目信任承诺
12.3.4.3、验证的文化
12.3.4.4、可审计性的设计
12.3.4.5、端到端论点的再讨论
12.3.4.6、审计数据系统的工具

### 12.4、做正确的事情

#### 12.4.1、预测性分析

12.4.1.1、偏见与歧视
12.4.1.2、责任与问责
12.4.1.3、反馈环路

#### 12.4.2、数据隐私与追踪

12.4.2.1、监控
12.4.2.2、赞成与选择的自由
12.4.2.3、数据隐私和使用
12.4.2.4、数据作为资产和权力
12.4.2.5、记住工业革命
12.4.2.6、立法与自律

### 12.5、小结

## 术语表