本目录摘自[豆瓣](https://book.douban.com/subject/4058874/)。

# 第一部分 背景知识

## 第1章 应重视的价值，也是对过去几年的沉重反思 2

### 1.1 总体价值 2

### 1.2 应重视的架构风格 3

1.2.1 焦点之一：模型 3
1.2.2 焦点之二：用例 3
1.2.3 如果重视模型，就可以使用领域模型模式 6
1.2.4 慎重处理数据库 9
1.2.5 领域模型与关系数据库之间的阻抗失配 13
1.2.6 谨慎处理分布式 16
1.2.7 消息传递很重要 18

### 1.3 对过程的各个组成部分的评价 19

1.3.1 预先架构设计 20
1.3.2 领域驱动设计 21
1.3.3 测试驱动开发 22
1.3.4 重构 25
1.3.5 选择一种还是选择组合 26

### 1.4 持续集成 27

1.4.1 解决方案（或至少是正确方向上的一大步） 27
1.4.2 从我的组织汲取的教训 28
1.4.3 更多信息 28

### 1.5 不要忘记运行机制 28

1.5.1 有关何时需要运行机制的一个例子 29
1.5.2 运行机制的一些例子 29
1.5.3 它不仅仅是我们的过错 30

### 1.6 小结 30

## 第2章 模式起步 32

### 2.1 模式概述 32

2.1.1 为什么要学习模式 33
2.1.2 在模式方面要注意哪些事情 34

### 2.2 设计模式 35

### 2.3 架构模式 42

2.3.1 示例：层 42
2.3.2 另一个示例：领域模型模式 43

### 2.4 针对具体应用程序类型的设计模式 43

### 2.5 领域模式 48

### 2.6 小结 52

## 第3章 TDD与重构 53

### 3.1 TDD 53

3.1.1 TDD流程 53
3.1.2 演示 54
3.1.3 设计效果 59
3.1.4 问题 61
3.1.5 下一个阶段 62

### 3.2 模拟和桩 62

3.2.1 典型单元测试 62
3.2.2 声明独立性 63
3.2.3 处理困难因素 64
3.2.4 用测试桩替换协作对象 64
3.2.5 用模拟对象替换协作对象 66
3.2.6 设计含义 68
3.2.7 结论 68
3.2.8 更多信息 68

### 3.3 重构 68

### 3.4 小结 78

# 第二部分 应用DDD

## 第4章 新的默认架构 80

### 4.1 新的默认架构的基础知识 80

4.1.1 从以数据库为中心过渡到以领域模型为中心 81
4.1.2 进一步关注DDD 81
4.1.3 根据DDD进行分层 82

### 4.2 轮廓 83

4.2.1 领域模型示例的问题/特性 83
4.2.2 逐个处理特性 84
4.2.3 到目前为止的领域模型 94

### 4.3 初次尝试将UI与领域模型挂接 95

4.3.1 基本目标 95
4.3.2 简单UI的当前焦点 95
4.3.3 为客户列出订单 95
4.3.4 添加订单 97
4.3.5 刚才我们看到了什么 98

### 4.4 另一个维度 98

4.4.1 领域模型的位置 99
4.4.2 孤立或共享的实例 99
4.4.3 有状态或无状态领域模型实例化 100
4.4.4 领域模型的完整实例化或子集实例化 100

### 4.5 小结 101

## 第5章 领域驱动设计进阶 102

### 5.1 通过简单的TDD实验来精化领域模型 102

5.1.1 从Order和OrderFactory的创建开始 103
5.1.2 一些领域逻辑 106
5.1.3 第二个任务：OrderRepository + OrderNumber 107
5.1.4 重建持久化的实体：如何从外部设置值 111
5.1.5 获取订单列表 114
5.1.6 该到讨论实体的时候了 115
5.1.7 再次回到流程上来 116
5.1.8 总览图 117
5.1.9 建立OrderRepository的伪实现 118
5.1.10 简单讨论一下保存 120
5.1.11 每个订单的总量 120
5.1.12 历史客户信息 124
5.1.13 实例的生命周期 126
5.1.14 订单类型 128
5.1.15 订单的介绍人 128

### 5.2 连贯接口 130

### 5.3 小结 131

## 第6章 准备基础架构 132

### 6.1 将POCO作为工作方式 133

6.1.1 实体和值对象的PI 133
6.1.2 是否使用PI 137
6.1.3 运行时与编译时PI 137
6.1.4 PI实体/值对象的代价 137
6.1.5 将PI用于存储库.. 139
6.1.6 单组存储库的代价 143

### 6.2 对保存场景的处理 143

### 6.3 建立伪版本机制 147

6.3.1 伪版本机制的更多特性 148
6.3.2 伪版本的实现 149
6.3.3 影响单元测试 150

### 6.4 数据库测试 153

6.4.1 在每次测试之前重置数据库 154
6.4.2 在测试运行期间保持数据库的状态 155
6.4.3 测试之前重置测试所使用的数据 156
6.4.4 不要忘记不断演变的模式 156
6.4.5 分离单元测试和数据库调用测试 156

### 6.5 查询 159

6.5.1 单组查询对象 160
6.5.2 单组查询对象的代价 161
6.5.3 将查询定位到哪里 162
6.5.4 再次将聚合作为工具 163
6.5.5 将规格用于查询 164
6.5.6 其他查询选择 165

### 6.6 小结 165

## 第7章 应用规则 166

### 7.1 规则的分类 166

### 7.2 规则的原则及用法 167

7.2.1 双向规则检查：可选的（可能的）主动检查，必需的（和自动的）被动检查 167
7.2.2 所有状态（即使是错误状态）都应该是可保存的 167
7.2.3 规则应该高效使用 167
7.2.4 规则应该是可配置的，以便添加自定义规则 167
7.2.5 规则应与状态放在一起 167
7.2.6 规则应该具有很高的可测试性 168
7.2.7 系统应阻止我们进入错的状态 168

### 7.3 开始创建API 168

7.3.1 上下文，上下文，还是上下文 169
7.3.2 数据库约束 169
7.3.3 将规则绑定到与领域有关的转换，还是绑定到与基础架构有关的转换 170
7.3.4 精化原则：所有状态，即使是错误状态，都应该是可保存的 171

### 7.4 与持久化有关的基本的规则API的需求 172

7.4.1 回到已发现的API问题上 173
7.4.2 问题是什么 173
7.4.3 我们允许了不正确的转换 174
7.4.4 如果忘记检查怎么办 174

### 7.5 关注与领域有关的规则 174

7.5.1 需要合作的规则 176
7.5.2 使用基于集合的处理方法 177
7.5.3 基于服务的验证 178
7.5.4 在不应该转换时尝试转换 179
7.5.5 业务ID 180
7.5.6 避免问题 182
7.5.7 再次将聚合作为工具 183

### 7.6 扩展API 183

7.6.1 查询用于设置UI的规则 184
7.6.2 使注入规则成为可能 184

### 7.7 对实现进行精化 184

7.7.1 一个初步实现 184
7.7.2 创建规则类，离开最不成熟的阶段 189
7.7.3 设置规则列表 191
7.7.4 使用规则列表 192
7.7.5 处理子列表 192
7.7.6 一个API改进 193
7.7.7 自定义 194
7.7.8 为使用者提供元数据 195
7.7.9 是否适合用模式来解决此问题 195
7.7.10 复杂规则又是什么情况 195

### 7.8 绑定到持久化抽象 196

7.8.1 使验证接口成为可插入的 196
7.8.2 在保存方面实现被动验证的替代解决方案 197
7.8.3 重用映射元数据 198

### 7.9 使用泛型和匿名方法 198

### 7.10 其他人都做了什么 199

### 7.11 小结 200

# 第三部分 应用PoEAA

## 第8章 用于持久化的基础架构 202

### 8.1 持久化基础架构的需求 203

### 8.2 将数据存储到哪里 204

8.2.1 RAM 204
8.2.2 文件系统 205
8.2.3 对象数据库 206
8.2.4 关系数据库 207
8.2.5 使用一个还是多个资源管理器 207
8.2.6 其他因素 207
8.2.7 选择和前进 207

### 8.3 方法 208

8.3.1 自定义手工编码 208
8.3.2 自定义代码的代码生成 209
8.3.3 元数据映射（对象关系（O/R）映射工具） 210
8.3.4 再次选择 211

### 8.4 分类 211

8.4.1 领域模型风格 211
8.4.2 映射工具风格 212
8.4.3 起点 212
8.4.4 API焦点 213
8.4.5 查询风格 213
8.4.6 高级数据库支持 214
8.4.7 其他功能 215

### 8.5 另一个分类：基础架构模式 216

8.5.1 元数据映射：元数据的类型 216
8.5.2 标识字段 217
8.5.3 外键映射 219
8.5.4 嵌入值 219
8.5.5 继承解决方案 219
8.5.6 标识映射 220
8.5.7 操作单元 220
8.5.8 延迟加载/立即加载 220
8.5.9 并发控制 221

### 8.6 小结 222

## 第9章 应用NHibernate 223

### 9.1 为什么使用NHibernate 223

### 9.2 NHibernate简介 224

9.2.1 准备 224
9.2.2 一些映射元数据 225
9.2.3 一个小的API示例 229
9.2.4 事务 231

### 9.3 持久化基础架构的需求 232

9.3.1 高级持久化透明 232
9.3.2 持久化实体的生命周期所需的特定特性 233
9.3.3 谨慎处理关系数据库 234

### 9.4 分类 235

9.4.1 领域模型风格 235
9.4.2 映射工具风格 235
9.4.3 起点 236
9.4.4 API焦点 236
9.4.5 查询语言风格 236
9.4.6 高级数据库支持 237
9.4.7 其他功能 239

### 9.5 另一种分类：基础架构模式 240

9.5.1 元数据映射：元数据类型 240
9.5.2 标识字段 240
9.5.3 外键映射 241
9.5.4 嵌入值 241
9.5.5 继承解决方案 242
9.5.6 标识映射 243
9.5.7 操作单元 244
9.5.8 延迟加载/立即加载 244
9.5.9 并发性控制 244
9.5.10 额外功能：验证挂钩 245

### 9.6 NHibernate和DDD 245

9.6.1 程序集概览 245
9.6.2 ISession和存储库 246
9.6.3 ISession、存储库和事务 246
9.6.4 得到了什么结果 247

### 9.7 小结 247

# 第四部分 下一步骤

## 第10章 博采其他设计技术 250

### 10.1 上下文为王 250

10.1.1 层和分区 250
10.1.2 分区的原因 251
10.1.3 限界上下文 252
10.1.4 限界上下文与分区有何关联 252
10.1.5 向上扩展DDD项目 252
10.1.6 为什么对领域模型——SO分区 253

### 10.2 SOA简介 253

10.2.1 什么是SOA 253
10.2.2 为什么需要SOA 253
10.2.3 SOA有什么不同 254
10.2.4 什么是服务 254
10.2.5 服务中包括什么 254
10.2.6 深入分析4条原则 255
10.2.7 再来看一下什么是服务 256
10.2.8 OO在SOA中的定位 256
10.2.9 客户—服务器和SOA 257
10.2.10 单向异步消息传递 257
10.2.11 SOA如何提高可伸缩性 258
10.2.12 SOA服务的设计 258
10.2.13 服务之间如何交互 259
10.2.14 SOA和不可用的服务 261
10.2.15 复杂的消息传递处理 262
10.2.16 服务的可伸缩性 262
10.2.17 小结 263

### 10.3 控制反转和依赖注入 263

10.3.1 任何对象都不是孤岛 263
10.3.2 工厂、注册类和服务定位器 265
10.3.3 构造方法依赖注入 267
10.3.4 setter依赖注入 269
10.3.5 控制反转 270
10.3.6 使用了Spring.NET框架的依赖注入 271
10.3.7 利用PicoContainer.NET进行自动装配 272
10.3.8 嵌套容器 273
10.3.9 服务定位器与依赖注入的比较 275
10.3.10 小结 275

### 10.4 面向方面编程 276

10.4.1 热门话题有哪些 277
10.4.2 AOP术语定义 279
10.4.3 .NET中的AOP 280
10.4.4 小结 291

### 10.5 小结 291

## 第11章 关注UI 292

### 11.1 提前结语 292

### 11.2 模型—视图—控制器模式 293

11.2.1 示例：Joe的Shoe Shop程序 294
11.2.2 通过适配器简化视图界面 299
11.2.3 将控制器从视图解耦 299
11.2.4 将视图和控制器结合起来 300
11.2.5 是否值得使用MVC 300

### 11.3 测试驱动的Web窗体 300

11.3.1 背景 301
11.3.2 一个示例 301
11.3.3 领域模型 302
11.3.4 GUI的TDD 302
11.3.5 Web窗体实现 307
11.3.6 小结 309
11.3.7 用NMock创建模拟 309

### 11.4 映射和包装 311

11.4.1 映射和包装 311
11.4.2 用表示模型来包装领域模型 312
11.4.3 将表示模型映射到领域模型 313
11.4.4 管理关系 316
11.4.5 状态问题 318
11.4.6 最后的想法 319

### 11.5 小结 320

### 11.6 结束语 320

# 第五部分 附录

## 附录A 其他领域模型风格 324

## 附录B 已讨论的模式的目录 349