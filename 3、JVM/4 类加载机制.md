### 类的生命周期

类的生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。

类加载过程包括：

1. **加载，Loading**

   加载过程包括3步：

   1. 根据全限定类名查找class文件并将二进制字节流加载到内存中；
   2. 在”**方法区/元空间**“保存该类的**元（数据）信息**；
      1. 即instanceKlass，包括静态常量池、字段、方法。（参照[文章](https://www.cnblogs.com/xy-nb/p/6773051.html)、[问题](https://www.zhihu.com/question/38496907)）
   3. 然后在**堆**中创建一个Class实例，来访问**方法区**中的方法。
      1. 即instanceOopDesc，包括对象头、元数据指针（instanceKlass的地址）、实例数据。

   另外，class文件的来源有：

   1. 本地class文件。
   2. jar、zip中的class。
   3. 从网络中加载的class。
   4. java动态生成的class（先在本地生成class）。
   5. 从数据库中加载。
   6. 由其他文件生成，如jsp文件。

2. **验证，Verification**
   1. 对文件格式、元数据、程序语义、符号引用[等内容](http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html)进行验证。

3. **准备，Preparation**

   1. 为<span style=background:#ffb8b8>静态变量</span>分配内存空间，并赋以默认值。

   2. 例如，对于<span style=background:#ffb8b8>静态变量</span><span style=background:#b3b3b3>public static int value = 123</span>，会被赋予默认值”0“；

      而对于常量<span style=background:#b3b3b3>public static **final** int value = 123</span>，则会被赋予值”123“。

4. **解析，Resolution**
   1. 将类中的符号引用替换为直接引用。
   2. 解析动作主要针对类或接口、字段、静态方法、接口方法、方法类型、方法句柄和调用点限定符等7类符号引用。
   3. **解析**可能发生在**初始化**之后，以支持Java的运行时绑定（也称动态绑定）。

5. **初始化，Initialization**

   1. 为<span style=background:#ffb8b8>静态变量</span>赋以正确的值。
   2. 只有当类被使用时，才会触发类的初始化。

类的**使用**、**卸载**：
1. **使用，Using**

   1. <span style=background:#c2e2ff>对象实例化</span>时会使用<span style=background:#c9ccff>类加载</span>后的类信息。

   2. 显然，<span style=background:#c2e2ff>对象实例化</span>不是<span style=background:#c9ccff>类加载</span>的一个阶段，<span style=background:#c2e2ff>对象实例化</span>发生于<span style=background:#c9ccff>类加载</span>之后，不要混淆。

      况且，<span style=background:#c9ccff>类加载</span>只进行一次，而<span style=background:#c2e2ff>对象实例化</span>可进行多次。

      <span style=background:#ffb8b8>静态变量</span>在<span style=background:#c9ccff>类加载</span>的**Preparation**段分配空间（在”**方法区/元空间**“中），**实例变量**在<span style=background:#c2e2ff>对象实例化</span>时分配空间（在**堆**中）。

2. **卸载，，Unloading**

   1. 略。

![image](../images/3/class-lifecycle.png)



### 类的初始化过程

类的初始化指的是类加载中的**Initialization**，即对<span style=background:#ffb8b8>静态变量</span>的初始化。

该阶段中，JVM会调用类构造器clinit()。

clinit()是由编译器自动收集类中的所有<span style=background:#ffb8b8>静态变量</span>的赋值语句和<span style=background:#f8d2ff>静态语句块</span>中的语句合并产生的。

需要注意的是，<span style=background:#f8d2ff>静态语句块</span>可以对定义在他之前的<span style=background:#ffb8b8>静态变量</span>赋值、访问，对定义在它之后的<span style=background:#ffb8b8>静态变量</span>只能赋值，不能访问。

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

更多实例可查看[文章](https://blog.csdn.net/wanghao109/article/details/49591815)。



### 类的初始化时机

以下5种情况会触发**Initialization**（**Loading**、**Verification**、**Preparation**也会随之发生）：

1. 遇到new、getstatic、putstatic、invokestatic等字节码指令，且类没有进行过初始化时。这4条指令具体对应以下场景：
   1. new，实例化对象时。
   2. getstatic/putstatic，读取/设置一个<span style=background:#ffb8b8>静态变量</span>时（<u>经**final**修饰的常量</u>除外）。
   3. invokestatic，调用**静态方法**时。

2. 对类进行反射调用，且类未进行过初始化时。
3. 初始化子类时，发现父类还未进行初始化时。
4. JVM启动时，会初始化主类（包含main()方法的类）。
5. Java7的动态语言支持时。

以上5种情况称为对一个类的<span style=background:#c2e2ff>主动引用</span>，剩下的引用方式称为<span style=background:#c2e2ff>被动引用</span>，不会触发类的**Initialization**，如：

1. 通过子类引用父类的<span style=background:#ffb8b8>静态变量</span>，不会导致子类的初始化。

   ```java
   System.out.println(SubClass.value);
   ```

2. 通过数组定义来引用类，不会触发类的初始化，但会触发对应数组类的初始化。

   ```java
   String[] array = new String[1];
   ```

3. <u>经**final**修饰的常量</u>，早就完成初始化并放入到了常量池中，本质上没有直接引用到定义常量的类，因此不会触发类的初始化。

   ```java
   System.out.println(ConstClass.HELLOWORLD);
   ```



### 类加载器

**类加载器**有4种：

1. <span style=background:#e6e6e6>Bootstrap Class Loader</span>，启动类加载器，是JVM的一部分，负责加载“<span style=background:#e6e6e6><JRE_HOME>/lib</span>”中的类。
2. <span style=background:#e6e6e6>Extension Class Loader</span>，扩展类加载器，负责加载”<span style=background:#e6e6e6><JRE_HOME>/lib/ext</span>“中的类。
3. <span style=background:#e6e6e6>Application Class Loader</span>，应用程序类加载器，负责加载<span style=background:#e6e6e6>Classpath</span>（用户类路径）下的类。
4. 自定义类加载器，需重写<span style=background:#b3b3b3>ClassLoader.findClass(String)</span>，重写<span style=background:#b3b3b3>ClassLoader.loadClass(String)</span>可打破<u>双亲委派模型</u>。

**Bootstrap Class Loader**由C++实现，其他**类加载器**继承自<span style=background:#b3b3b3>java.lang.ClassLoader</span>由Java实现。

每个**类加载器**都拥有一个独立的类<span style=background:#c2e2ff>名称空间</span>，JVM使用”**类加载器**的<span style=background:#c2e2ff>名称空间</span>“+”类的全限定名“来唯一地标识一个类，即类相等，除了类本身要相等，还必须由同一个**类加载器**加载而来。

**类加载器**加载类时，还会加载该类依赖和引用到的其他类。

**类加载器**会将加载过的类缓存下来，以后只从缓冲中加载类。这也就是“修改class文件后需要重启JVM”的原因。



### 双亲委派模型

除**Bootstrap Class Loader**外，所有的**类加载器**都有自己的父加载器，父子关系通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。

为防止重复加载类，当类加载器加载类时，会先委托父加载器去加载类，当父加载器加载不到时，才会自己加载。
