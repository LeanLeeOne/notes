**Netty**是一个非阻塞I/O服务端-客户端框架，异步事件驱动。

**Netty**的3个特点：并发高、传输快、封装好。

1. 并发高是因为采用了**NIO**模型。
   1. **BIO**，阻塞整个过程，连接数少时，延迟较低，适用于数据库连接等场景。
   2. **NIO**，阻塞业务处理，但不阻塞数据接收，也就是多路复用，适用于高并发逻辑简单的场景。
2. 传输快是因为采用了零拷贝技术。
   1. 对接收方来说，一般的网络传输，是先将数据保存到**NIO**缓冲区，然后再从socket**NIO**区复制到java程序的内存中，
   2. 而**Netty**直接开辟内存（堆、直接内存），数据直接保存到开辟的内存中，少了复制过程。
3. 封装好
   1. **Netty**其实就是对java.nio进行了封装，免去了繁琐的细节，简化了使用。。
   2. codec，是**Netty**的编码、解码器。
   3. 支持多种主流协议，http、ftp、xml、json、avro、protobuf。



### NIO

线程数少了，线程切换的效率也因此提高。

并且**NIO**的数据读写不再以字节为单位，而是字节块，提高了读取效率。

一般的**NIO**模型会设置两个线程，每个线程绑定一个轮询器（selector），其中一个负责获取新连接，另一个负责读写数据。

**Netty**默认线程数是cpu核心数的2倍，bind之后启动。

1. 阅读源码可知，**Netty**会从1、系统属性、CPU核心数*2 这三个值中取出一个最大的作为默认线程数。



### 零拷贝

内存开辟有三种模式，<span style=background:#ffb8b8>Heap Buffer</span>、<span style=background:#f8d2ff>Direct Buffer</span>和两者的结合<span style=background:#c2e2ff>Composite Buffer</span>。

1. 直接内存是调用本地方法在内存中直接开辟，不受JVM的管理，也就没有GC一说，不受高负载情况下频繁**GC**中断的影响。
2. -XXMaxDirectMemorySize=xxxM

使用<span style=background:#ffb8b8>Heap Buffer</span>，会多一步向直接内存中复制的过程，然后才将副本发送到<span style=background:#ffb8b8>Heap Buffer</span>。

并且会组合多个<span style=background:#ffb8b8>Heap Buffer</span>对象作为一个来进行操作。



### 解码器

**Netty**自带了几种解码器：

LineBasedFrameDecoder，换行符分隔。

DelimiterBasedFrameDecoder，自定义分隔符。

FixedLengthFrameDecoder，定长分割。

LengthFieldBasedFrameDecoder，自定义解码器。



压根儿就没有所谓的<span style=background:#ffee7c>粘包</span>问题。

tcp是面向流的协议，开发者没有定义好消息边界才会造成有时一下子收到多个报文的问题。

或者发送的消息内容太小，tcp会将其合并为一个报文发送。



<span style=background:#ffee7c>异步IO与Netty</span>