**Redis**中的每个键、值都基于一个名为“redisObject”的数据结构：

```c
typedef struct redisObject {
    int refcount;        // 引用计数
	unsigned type:4;     // 类型
    unsigned encoding:4; // 编码
    unsigned notused:2;  // 对齐位
    unsigned lru:22;     // LRU 时间（相对于 server.lruclock）
    void *ptr;     		 // 指向对象的值
} robj;
```

C语言没有垃圾回收机制，所以**Redis**使用<span style=background:#c2e2ff>引用计数</span>法来回收垃圾。



### 类型

<table cellspacing="0" cellpadding="0">
	<thead>
		<tr>
			<th style="width: 75px; min-width: 75px;">Type</th>
			<th style="width: 95px; min-width: 95px;">中文名</th>
			<th style="width: 315px; min-width: 315px;">简介</th>
			<th style="width: auto;">特性</th>
			<th style="width: 350px; min-width: 350px">场景</th>
		</tr>
	</thead>
	<tbody>
		<tr><td>String</td><td>字符串</td><td>二进制安全</td><td>可以包含任何数据，比如图片或者序列化的对象，<br/>一个键最大能存储512M</td><td>1、简单的缓存<br/>2、计数器</td></tr>
		<tr><td>Hash</td><td>字典</td><td>键值对集合，<br/>即编程语言中的Map类型</td><td>适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>1、存储、读取、修改用户等<span style=background:#c2e2ff>对象</span>的属性</td></tr>
		<tr><td>List</td><td>列表</td><td>链表(双向链表)</td><td>增删改，提供了操作某一段元素的API</td><td>1、最新消息<span style=background:#c2e2ff>排行</span>等功能(比如朋友圈的时间线)<br/>2、消息队列（rpop、lpush）</td></tr>
		<tr><td>Set</td><td>集合</td><td>元素不重复、有序排列</td><td>1、添加、删除，查找的复杂度都是O(1)<br/>2、为集合提供了求交集、并集、差集等操作</td><td>1、<span style=background:#c2e2ff>共同</span>好友（求交集）<br/>2、利用<span style=background:#c2e2ff>唯一性</span>，统计访问网站的所有独立IP<br/>3、好友推荐时，根据tag求交集，大于某个阈值就可以推荐</td></tr>
		<tr><td>Sorted Set</td><td>有序集合</td><td>将Set中的元素增加一个权重参数score，<br/>元素按score有序排列</td><td>数据插入集合时，已经进行天然排序</td><td>1、<span style=background:#c2e2ff>排行榜</span><br/>2、带权重的消息队列</td></tr>
	</tbody>
</table>



此外**Redis**还可作：

1. 会话缓存
   1. 使用**Redis**来统一存储多台应用服务器的会话信息。
   2. 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

2. 查找表
   1. **Redis**查找快速，还可以用来做查找表，如，存储DNS。
   2. 查找表需要可靠，所以内容不能失效；但，缓存不作为可靠的数据来源，内容可以失效。

------




### 编码

针对以上5种<u>Type</u>，[**Redis**设计](https://redisbook.readthedocs.io/en/latest/index.html)了不同的<u>Encoding</u>。

![](../images/8/redis-type-structure-mapping.svg)

------



### 简单动态字符串

Simple Dynamic String，SDS，简单动态字符串。

**Redis**中，几乎所有模块都在使用**SDS**，而非传统C字符串，其主要作用为：

1. 实现字符串对象。
2. 做<span style=background:#b3b3b3>char\*</span>的替代品
   1. <span style=background:#c2e2ff>减少</span>了字符串<span style=background:#c2e2ff>追加</span>操作产生的内存<span style=background:#c2e2ff>重分配</span>次数。
   2. <span style=background:#c2e2ff>简化</span>了字符串的<span style=background:#c2e2ff>长度</span>计算。
3. 二进制安全。
   1. 所以不止可以存储字符串，还可以存储图片、音频、视频等二进制数据。

------



### 字典

#### 用途：

1. 实现数据键空间（Key Space）。
2. 用作**Hash**类型的键的底层实现之一。

#### 数据结构

如下所示，**Redis**的**Dictionary**（<span style=background:#b3b3b3>dict</span>）包含两个散列表（<span style=background:#b3b3b3>dictht</span>），以方便扩容时的`rehash`。


```c++
typedef struct dict {       // 字典
    dictht ht[2];			// 散列表
    long rehashidx;			// rehash index
    ……
} dict;
typedef struct dictht {		// 散列表，HashTable
    dictEntry **table;		// 指针数组，俗称桶、bucket
    ……
} dictht;
typedef struct dictEntry {	// 键值对
    struct dictEntry *next; // 后继指针，拉链法
    ……
} dictEntry;
```

dictht使用<u>拉链法</u>（链地址法）解决碰撞冲突，如[下图](https://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html)所示：

![](../images/8/redis-dictionary-structure.svg)

#### 扩容

为了保证性能（节点数量与散列表的大小为<span style=background:#e6e6e6>1 : 1</span>时性能最好），每次向**Dictionary**中增加键值对时，都会对<span style=background:#b3b3b3>dict.ht[0]</span>的节点数量与散列表大小的比率（Ratio）作比较，当Ratio大于某些阈值时就会触发扩容。

扩容时，将<span style=background:#b3b3b3>dict.ht[0]</span>上的键值对逐个`rehash`到<span style=background:#b3b3b3>dict.ht[1]</span>上，而该<span style=background:#b3b3b3>dict.ht[0]</span>的<span style=background:#b3b3b3>table[rehashidx]</span>会指向`null`，<span style=background:#b3b3b3>dict.reashidx</span>会加1，`rehash`完毕后会交换这两个<span style=background:#b3b3b3>dict.ht</span>的角色。

#### 渐进式

`rehash`中键值对的移动不是一次性完成，而是渐进式的，以避免服务器压力陡增。

`rehash`开始后时，每次**Dictionary**被使用时，才会执行一次“键值对的移动”。

渐进式`rehash`会将**Dictionary**中的数据分散到两个<span style=background:#b3b3b3>dict.ht</span>中。

#### 收缩

当键值对不断减少，直到Ratio小于阈值时，会自动触发收缩**字典**。

------



### 压缩列表

```c++
area        |<------------------- entry -------------------->|
            +------------------+----------+--------+---------+
component   | pre_entry_length | encoding | length | content |
            +------------------+----------+--------+---------+
```

**Zip List**使用连续的内存来保存元素，但元素的空间长度不一，所以**Zip List**会在元素的头部存储元素<u>自身的长度</u>（<span style=background:#b3b3b3>length</span>）。

> **Zip List**没有采用任何压缩压缩算法，所以翻译为紧凑列表更恰当一些。

**Zip List**中的元素没有存放指向前后元素的<u>指针</u>，而是存储了前一个元素的<u>长度</u>（<span style=background:#b3b3b3>pre_entry_length</span>），而不同的编码（<span style=background:#b3b3b3>encoding</span>）会导致<span style=background:#b3b3b3>pre_entry_length</span>长度不同，<span style=background:#e6e6e6>1Byte</span>或<span style=background:#e6e6e6>5Byte</span>：

1. <span style=background:#e6e6e6>1Byte</span>：如果前一元素的长度小于<span style=background:#e6e6e6>254Byte</span>，<span style=background:#b3b3b3>pre_entry_length</span>便使用<span style=background:#e6e6e6>1Byte</span>来保存。
2. <span style=background:#e6e6e6>5Byte</span>：如果前一元素的长度大于等于<span style=background:#e6e6e6>254Byte</span>，那么将第<span style=background:#e6e6e6>1</span>个字节的值设为<span style=background:#e6e6e6>254</span>，然后用接下来的<span style=background:#e6e6e6>4</span>个字节保存实际长度。

> 存<u>长度</u>比存<u>指针</u>省空间，但会降低读性能，这种设计属于“时间换空间”。

结合元素的<span style=background:#b3b3b3>encoding</span>、<span style=background:#b3b3b3>length</span>、<span style=background:#b3b3b3>pre_entry_length</span>即可推算相邻元素的位置。

**Zip List**的写性能差，如，往已有的两个元素A、B间插入一个新元素C，如果A总长为<span style=background:#e6e6e6>253Byte</span>，但C总长<span style=background:#e6e6e6>254Byte</span>，那么B.pre_entry_length就会由<span style=background:#e6e6e6>1Byte</span>扩充为<span style=background:#e6e6e6>5Byte</span>，进而引起B的总长变长。

> 这种扩充是连锁，直到某个后续元素的<span style=background:#b3b3b3>pre_entry_length</span>无需变化。
>
> 当然，连锁反应发生的概率较低。

**Zip List**要比**Dictionary**、**Linked List**、**Skip List**省内存，**Redis**会优先使用**Zip List**，当满足某些条件时：

1. **Hash**才会将**Zip List**转为**Dictionary**。
2. **List**才会将**Zip List**转为**Linked List**。
3. **Sorted Set**才会将**Zip List**转为**Skip List**。

------



### 双端链表

**Redis**中的**Linked List**采用通用设计。

**Linked List**除了作为**List**的底层实现，还广泛应用于：

1. 事务模块使用**Linked List**保存输入的命令。
2. 服务器模块使用**Linked List**保存多个客户端。
3. 订阅 / 发送模块使用**Linked List**保存多个客户端。
4. 事件模块使用**Linked List**保存时间事件。

------



### [Quick List](https://zhuanlan.zhihu.com/p/102422311)

**Linked List**便于插入、删除元素，但会产生空间碎片；**Zip List**空间利用率高，但是不便于插入、删除；于是**Redis**便推出了两者的结合**Quick List**，由**Zip List**组成的**Linked List**。

**Redis3.2**后，**Zip List**被**Quick List**替代，但**Zip List**仍是**Sorted Set**底层实现之一。

![](../images/8/redis-quick-list.svg)

------



### 整数集合

当**Set**中的元素均为整数且数量不多时，会采用**Int Set**作为实现。

**Int Set**中的整数可由<span style=background:#e6e6e6>16Bit</span>升级为<span style=background:#e6e6e6>32Bit</span>、<span style=background:#e6e6e6>32Bit</span>升级为<span style=background:#e6e6e6>64Bit</span>，整数最终几位，取决于位数最大的那个整数，升级会引起整个**Int Set**的内存的重新分配。

**Int Set**使用<span style=background:#c2e2ff>二分查找</span>算法，来判断整数在集合中的位置（数组的索引）。

------



### 跳跃列表

**Skip List**基于多指针有序链表，查找数据时，从**Skip List**的上层指针开始查找，找到对应区间后再向下层指针查找。

[下图](https://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html#%E8%B7%B3%E8%B7%83%E8%A1%A8)演示了查找“22”的过程：

![](../images/8/redis-skip-lists.png)

**Skip List**查找单个Key的速度与平衡树[相仿，但**Skip List**](Redis为什么用跳表而不用平衡树？ - 张铁蕾的文章 - 知乎 https://zhuanlan.zhihu.com/p/23370124)：

1. 内存占用略少。
2. 插入、删除速度快。
   1. 因为不需要进行<span style=background:#c2e2ff>旋转</span>来维护平衡性。
3. 容易实现。
   1. 范围查找要比平衡树容易实现。

**Redis**中的**Skip List**在通用设计的基础上增加了：

1. 可重复的Score：多个不同的Member的Score可相同。
2. 对比时，要同时检查Score和Member。
3. 每个节点都带有高度为1的后退指针，用于从表尾向表头迭代。

