### 包装类型

1. Java有8种基本类型：字节、短整型、整型、长整型、单精度浮点型、双精度浮点型、布尔型、字符型（2字节的Unicode）

   1. Java在这8种基本类型之上包装了类型。
   2. Java实际上使用<span style=background:#e6e6e6>整型</span>实现的<span style=background:#e6e6e6>布尔型</span>，用<span style=background:#e6e6e6>字节数组</span>实现的<span style=background:#e6e6e6>布尔数组</span>。
   3. 字面量“1.1”是<span style=background:#e6e6e6>double</span>类型，Java不支持**向下转型**为<span style=background:#e6e6e6>float</span>。

2. 包装类型中的所有数值类型均继承自Number类。

   1. POJO中的属性尽量选择包装类型，而非基本类型；因为包装类型可以为Null，用于表示某些场景。

3. 将基本类型转换为包装类型，成为**装箱**；反之，将包装类型转为基本类型成为**拆箱**。

   1. 装箱、拆箱会影响执行效率。
   2. 装箱过程采用的<span style=background:#e6e6e6>valueOf</span>方法，拆箱才用的是<span style=background:#e6e6e6>xxxValue</span>方法。
   3. 对于Integer来说，对变量进行“赋值”会调用<span style=background:#b3b3b3>Integer.valueOf()</span>实例一个新对象，但是需要注意的是，Java标准库有缓存优化，对于区间[-128,127]内的数值会返回同一对象，这就导致了使用双等号对两个数值相同的区间内的整数进行比较时结果为真，但是对于数值较大的数返回的还是不同的实例化对象。



### 枚举类型

1. 枚举类编译后自带**final**关键字，无法被其它类**继承。**
2. 枚举类的实例无法从过new来新建，JVM会为每个枚举**自动**创建唯一实例（即**单例**），且创建过程是**线程安全**的。
3. 枚举类的自定义构造方法要加**private**，属性建议加**final**来修饰。



### BigDecimal

1. 计算机科学中的**浮点数**实际上是用**二进制**表示出来的，存在精度不足的问题，这对**数额计算**来说很致命，于是便有了BigDecimal。

   1. 如，<span style=background:#e6e6e6>(double) 0.1</span>实际上只是<span style=background:#e6e6e6>0.100000000000000055511151231257827021181583404541015625</span>的近似值

2. BigDecimal可以表示任意大小的精确小数，但是性能不如浮点数。

   1. BigDecimal使用**BigInteger**存储数值。
   2. BigDecimal使用名为**scale**的变量保存小数点位置。

3. <span style=background:#b3b3b3>BigDecimal.stripTrailingZeros()</span>用于**抹零**，包括对小数、纯整数的抹零。

   1. 对于整十整百这类以零结尾的整数，应用该方法后会变成**科学计数法**表示的数字。

      1. 如，<span style=background:#b3b3b3>new BigDecimal("123000").stripTrailingZeros()</span>的值为“1.23E+5”。

   2. 且纯整数抹零后，scale会由0变为负数（该负数绝对值的大小等于结尾零的个数）。

4. 通过<span style=background:#b3b3b3>BigDecimal.setScale()</span>可以设置精度，当设置的精度小于原精度时，就需要考虑**截取**的问题了，

   1. 截取方式包括有很多**RoundingMode.DOWN**、**RoundingMode.HALF_UP**等。
   2. 除运算中往往存在除不尽的情况，此时也需要考虑指定精度，即**截取**问题。

9. BigDecimal进行值比较时，因为存在以零结尾的情况，所以不能使用<span style=background:#b3b3b3>Object.equals()</span>，应使用<span style=background:#b3b3b3>Integer.valueOf(BigDecimal.compareTo())</span>。

6. 当涉及数额计算时，实例化BigDecimal不要使用<span style=background:#f8d2ff>BigDecimal(double val)</span>，应使用<span style=background:#ffb8b8>BigDecimal(String val)</span>或<span style=background:#ffb8b8>BigDecimal.valueOf(double val)</span>。

   1. 因为正如一开始提到的，浮点数是不精确的，<span style=background:#f8d2ff>BigDecimal(double val)</span>根据的是浮点数的[实际值](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#BigDecimal-double-)，可能与我们的期望值有出入。

12. 浮点数进行运算后可能会存在精度丢失，不宜进行等值比较，此时可用**BigDecimal**代替，如：

    ```java
    float a = 1.0f - 0.9f; // 1.00000024
    float b = 0.9f - 0.8f; // 0.099999964
    ```

