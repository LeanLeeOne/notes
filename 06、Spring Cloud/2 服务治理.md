## 角色⭐

> **Eureka**这个词源于古希腊语，意为 “我找到了！我发现了！”。据传，阿基米德在洗澡时发现浮力原理，高兴得来不及穿上裤子，跑到街上大喊：“Eureka！”

如[下图](https://blog.csdn.net/qiansg123/article/details/80127590)所示，**Eureka**将连同自己在内的所有服务都视作一个服务实例（Service Instance），这些实例分为：

1. Server：注册中心，服务治理的核心，提供服务注册、服务发现功能。
   1. 服务注册：Client向Server注册Host，并定时发送心跳，而Server维护注册的服务列表。
   2. 服务发现：通过服务名找到IP。

2. Client：注册中心之外的服务，或者说提供功能逻辑的服务。
   1. 而这些服务按照调用关系又分为：服务提供者（Provider）、服务调用者（Consumer）。

![](../images/6/eureka-roles.jpg)



## 数据结构[[1]](https://developer.aliyun.com/article/740352)🌙

**Server**的注册表分为3级：

1. <span style=background:#ffb8b8>注册表</span>

   ```java
   private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<>();
   ```

2. <span style=background:#c9ccff>一级缓存</span>

   ```java
   private final ConcurrentMap<Key, Value> readOnlyCacheMap = new ConcurrentHashMap<>();
   ```

3. <span style=background:#f8d2ff>二级缓存</span>，基于**Guava**，包含失效机制。

   ```java
   private final LoadingCache<Key, Value> readWriteCacheMap;
   ```

<span style=background:#ffb8b8>注册表</span>中只保存数据结构，缓存中保存Ready的服务信息。

### 缓存的更新

Client有注册、续约、下线、剔除、获取等行为，Server有同步行为，这些行为都会引起注册表、缓存表内容的变化。⭐

1. 删除<span style=background:#f8d2ff>二级缓存</span>：
   1. Client发送`register`、`renew`、`cancel`请求时，Server更新<span style=background:#ffb8b8>注册表</span>后会删除<span style=background:#f8d2ff>二级缓存</span>。
   2. Server自身的Evict任务剔除Client时也会删除<span style=background:#f8d2ff>二级缓存</span>。
   3. <span style=background:#f8d2ff>二级缓存</span>超时失效会自动清空。
2. 加载<span style=background:#f8d2ff>二级缓存</span>
   1. Client发送`get`请求获取服务列表时，如果<span style=background:#f8d2ff>二级缓存</span>为空，就会触发**Guava**的加载，即，获取并处理<span style=background:#ffb8b8>注册表</span>中的服务信息并放入<span style=background:#f8d2ff>二级缓存</span>。
   2. Server更新<span style=background:#c9ccff>一级缓存</span>时，如果<span style=background:#f8d2ff>二级缓存</span>为空，也会触发**Guava**的加载。
3. 更新<span style=background:#c9ccff>一级缓存</span>
   1. Server内置的定时任务会定期将<span style=background:#f8d2ff>二级缓存</span>同步到<span style=background:#c9ccff>一级缓存</span>中，包括delete、update。

### 服务行为[[2]](https://developer.aliyun.com/article/740352?accounttraceid=a86103375a534931a28af14f461ab194teoe)

1. `register`
   1. Server收到该请求后会将Client保存到<span style=background:#ffb8b8>注册表</span>中。
   2. Server会将该请求封装为事件放入更新队列，增量发送给其它Client。
   3. 清空<span style=background:#f8d2ff>二级缓存</span>，保证数据一致性。
   4. 更新阈值，并将信息同步给其它Server。
2. `renew`
   1. Client会定期发送该请求（心跳）以续约。
   2. Server收到请求后会更新对应Client的到期时间，并将信息同步给其它Server。
3. `cancel`
   1. Server收到该请求后会将Client从<span style=background:#ffb8b8>注册表</span>中删除。
   2. 之后的行为与收到`register`请求一致。
4. Eviction
   1. 将不能正常`cancel`的Client剔除。
   2. 剔除过程分为3步：判断剔除条件、找出过期服务、剔除过期服务。
5. Fetch Registries
   1. Client会定期向Server请求服务列表。
6. 服务同步
   1. 即Server之间的同步，分为启动时同步和运行时同步。



## 网络划分

**Eureka**将网络划分为**Region**、Zone。

**Region**、**Zone**的概念均来自AWS，而在非AWS环境下，**Zone**可以简单地理解为机房，**Region**为跨机房的网络。

![](../images/6/eureka-region-zone.jpg)



## 自我保护模式

当Server在短时间内丢失过多的心跳时（比如发生了网络分区故障），那么这个Server就会进入<u>自我保护模式</u>。

在<u>自我保护模式</u>中，Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数重新恢复到阈值以上时，该Server就会自动退出自我保护模式。

该模式可以通过`eureka.server.enable-self-preservation = false`来禁用。

> 将异常下线客户端最大感知时间设置为`20s`：
>
> - `eureka.instance.lease-renewal-interval-in-seconds` + `eureka.instance.lease-expiration-duration-in-seconds` + `eureka.server.eviction-interval-timer-in-ms`
> - = `5s` + `10s` + `5s` = `20s`

### 设计哲学⭐

它的设计哲学前面提到过，那就是**<u>宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例</u>**。

这样做会使Client很容易拿到实际已经不存在的服务实例，进而出现调用失败的情况，因此Client要有容错机制，比如请求重试、断路器。



## 与其它注册中心比较⭐

注册中心的主要功能是：提供服务注册、服务发现功能，但不同的注册中心会对CAP有不同的侧重。

### Zookeeper

CP

### Consul

CP

### Nacos

AP或CP



