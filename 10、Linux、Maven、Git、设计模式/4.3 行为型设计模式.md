行为型设计模式设计算法和对象间职责的分配，通过组合来使一组对象协同完成整个任务，主要有：

### Chain of Responsibility，责任链

由多个处理器组成一个调用链来处理请求，链中的每个处理器都可以<u>根据自身定义的条件决定</u>是否处理、是否传递该请求，这种请求处理模式就是责任链模式。

> “<u>根据自身定义的条件决定</u>”换句话说就是自己责任内。

该模式可以避免请求发送者和接收者的耦合。<span style=background:#ffee7c>（不一定吧）</span>

处理器在链中的顺序有时很重要。

> **Servlet**的`Filter`、**Spring MVC**的`Interceptor`采用的都是责任链模式。

### Command，命令

将请求封装成对象，这样，执行请求也就转变成了执行对应对象的处理方法，而这些封装成对象我们称为命令，之后我们可以通过将这些命令入栈，进而实现命令的重做（`redo`）、撤销（`undo`）。

使用该模式会提升系统的复杂度，但是能降低系统的耦合度，也正因此，如果请求对应的都是简单操作，我们无需将这些请求封装成命令，即，无需采用该模式。

> **Hystrix**就采用了该模式。

### Interpreter，解释器

我们先设定一种语言，将符合该语言的语句解释成执行代码的程序就是解释器，此时用户仅需提供执行语句，无需关心背后实现。

> 正则表达式就是这样一种模式，我们仅需提供正则语句（表达式），之后解释器会将语句转换成代码执行。
>
> 数据库采用的也是这样一种模式，我们仅需提供查询语句，之后解释器会将SQL转换成真正的查询程序。

### Iterator，迭代器

一个聚合对象内部有一组元素，我们不直接访问这些元素，而是将遍历工作委托给一个对象，而这个对象就是迭代器。

> 迭代器模式广泛应用于Java、C++的容器类遍历。

### Mediator，中介

系统中有一组组件相互调用、彼此交错，我们新引入一个对象，将之前组件间的相互调用改为只与这个新对象交互，而这个新对象就是中介。

中介模式能降低系统组件间的耦合度，常用于UI组件的设计。

### Memento，备忘录（纪念品）

纪念品模式是一种，在不破坏对象封装的前提下，获取该对象当前的内部状态，并在对象外部保存该状态的模式，之后在需要的时候，我们将可以将该对象恢复到该状态。

纪念品模式主要有3个角色：
1. Memento，保存对象状态。
2. Originator，用于创建Memento。
3. Caretaker，用于保存Memento。

该模式常用于办公软件的保存文档状态功能的设计。

### Observer，观察者

当一个对象的状态发生变化时，依赖它的所有对象都会得到通知，并更新自身，这个对象就是观察者。

该模式又称为Subscribe-Publish，即，订阅/发布模式。

### State，状态

对象改变内部状态时，其行为也随之变化，即，不同的状态对应不同的行为。

该模式用于将不同的状态分离到不同的状态类中，以方便状态的扩展。

状态模式的关键在于状态的切换：
1. 对于简单场景，可以由调用方直接切换。
2. 对于复杂场景，可由触发相应条件来完成状态的切换。

### Strategy，策略

我们一组算法封装成一个个的策略，并将执行一个个的算法改为执行一个个的策略。

策略模式适用于，总体流程确定，但是某一环节中的执行过程不确定的场景，该模式便于系统的扩展，

> 策略模式广泛应用于Java标准库中，比如数组排序`Array.sort(array, String::compareToIgnoreCase)`。
>
> 购物车针对不同客户在结算时采用不同减免方式的情景就很适合策略模式。

### Template Method，模板方法

对于一组总体流程确定的操作，我们将其抽象为**模板**，同时并将不确定的部分抽象为相应**方法**，继承模板的子类会实现这些方法，也就是填充模板中不确定的部分。

> **Spring**就提供了大量的模板。

### Vistor，访问者

对于一组操作，我们将其确定部分封装一个对象，对于其不确定的部分，我们将其封装为抽象对象，通过向确定对象中传入抽象对象的实现，并回调实现对象的方法来完成操作，其中传入的对象就是访问者。

对于新需求我们只需新增访问者，而无需改变固定对象。

> 该模式常用于遍历文件、目录，或者遍历XML中的节点。

