## 基于时间设计Index

##### 按照时间设计Index有以下2个优点：

1. 一旦**Index**创建后，<u>**Shard**的数量</u>就无法变更。虽然<u>**Shard**的数量</u>不可变，但是我们可以按照<span style=background:#c2e2ff>时间段</span>来创建**Index**，如按小时创建、按天创建、按月创建，这样能将控制<u>**Shard**的数量</u>转换为控制<u>**Index**的数量</u>，来提高<span style=background:#d4fe7f>灵活性</span>。
2. 同时，对某些应用来说，数据的搜索会集中在最近一段时间上，按时间切分，我们就可以只扫描近期的数据，从而减少不必要的扫描，<u>提升效率</u>。

当然并不是所有应用的**Index**都要按照时间来切分，比如数据增长缓慢的应用，就没必要按时间切分**Index**，切分后反而会减少分片中的数据量，使得降低得分的精度、降低查询速度（降低速度是因为**Shard**过多，线程过多）。

##### 确定切分的时间间隔的依据：

1. 在按时间粒度切分时要保证分段的<span style=background:#d4fe7f>均匀</span>，这对随时间变化均匀、能够预测的数据来说时容易做到的。
2. 而对于难以按时间预测的数据增长，**Elasticsearch**也提供了”Rollover and Shrink API“来按照体积自动合并、创建**Index**。

##### 实现Index的切分：

1. 基于时间设计**Index**，就要求我们能自动创建**Index**，而**Elasticsearch**提供了<span style=background:#c2e2ff>Index Template</span>，简化了我们创建**Index**的工作。



## Mapping的设计技巧

**Mapping**设计的好，能够<u>节省空间</u>、<u>提升性能</u>。

而**Mapping**的设计主要考虑3个方面：

1. 尽量使用结构化的数据：虽然**Elasticsearch**支持半结构化的数据，但是前文也提到了，半结构化的数据水太深，开发者把握不住。

2. **Mapping**尽量扁平，因为**Elasticsearch**中没有`JOIN`。

3. 对于需要精确匹配的字段，不应设置分词，即<span style=background:#e6e6e6>type=keyword</span>。


此外，还有一些常用参数：

1. <span style=background:#e6e6e6>_all</span>

   1. <span style=background:#e6e6e6>\_all</span>是一个经过分析的字段，如果我们不清楚关键字在哪个字段中，可以开启这个<span style=background:#e6e6e6>\_all</span>字段，开启后**Elasticsearch**会结合所有字段建立一个新的**Index**，但是开启后会占用更多的磁盘，降低性能。
   2. <span style=background:#e6e6e6>\_all</span>常用于应用初期，之后随应用的发展，搜索需求会越来越精确，也就不再需要<span style=background:#e6e6e6>\_all</span>，此时会使用<span style=background:#e6e6e6>include_in_all</span>的选项。
   3. **_all**也可以指定分析器。

2. <span style=background:#e6e6e6>_source</span>

   1. 大部分场景都有搜索原文的需要，需要开启此字段。
   2. 如果不开启，那么**Elasticsearch**只会保存**Document**的ID，能节省空间，提升节省查询时间。

3. <span style=background:#e6e6e6>dynamic mapping</span>

   动态映射，用于控制未定义字段的插入，可配置在根字段及其他字段上，且有3个值：

   1. strict，禁止插入，会报错，这个值常用，毕竟没人喜欢脏数据。
   2. true，允许插入未定义的字段。
   3. false，忽略未定义的字段。

4. <span style=background:#e6e6e6>ignore_malformed</span>

   1. 可以用来忽略IP等类型的字段。



## 别名

借助别名，我们可以将按时间切分的索引重新聚合起来，同时，借助别名，我们可以实现将基于时间冷热数据分离。



## 分片分配原则

**Shard**的分配原则是指”Primary Shard“的个数，主要考虑4点：

1. 单片**Shard**的大小不宜超过<span style=background:#e6e6e6>30GB</span>，过大的**Shard**会导致进行<span style=background:#c2e2ff>Relocate</span>时，机器负载过高，进而影响系统的稳定性。
2. <u>**Shard**的数量</u>要基于”Data Node“的数量。



## 整体思路

<span style=background:#ffee7c>待补充……</span>



## 关于热点问题

**Elasticsearch**能很好地应对读操作的<span style=background:#ffb8b8>热点问题</span>，因为**Elasticsearch**是一个以读（检索）为主的系统，<span style=background:#ffb8b8>热点数据</span>往往在内存中都会有缓存，会很快的返回给客户端，读操作一般不会成为系统瓶颈，如果成为瓶颈，我们可以采用增加节点，以及横切竖切（只加载热点数据行、精简字段）的方式应对。

关于写操作的<span style=background:#ffb8b8>热点问题</span>，因为写入发生在硬盘，<u>写硬盘</u>显然要比<u>读内存</u>漫长地多，容易成为系统瓶颈，可增加**Node**分散压力，用空间换时间。