## 简述

**Doris**是一个基于MPP架构的高性能、实时的分析型数据库，能提供毫秒级的大数据查询，不仅支持高并发的点查询场景，也支持高吞吐的复杂分析场景。

> **Doris**由百度于2017年开源，2018年捐赠给Apache，2022年成为Apache的顶级项目。
>
> **Doris**采用**MySQL**协议，支持标准SQL，高度兼容**MySQL**语法。



## 数据模型[[1]](https://doris.apache.org/zh-CN/docs/dev/data-table/data-model)

**Doris**将字段分为Key和Value两种，Key、Value分别对应[维度和指标](../09、Lucene/6.2 数据仓库#维度与指标)，均可由多个字段组成。Key用于快速查找（全局有序）、聚合。

**Doris**的数据模型源自Google Mesa，分为`3`种：

- Aggregate：会自动地按Key对数据进行聚合，这种预聚合能大幅提升读性能。
- Unique：Key唯一，相同Key的数据会被覆盖，但不会聚合，适用于行级更新。
- Duplicate：原样存储，既不根据Key进行覆盖，更不会根据Key进行聚合，适用于事实表的明细存储。

> 建表语句中：
>
> - 用`UNIQUE KEY`、`AGGREGATE KEY`或`DUPLICATE KEY`关键字标识的字段是Key，其余字段为Value。
> - Key字段必须定义在Value字段之前。

### Aggregate模型

Aggregate模型提供`4`种聚合方式：`SUM`、`MIN`、`MAX`和`REPLACE`。

### Unique模型

Unique模型，在1.2版本之前，是Aggregate模型的一个特例，由于Aggregate模型的实现方式是读时合并（Merge On Read，MOR），因此在一些聚合查询上性能表现不佳，所以**Doris**在1.2版本后，为Unique模型引入新的实现方式—写时合并（Merge On Write，MOW）—来优化查询性能。

> MOR目前仍是Unique模型的默认实现方式。
>
> Unique模型仅支持整行更新。

### Duplicate模型

严格来说，Duplicate模型会按Key进行排序，不是原样存储。

> Duplicate模型的Key，称为Sorted Column更贴切，官方建议选择前`2~4列`作为Key。



## 数据划分[[2]](https://doris.apache.org/zh-CN/docs/dev/data-table/data-partition/)

### 分区

**Doris**支持分区，提供Range和List两种划分方式。

> List是由枚举值构成的列表。
>
> **Doris**支持动态分区。

若建表时不配置Partition，**Doris**会自动生成一个与表名同名的、全值范围的、对用户透明（不可删除）的Partition。

分区字段可以指定一到多个，但必须为Key。

### 分桶

**Doris**支持分桶（Bucket），桶文件也被称为Tablet，提供Hash和Random两种划分方式。

分桶字段可以指定一到多个，分桶字段：

- 对于Aggregate模型和Unique模型，必须为Key。
- 对于Duplicate模型，可以是Key和Value。

> 分区字段和分桶字段没有直接联系，不必相同。
>
> 添加Partition时，可以为该Partition单独指定Bucket的数量，但Partition的Bucket数量一旦指定，不可更改。所以在确定Bucket数量时，需要预先考虑集群扩容的情况。
>
> 如果选择多个分桶分桶，则数据分布更均匀，但如果一个查询条件不包含所有分桶列的等值条件，那么该查询会退化为扫描所有分桶，增加IO，甚至影响其他查询。

#### 大小和数量

Tablet过小，则聚合效果不佳，且元数据管理压力大；Tablet过大，则不利于副本的迁移、补齐，且会增加Schema Change或者Rollup操作失败重试的代价（这些操作失败重试的粒度是Tablet）。

当Tablet的大小和数量冲突时，优先考虑大小原则。

#### Random Distribution

除了Hash划分，Bucket其实还支持Random划分。因为没有分桶字段，所以也就无法限定分桶范围，也就是会扫描分区内的全部分桶。

在导入数据时，可同时设置但分片导入和Random划分，这样单次导入作业每个批次的数据，将随机选择一个Tablet进行写入。

- 但如果OLAP表是只读的，则Random划分可以避免严重的数据倾斜。
- 在大数据量的导入时，一个作业将数据写入对应的分区时将只写入一个分片，从而缓解数据导入和Compaction导致的写放大问题，进而提高数据导入的并发度和吞吐量，以及集群的稳定性。

Random划分适合对整个分区的聚合查询分析，不适合高并发的点查询。



## 索引

**Doris**不支持在任意字段上创建索引。

前缀索引，是在对Key排序的基础上，实现的一种根据给定前缀列，快速查询数据的索引方式。

**Doris**取Key字段的前`36Byte`作为这前缀索引，但遇到`VARCHAR`类型的字段时，前缀索引会直接截断。



## 查询引擎

<img src="../images/9/doris_framework.png" style="zoom: 40%;" />

如[上图](https://doris.apache.org/zh-CN/docs/dev/summary/basic-summary/)所示，**Doris**的进程仅分为`2`类，不依赖**Hadoop**等外部组件，两类进程均支持横向扩展：

- 管理节点，<span style=background:#ffb8b8>Frontend</span>，主要负责用户请求的接入、生成<u>执行计划</u>、元数据的管理、节点管理相关工作。
  - 对于元数据的管理，<span style=background:#ffb8b8>Frontend</span>采用了类似于**ZooKeeper**的设计，将节点分为Leader、Follower和Observer等三种角色。至少部署`3`个Follower，才能实现元数据的读写高可用。

- 工作节点，<span style=background:#f8d2ff>Backend</span>，主要负责执行计算、存储数据。
  - 从节点又分为Coordinator和Worker。

两类进程通过一致性协议来保证服务的高可用和数据的高可靠。

**Doris**的查询引擎[源自](https://www.infoq.cn/article/vxup94ub59ya*k0tnefe)**Impala**。

- **Impala**采用多主模式，每个节点都缓存元数据，而这可能会面临元数据落后/不一致的问题。
- **Doris**采用主从模式，将元数据的管理放到主节点中，从而避免了元数据的不一致。

除了采用了与**Impala**不同的主从模式，**Doris**还将**Statestored**、**Catalogd**的功能也整合进了<span style=background:#ffb8b8>Frontend</span>中，从而实现了不依赖**Hadoop**等外部组件，部署、扩展更加简便。

**Impala**由**Hive**的Metastore保证数据的一致性，由**HDFS**保证数据的可靠性；而**Doris**自行实现：采用**Paxos**协议来保证一致性，采用Memory + Checkpoint + Journal的机制来确保元数据的高性能及高可靠。

**Doris**查询引擎的所有的内存结构能够按照列式布局，是向量化的。

> 对于行式布局，每一次对行的函数调用，都会：打断CPU流水，不利于分支预测；指令和数据Cache Miss高；编译器不友好，不利于循环展开，不利于使用SIMD等CPU加速指令。
> 但对于列存布局，能采用向量化执行，从而大幅减少虚函数调用、提升Cache命中率、高效利用SIMD指令、提升CPU利用率。
> 在宽表聚合场景下，向量化引擎的性能是非向量化引擎的`5`~`10`倍。

**Doris**采用了Adaptive Query Execution技术， 可根据Runtime Statistics来动态调整执行计划。

**Doris**使用CBO和RBO结合的优化策略。

> RBO，Rule Based Optimizer，支持常量折叠、子查询改写、谓词下推、列裁剪、分区分桶裁剪、等价谓词推导、公共表达式复用等。
> CBO，Cost Based Optimizer，支持Join Re-Order。CBO还在优化中，通过更加精准的统计信息收集和推导，提供更加精准的代价模型预估。



## 存储

Doris的计算和存储是耦合的，而分离的两者更适应云服务。

### 列式存储

**Doris**采用列式存储（ORCFile），支持按列进行压缩，有效节省了IO、CPU。

除了压缩，**Doris**还会对数据排序，并在此基础上，按一定的粒度（一千行、一万行、十万行）创建稀疏索引，而多数分析型数据库只会直接创建稀疏索引。有序的数据，对于`min()`、`max()`、`sum()`等聚合操作，能有效缩小查询范围，提升读性能。

### 物化视图

**Doris**支持强一致、自动更新的物化视图。

查询时，用户仅需指定原始表，**Doris**会将根据查询条件自动选择使用原始表或合适的物化视图。

### 导入

**Doris**的数据导入是原子性的。

#### Compaction

合并

##### Aggregate模型

在导入数据时，Aggregate模型会进行分级合并，即，把小文件合并成中文件，再把中文件合并成大文件，而没有采用大文件直接跟小文件合并的方式，因为后者存在更严重的读写放大。

在Aggregate模型中，数据聚合发生在`3`个阶段：

1. 每一批次数据导入的ETL阶段，都会对同一批次内的数据进行聚合。
2. <span style=background:#f8d2ff>Backend</span>进行Compaction时，会对已导入的不同批次的数据进行进一步的聚合。
3. 数据查询阶段，对于涉及到的数据，会进行对应的聚合。

数据的聚合程度，在不同时间可能不一致，但这对用户而言是透明的，因为**Doris**会在查询过程中自动加入聚合算子，来提供最终的聚合结果，即，保证对外展示的一致性。

> 但这种一致性保证，会在语义和性能方面存在[局限性](https://doris.apache.org/zh-CN/docs/dev/data-table/data-model#聚合模型的局限性)：
>
> - 在Aggregate模型的聚合列（Value）上，执行与聚合类型不一致的聚合类查询时，要注意语义。
> - 在某些查询中，这种一致性保证会极大的降低查询效率，例如`count(*)`查询时，**Doris**必须扫描所有的Key字段，并且经过聚合，才能得到正确的语义。对于频繁的`count(*)`查询，官方建议通过增加一个聚合类型为`SUM`/`REPLACE`、值恒为`1`的字段来模拟`count(*)`。

对于`REPLACE`这种聚合方式：

- 对于同一个导入批次中的数据，替换顺序不做保证。
- 对于不同导入批次中的数据，替换顺序可以保证，即，后一批次的数据会替换前一批次的。

##### Unique模型

Unique模型的MOW，在导入阶段就会将被覆盖/更新的数据标记为删除，这样在查询时，所有被标记删除的数据都会在文件级别被过滤掉，即，消除掉了MOR中的数据聚合过程、读取出来的数据都是最新的，并且能够在多种情况下（尤其是聚合查询）支持多种谓词的下推，大幅提升查询性能。

#### ENGINE

本示例中，ENGINE 的类型是 olap，即默认的 ENGINE 类型。在 Doris 中，只有这个 ENGINE 类型是由 Doris 负责数据管理和存储的。其他 ENGINE 类型，如 mysql、broker、es 等等，本质上只是对外部其他数据库或系统中的表的映射，以保证 Doris 可以读取这些数据。而 Doris 本身并不创建、管理和存储任何非 olap ENGINE 类型的表和数据。

### 冷热分离

**Doris**能自动识别冷热数据，减少不必要的重复BE/CE，节省IO、CPU。**Doris**能识别存储介质的类型（HDD或SSD），结合自动识别冷热数据，能在分区粒度上，自动进行冷热数据的迁移。

