## 简介

Effective Java，编写高效的Java代码，其中的"高效"包含两个方面：高维护性、高性能。

- 高维护性又包括3方面：
  - 易读：便于
  - 安全
  - 容易扩展
  - 不易出错
- 高性能指的是运行速度快、空间占用少。

高维护性和高性能这两个追求一般不会产生冲突，但如果产生冲突，作者认为，可维护性比性能更重要，<span style=background:#ffee7c>因为</span>



## 主要章节介绍

第1章为引言。

第2章阐述何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清除动作。

第3章阐述对于所有对象都通用的方法，你会从中获知对equals、hashCode、toString、clone、finalize以及Comparable.compareTo方法相当深入的分析，从而避免今后在这些问题上再次犯错。

第4章阐述作为Java程序设计语言的核心以及Java语言的基本抽象单元（类和接口）在使用上的一些指导原则，帮助你更好地利用这些元素，设计出更加有用、健壮和灵活的类与接口。

第5章和第6章分别阐述在Java 1.5发行版本中新增加的泛型（Generic）以及枚举（Enum）和注解（Annotation）的最佳实践，教你如何最大限度地享有这些优势，并使整个过程尽可能地简单化。

第7章专门讨论在Java 8中新增的函数接口（Functional Interface）、Lambda表达式和方法引用（Method Reference），使创建函数对象（Function Object）变得更加容易。接着探讨为处理数据元素的序列提供了类库级别支持的Stream API，以及如何最佳的利用这些机制。

第8章讨论方法设计的几个方面：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档，从而使方法设计在可用性、健壮性和灵活性上有进一步的提升。

第9章主要讨论Java语言的具体细节，讨论了局部变量的处理、控制结构、类库的使用、各种数据类型的用法，以及两种不是有语言本身提供的机制（Reflection和Native Method，反射机制和本地方法）的用法，并讨论了优化和命名惯例。

第10章阐述如何充分发挥异常的优点来提高程序的可读性、可靠性和可维护性，以及减少异常使用不当所带来的负面影响，并提供一些关于有效使用异常的指导原则。

第11章阐述如何帮助你编写出清晰、正确、文档组织良好的并发程序，比如如何避免过度同步，优先采用Executor Framework、并发集合（Concurrent Collection）、同步器（Synchronizer），记忆是否需要依赖于线程调度器等。

第12章阐述序列化方面的技术，并且有一项值得特别提及的特性，就是序列化代理（Serializable Proxy）模式，它可以帮助你避免对象序列化的许多缺陷。

> 官方中文版的翻译水平与网友的评价一致——蹩脚，故本文主要参考[开源版本](https://github.com/sjsdfg/effective-java-3rd-chinese/tree/v1.4/docs/notes)。
>
> 但是该*开源版本*存在很多笔误，而且翻译水平仍没完全实现“信达雅”。



## 目录

### 一、引言

### 二、创建和销毁对象

1、静态工厂方法优于构造方法

2、当构造方法参数过多时使用`Builder`模式

3、使用私有构造方法或枚举类实现`Singleton`属性

4、使用私有构造器方法执行非实例化

5、依赖注入优于引用资源

6、避免创建不必要的对象

7、消除过期的对象引用

8、避免使用`Finalizer`和`Cleaner`

9、`try-with-resources`优于`try-finally`

### 三、对于所有对象都通用的方法

10、重写`equals`时遵守通用约定

11、重写`equals`时同时也要重写`hashCode`

12、始终要重写`toString`

13、谨慎地重写`clone`

14、考虑实现`Comparable`接口

### 四、类和接口

15、使类和成员的可访问性最小化

16、在公共类而非公共属性中使用访问方法

17、使可变性最小化

18、组合优于继承

19、要么设计继承并提供文档说明，要么禁止用继承

20、接口优于抽象类

21、为后代设计接口

22、接口只用于定义类型

23、类层次结构优于标签类

24、静态成员类优于非静态成员类

25、将源文件限制为单个顶级类

### 五、泛型

26、不要使用原始类型

27、消除非受检的警告

28、列表优于数组

29、优先考虑泛型

30、优先考虑泛型方法

31、利用限定通配符来提升API的灵活性

32、谨慎地结合泛型和可变参数

33、优先考虑类型安全的异构容器

### 六、枚举和注解

34、用`Enum`代替`int`常量

35、用实例属性代替序数

36、用`EnumSet`代替位属性

37、用`EnumMap`代替序数索引

38、用接口模拟可扩展的`Enum`

39、注解优于命名模式

40、始终使用`Override`注解

41、用标记接口定义类型

### 七、Lambda和Stream

42、`Lambda`优于匿名类

43、方法引用优于`Lambda`

44、优先使用标准的函数接口

45、慎用`Stream`

46、优先选择`Stream`中无副作用的函数

47、使用`Collection`作为返回类型优于使用`Stream`

48、慎用`Stream`并行

### 八、方法

49、检查参数的有效性

50、必要时进行保护性拷贝

51、谨慎设计方法签名

52、慎用重载

53、慎用可变参数

54、返回空数组或者空集合，而非`null`

55、谨慎地返回`Optional`

56、为所有已公开的API元素编写文档注释

### 九、通用编程

57、使局部变量的作用域最小化

58、`for-each`循环优于传统的`for`循环

59、了解并使用类库

60、如需精确答案，应避免使用`float`和`double`

61、基本类型优于包装类型

62、若其他类型更合适，则尽量避免使用字符串

63、了解字符串连接的性能

64、通过接口引用对象

65、接口优于反射

66、谨用本地方法

67、谨慎地进行优化

68、遵守普遍接受的命名惯例

### 十、异常

69、只针对异常的情况才使用异常

70、对可恢复的情况使用受检异常，对编程错误使用运行时异常

71、避免不必要地使用受检异常

72、优先使用标准的异常

73、抛出与抽象对应的异常

74、每个方法抛出的所有异常都要建立文档

75、在细节消息中包含失败-捕获信息

76、努力使失败保持原子性

77、不要忽略异常

### 十一、并发

78、同步访问共享的可变数据

79、避免过度同步

80、`executor`、`task`和`stream`优于线程

81、并发工具优于`wait`和`notify`

82、线程安全性的文档化

83、慎用延迟初始化

84、不要依赖线程调度器

### 十二、序列化

85、其他方法优于Java序列化

86、谨慎地实现`Serializable`接口

87、考虑使用自定义的序列化形式

88、保护性地编写`readObject`方法

89、对于实例控制，枚举类型优于`readResolve`

90、考虑用序列化代理代替序列化实例



## 摘要

### 一、引言

无

### 二、创建和销毁对象

#### 1、静态工厂方法优于构造方法

> <u>静态工厂方法</u>与设计模式中的<u>工厂方法模式</u>不同，即，本条目中描述的<u>静态工厂方法</u>在设计模式中没有直接的等价。

提供<u>静态工厂方法</u>而不是<u>构造方法</u>有优点也有缺点。

- 优点
  - <u>静态工厂方法</u>有名字，易读、不必纠结方法签名。
  - <u>静态工厂方法</u>不需要每次调用时都创建一个对象，允许创建不可变类、缓存实例。
  - <u>静态工厂方法</u>可以反悔其返回类型的任何子类型的对象。
  - <u>静态工厂方法</u>返回对象的类可以根据输入参数的不同而不同。
  - <u>静态工厂方法</u>在编写包含该方法的类时，返回的对象的类不需要存在。
- 缺点
  - 如果类没有`public`或`protected`类型的<u>构造方法</u>，那么该类就无法被子类化。
  - 程序员难以发现<u>静态工厂方法</u>。

#### 2、当构造方法参数过多时使用建造者模式

`Builder`模式结合了<u>可伸缩构造方法</u>模式的安全性和`JavaBean`模式的可读性。

#### 3、使用私有构造方法或枚举类实现单例属性

<u>单一元素枚举类</u>通常是实现单例的最佳方式。

#### 4、使用私有构造器方法执行非实例化

试图通过创建<u>抽象类</u>来强制执行<u>非实例化</u>是行不通的。

可以通过包含一个<u>私有构造方法</u>来实现类的<u>非实例化</u>。

#### 5、依赖注入优于引用资源

<u>静态工具类</u>和<u>单例类</u>不适合用来实现以来一个或多个底层资源的类。

将资源或工厂传递给<u>构造方法</u>，以创建实例，即，依赖注入。

#### 6、避免创建不必要的对象

优先使用<u>基本类型</u>而不是<u>包装类型</u>，同时要注意无意识的<u>自动装箱</u>。

> 创建额外的对象以增强程序的清晰度、简单性或功能性通常是件好事。

#### 7、消除过期的对象引用

消除过期的对象引用，以避免内存泄漏。

当一个类自己管理内存时，程序员就需要警惕内存泄漏问题。

#### 8、避免使用`Finalizer`和`Cleaner`

能不用就不用，并且大概率用不到。

#### 9、`try-with-resources`优于`try-finally`

`try-with-resources`更加方便、简洁。

### 三、对于所有对象都通用的方法

#### 10、重写`equals`时遵守通用约定

重写`equals`时要遵守自反性、对称性、传递性、一致性、非空性。

推荐使用**Google**的开源框架AutoValue。

#### 11、重写`equals`时同时也要重写`hashCode`

求得属性对<u>散列值</u>`c`，然后循环执行`result = 31 * result + c;`来计算对象的<u>散列值</u>。

或者使用**Guava**的`com.google.common.hash.Hashing`。

如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存<u>散列值</u>，而不是在每次请求时重新计算哈希码。

#### 12、始终要重写`toString`

通过重写`toString()`来输出有效内容，可以让调试过程更加方便。

实现`toString()`时，必须在文档中指定返回值的*格式*，如果没有使用格式，也需要在文档中指明。

<u>静态工具类</u>无需重写`toString()`。

#### 13、谨慎地重写`clone`

重写`clone()`时需要注意的事项很多，所以，新的接口不应该继承它，新的可扩展类不应该实现它，如有需要，可使用<u>复制构造方法</u>或<u>复制工厂</u>。

> 重写`clone()`时，方法的返回类型可以是重写方法的返回类型的子类。
>
> 如果对象的每个属性包含原始值或对不可变对象的引用，则`super.clone()`返回的对象可能正是你所需要的，不需要进一步的处理。但如果对象某个属性包含对可变对象的引用，则在重写`clone()`时需要对该属性的内部进行复制。
>
> - <u>不可变类</u>不应提供`clone()`，因为这只会浪费复制。
> - 当可变对象是数组时，此时不必将某一类型的数组转换为`Object[]`，因为在数组上调用`clone()`会返回一个数组，其运行时和编译时类型与被克隆的数组相同。
> - 如果引用可变对象的属性使用`final`进行修饰，那么就没法赋值了，只能移除`final`。
>
> 与<u>构造方法</u>一样，`clone()`绝对不可以在构建过程中调用一个可以重写的方法，否则子类有机会在克隆中修复它的状态之前执行该方法，进而导致克隆和原始对象的损坏。
>
> 在设计父类时，通常有两种选择，但无论选择哪一种，都不应该实现`Clonable`接口，但可以选择通过实现正确运行的`protected clone()`来模仿`Object.clone()`。
>
> 如果类有线程安全的要求，那么在重写`clone()`是不要忘了进行同步。

#### 14、考虑实现`Comparable`接口

`Comparable.compareTo()`与`Object.equals()`相似，但是前者支持泛型，用于比较大小。

Java类库中的绝大部分值类、枚举类都实现了`Comparable`接口。

实现`Comparable`也应遵守自反性、对称性、传递性。

重写`Comparable.compareTo()`时，请避免使用`<`和`>`，应使用包装类中的静态方法`compare()`或`Comparator`接口中的构建方法。

### 四、类和接口

#### 15、使类和成员的可访问性最小化

> **良好的封装**是软件设计的基本原则。
>
> - **良好的封装**有助于组件的分离/解耦，进而有助于组件的独立开发、测试、理解、使用、修改，而这能加速系统的开发、降低维护的成本。
> - **良好的封装**本身不会带来良好的性能，但是有助于分析/确定组件的性能，这样在优化某些组件时不会影响其它正确的组件。
> - **良好的封装**增加了代码的可重用度，同时也降低了构建大型系统的风险。

要做到**良好的封装**，要尽可能地让每个类或成员不可访问。

> 成员包括属性、方法、嵌套类和嵌套接口。

公共类的实例属性很少使用`public`进行修饰，并且带有<u>公共可变属性</u>的类通常不是线程安全的。

> 即使该属性使用了`final`进行修饰，并且引用了一个不可变的对象，而一旦将其公开就意味着放弃了切换到新的内部数据表示的灵活性。
>
> 失去灵活性的问题适用于静态属性，但有一个例外：经`public static final`修饰的常量是类的抽象的一部分。
>
> 而例外的例外是，如果经`public static final`修饰的常量是**数组**，那么直接返回该数组的行为是错误的，因为非零长度的数组总是可变的，此时应返回该数组的一个快照/副本。

#### 16、在公共类而非公共属性中使用访问方法

如果一个类在其包之外是可访问的，则应该提供访问方法来保留更改类内部表示的灵活性。

> 但如果一个类是<u>包级私有</u>的，或者是一个<u>私有内部类</u>，则直接暴露它的数据属性也没有太大问题。

#### 17、使可变性最小化

与<u>可变类</u>相比，<u>不可变类</u>更易于设计、实现、使用，更不容易出错，更安全。

> 不可变对象本质上是线程安全的，因为它们不需要同步。

<u>不可变类</u>的设计需遵循：

1. 不提供修改对象状态的方法（mutators，设值方法）。
2. 确保该类不能被继承。
   1. 使用`final`修饰类来实现。
   2. 或者，可以使所有的<u>构造方法</u><u>私有</u>或<u>包级私有</u>，并添加<u>公共静态工厂</u>。
3. 所有字段都用`final`来修饰。
  1. 但是可以放宽该条原则以提高性能。
4. 所有字段都用`private`来修饰。
5. 确保对任何可变组件的互斥访问。

> <u>不可变类</u>的主要缺点是对于每个不同的值都需要一个单独的对象，而创建这些对象的代价可能很高，进而影响性能。
>
> 对此，可为<u>不可变类</u>创建一个<u>包级私有的可变伙伴类</u>，如`String`和`StringBuilder`。

#### 18、组合优于继承

<u>继承</u>虽然强大，但是破坏了<u>封装</u>，而<u>组合</u>不会。

只有在<u>子类</u>和<u>父类</u>存在真正的父子关系时才可以使用。

> 在包中使用<u>继承</u>是安全的，因为<u>子类</u>和<u>父类</u>都在同一个程序员的控制之中。
>
> <u>组合</u>涉及<u>包装类</u>和<u>被包装类</u>，也被称为<u>装饰器模式</u>。
>
> <u>组合</u>和<u>转发</u>的结合被不准确地称为<u>委托</u>（delegation），而严格意义上的<u>委托</u>需要<u>包装对象</u>把自身传递给<u>被包装对象</u>。

#### 19、要么设计继承并提供文档说明，要么禁止用继承

对于 *专门为继承而设计的类*，其每个`public`或者`protected`方法的文档中，必须指明该方法调用哪些可重写方法，以及这些方法以何种顺序调用的，以及每次调用的结果又是如何影响后续处理，并遵守这些描述。否则，<u>子类</u>就会依赖<u>父类</u>的实现细节，如果<u>父类</u>的实现发生了变化，<u>子类</u>就有可能遭到破坏。

> 好的API文档应该是描述该方法做了什么，而不是描述方法是如何做到的。
>
> *编写子类* 是测试 *专门为继承而设计的类* 的唯一方法。通常来说，三个子类足以测试一个可继承的类，而这些子类应该由父类作者以外的人编写。

<u>构造方法</u>绝不能直接或间接地调用可重写的方法。

#### 20、接口优于抽象类

Java只允许单一继承，没有接口来得灵活。

当接口方法有明显的方法实现时，可以提供<u>默认方法</u>。

> 但默认方法有部分限制：
>
> - `Object`类中方法，如`equals()`和`hashCode()`，不允许提供<u>默认方法</u>。
> - 接口不允许包含<u>实例属性</u>或<u>非公共静态成员</u>，<u>私有静态方法</u>除外。
> - 不能将<u>默认方法</u>添加到不受控制的接口中。

Abstract Skeletal Implementation Class，抽象的骨架实现类，将<u>接口</u>和<u>抽象类</u>的优点结合起来。

> 按照惯例，<u>抽象骨架实现类</u>被称为`AbstractInterface`，如：`AbstractCollection`，`AbstractSet`。

#### 21、为后代设计接口

Java8新增的<u>默认方法</u>是为了允许将方法添加到现有的接口。

> 使用<u>默认方法</u>可以将新的方法添加到现有接口中，但不能保证这些方法可以在所有已有的实现中使用，因为在Java8之前，这些实现是用默认的接口编写的，这些默认接口永远不会获得任何新的方法，如`org.apache.commons.collections4.collection.SynchronizedCollection`。所以应尽量避免使用<u>默认方法向</u>现有接口中添加新的方法。
>
> Java8向核心集合接口中添加了许多新的<u>默认方法</u>，以便使用Lambda。

#### 22、接口只用于定义类型

<u>常量接口</u>是包含常量的接口，也就是只包含经`static final`修饰的属性。

使用<u>常量接口</u>后，使用常量名时就无需再用类名限定了，但是这违反了”接口仅用于标识类型“的初衷，故不推荐使用。

> 对类的使用者来说，类实现一个<u>常量接口</u>是没有意义的，还会令他们感到困惑。
>
> 另外，如果一个非`final`类实现了<u>常量接口</u>，那么它的所有子类的命名空间都会被接口中的常量所污染。

#### 23、类层级结构优于标签类

<u>标签字段</u>是用于标识实例类型的字段，拥有<u>标签字段</u>的类叫做<u>标签类</u>。

<u>标签类</u>冗长的、易出错、效率低，不如用子类表示不同类型的方式。

使用子类的方式将原有的类分成了父类、子类两个层级，故叫做<u>类层级结构</u>。

> <u>标签类</u>实际上仅是对<u>类层级结构</u>的简单的模仿。

#### 24、静态成员类优于非静态成员类

<u>嵌套类</u>是在另一个类中定义的类。“另一个类”叫做<u>顶级类</u>。

<u>嵌套类</u>只应存在于其宿主类中，否则它应该是一个<u>顶级类</u>。

<u>嵌套类</u>有4种：静态成员类、非静态成员类、匿名类和局部类。后三种被称为内部类。

> 4种嵌套类各有用途：
>
> - 如果一个成员类的每个实例都需要引用其宿主实例，则使其成为<u>非静态</u>的；否则，使其静态。
> - 如果一个类属于一个方法内部，且只需要从一个地方创建其实例，且存在一个预置类型来说明这个类的特征，那么将其作为<u>匿名类</u>；否则，把它变成局部类。

> 另外：
>
> - 如果一个<u>包级私有顶级类</u>或<u>接口</u>只被某个类使用，那么可以考虑将该<u>包级私有顶级类</u>或<u>接口</u>作为该类的<u>私有静态嵌套类</u>。
> - <u>非静态成员类</u>的每个实例都有一个对其宿主实例的隐藏的外部引用，而存储这个引用会有额外的时空开销，同时会有<u>内存泄露</u>的风险。
> - <u>匿名类</u>虽然有很多限制，但在引入Lambda之前，它是函数式编程的首选。
> - <u>局部类</u>很少被使用。

#### 25、将源文件限制为单个顶级类

虽然Java允许在单个源文件中定义多个<u>顶级类</u>，但这样做没有任何好处，反而存在重大风险。可考虑使用<u>静态成员类</u>代替这种做法。

### 五、泛型

### 六、枚举和注解

### 七、Lambda和Stream

### 八、方法

### 九、通用编程

### 十、异常

### 十一、并发

### 十二、序列化

